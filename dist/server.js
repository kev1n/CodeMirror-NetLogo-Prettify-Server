
      // Fix for CommonJS modules
      import { createRequire } from 'module';
      const require = createRequire(import.meta.url);
    

// src/server.ts
import express from "express";
import cors from "cors";
import bodyParser from "body-parser";
import { JSDOM } from "jsdom";

// src/editor.ts
import { EditorView as EditorView8, keymap as keymap2, placeholder } from "@codemirror/view";

// node_modules/@marijn/find-cluster-break/src/index.js
var rangeFrom = [];
var rangeTo = [];
(() => {
  let numbers = "lc,34,7n,7,7b,19,,,,2,,2,,,20,b,1c,l,g,,2t,7,2,6,2,2,,4,z,,u,r,2j,b,1m,9,9,,o,4,,9,,3,,5,17,3,3b,f,,w,1j,,,,4,8,4,,3,7,a,2,t,,1m,,,,2,4,8,,9,,a,2,q,,2,2,1l,,4,2,4,2,2,3,3,,u,2,3,,b,2,1l,,4,5,,2,4,,k,2,m,6,,,1m,,,2,,4,8,,7,3,a,2,u,,1n,,,,c,,9,,14,,3,,1l,3,5,3,,4,7,2,b,2,t,,1m,,2,,2,,3,,5,2,7,2,b,2,s,2,1l,2,,,2,4,8,,9,,a,2,t,,20,,4,,2,3,,,8,,29,,2,7,c,8,2q,,2,9,b,6,22,2,r,,,,,,1j,e,,5,,2,5,b,,10,9,,2u,4,,6,,2,2,2,p,2,4,3,g,4,d,,2,2,6,,f,,jj,3,qa,3,t,3,t,2,u,2,1s,2,,7,8,,2,b,9,,19,3,3b,2,y,,3a,3,4,2,9,,6,3,63,2,2,,1m,,,7,,,,,2,8,6,a,2,,1c,h,1r,4,1c,7,,,5,,14,9,c,2,w,4,2,2,,3,1k,,,2,3,,,3,1m,8,2,2,48,3,,d,,7,4,,6,,3,2,5i,1m,,5,ek,,5f,x,2da,3,3x,,2o,w,fe,6,2x,2,n9w,4,,a,w,2,28,2,7k,,3,,4,,p,2,5,,47,2,q,i,d,,12,8,p,b,1a,3,1c,,2,4,2,2,13,,1v,6,2,2,2,2,c,,8,,1b,,1f,,,3,2,2,5,2,,,16,2,8,,6m,,2,,4,,fn4,,kh,g,g,g,a6,2,gt,,6a,,45,5,1ae,3,,2,5,4,14,3,4,,4l,2,fx,4,ar,2,49,b,4w,,1i,f,1k,3,1d,4,2,2,1x,3,10,5,,8,1q,,c,2,1g,9,a,4,2,,2n,3,2,,,2,6,,4g,,3,8,l,2,1l,2,,,,,m,,e,7,3,5,5f,8,2,3,,,n,,29,,2,6,,,2,,,2,,2,6j,,2,4,6,2,,2,r,2,2d,8,2,,,2,2y,,,,2,6,,,2t,3,2,4,,5,77,9,,2,6t,,a,2,,,4,,40,4,2,2,4,,w,a,14,6,2,4,8,,9,6,2,3,1a,d,,2,ba,7,,6,,,2a,m,2,7,,2,,2,3e,6,3,,,2,,7,,,20,2,3,,,,9n,2,f0b,5,1n,7,t4,,1r,4,29,,f5k,2,43q,,,3,4,5,8,8,2,7,u,4,44,3,1iz,1j,4,1e,8,,e,,m,5,,f,11s,7,,h,2,7,,2,,5,79,7,c5,4,15s,7,31,7,240,5,gx7k,2o,3k,6o".split(",").map((s) => s ? parseInt(s, 36) : 1);
  for (let i = 0, n = 0; i < numbers.length; i++)
    (i % 2 ? rangeTo : rangeFrom).push(n = n + numbers[i]);
})();
function isExtendingChar(code) {
  if (code < 768) return false;
  for (let from = 0, to = rangeFrom.length; ; ) {
    let mid = from + to >> 1;
    if (code < rangeFrom[mid]) to = mid;
    else if (code >= rangeTo[mid]) from = mid + 1;
    else return true;
    if (from == to) return false;
  }
}
function isRegionalIndicator(code) {
  return code >= 127462 && code <= 127487;
}
var ZWJ = 8205;
function findClusterBreak(str, pos, forward = true, includeExtending = true) {
  return (forward ? nextClusterBreak : prevClusterBreak)(str, pos, includeExtending);
}
function nextClusterBreak(str, pos, includeExtending) {
  if (pos == str.length) return pos;
  if (pos && surrogateLow(str.charCodeAt(pos)) && surrogateHigh(str.charCodeAt(pos - 1))) pos--;
  let prev = codePointAt(str, pos);
  pos += codePointSize(prev);
  while (pos < str.length) {
    let next = codePointAt(str, pos);
    if (prev == ZWJ || next == ZWJ || includeExtending && isExtendingChar(next)) {
      pos += codePointSize(next);
      prev = next;
    } else if (isRegionalIndicator(next)) {
      let countBefore = 0, i = pos - 2;
      while (i >= 0 && isRegionalIndicator(codePointAt(str, i))) {
        countBefore++;
        i -= 2;
      }
      if (countBefore % 2 == 0) break;
      else pos += 2;
    } else {
      break;
    }
  }
  return pos;
}
function prevClusterBreak(str, pos, includeExtending) {
  while (pos > 0) {
    let found = nextClusterBreak(str, pos - 2, includeExtending);
    if (found < pos) return found;
    pos--;
  }
  return 0;
}
function codePointAt(str, pos) {
  let code0 = str.charCodeAt(pos);
  if (!surrogateHigh(code0) || pos + 1 == str.length) return code0;
  let code1 = str.charCodeAt(pos + 1);
  if (!surrogateLow(code1)) return code0;
  return (code0 - 55296 << 10) + (code1 - 56320) + 65536;
}
function surrogateLow(ch) {
  return ch >= 56320 && ch < 57344;
}
function surrogateHigh(ch) {
  return ch >= 55296 && ch < 56320;
}
function codePointSize(code) {
  return code < 65536 ? 1 : 2;
}

// node_modules/@codemirror/state/dist/index.js
var Text = class _Text {
  /**
  Get the line description around the given position.
  */
  lineAt(pos) {
    if (pos < 0 || pos > this.length)
      throw new RangeError(`Invalid position ${pos} in document of length ${this.length}`);
    return this.lineInner(pos, false, 1, 0);
  }
  /**
  Get the description for the given (1-based) line number.
  */
  line(n) {
    if (n < 1 || n > this.lines)
      throw new RangeError(`Invalid line number ${n} in ${this.lines}-line document`);
    return this.lineInner(n, true, 1, 0);
  }
  /**
  Replace a range of the text with the given content.
  */
  replace(from, to, text) {
    [from, to] = clip(this, from, to);
    let parts = [];
    this.decompose(
      0,
      from,
      parts,
      2
      /* Open.To */
    );
    if (text.length)
      text.decompose(
        0,
        text.length,
        parts,
        1 | 2
        /* Open.To */
      );
    this.decompose(
      to,
      this.length,
      parts,
      1
      /* Open.From */
    );
    return TextNode.from(parts, this.length - (to - from) + text.length);
  }
  /**
  Append another document to this one.
  */
  append(other) {
    return this.replace(this.length, this.length, other);
  }
  /**
  Retrieve the text between the given points.
  */
  slice(from, to = this.length) {
    [from, to] = clip(this, from, to);
    let parts = [];
    this.decompose(from, to, parts, 0);
    return TextNode.from(parts, to - from);
  }
  /**
  Test whether this text is equal to another instance.
  */
  eq(other) {
    if (other == this)
      return true;
    if (other.length != this.length || other.lines != this.lines)
      return false;
    let start = this.scanIdentical(other, 1), end = this.length - this.scanIdentical(other, -1);
    let a = new RawTextCursor(this), b = new RawTextCursor(other);
    for (let skip = start, pos = start; ; ) {
      a.next(skip);
      b.next(skip);
      skip = 0;
      if (a.lineBreak != b.lineBreak || a.done != b.done || a.value != b.value)
        return false;
      pos += a.value.length;
      if (a.done || pos >= end)
        return true;
    }
  }
  /**
  Iterate over the text. When `dir` is `-1`, iteration happens
  from end to start. This will return lines and the breaks between
  them as separate strings.
  */
  iter(dir = 1) {
    return new RawTextCursor(this, dir);
  }
  /**
  Iterate over a range of the text. When `from` > `to`, the
  iterator will run in reverse.
  */
  iterRange(from, to = this.length) {
    return new PartialTextCursor(this, from, to);
  }
  /**
  Return a cursor that iterates over the given range of lines,
  _without_ returning the line breaks between, and yielding empty
  strings for empty lines.
  
  When `from` and `to` are given, they should be 1-based line numbers.
  */
  iterLines(from, to) {
    let inner;
    if (from == null) {
      inner = this.iter();
    } else {
      if (to == null)
        to = this.lines + 1;
      let start = this.line(from).from;
      inner = this.iterRange(start, Math.max(start, to == this.lines + 1 ? this.length : to <= 1 ? 0 : this.line(to - 1).to));
    }
    return new LineCursor(inner);
  }
  /**
  Return the document as a string, using newline characters to
  separate lines.
  */
  toString() {
    return this.sliceString(0);
  }
  /**
  Convert the document to an array of lines (which can be
  deserialized again via [`Text.of`](https://codemirror.net/6/docs/ref/#state.Text^of)).
  */
  toJSON() {
    let lines = [];
    this.flatten(lines);
    return lines;
  }
  /**
  @internal
  */
  constructor() {
  }
  /**
  Create a `Text` instance for the given array of lines.
  */
  static of(text) {
    if (text.length == 0)
      throw new RangeError("A document must have at least one line");
    if (text.length == 1 && !text[0])
      return _Text.empty;
    return text.length <= 32 ? new TextLeaf(text) : TextNode.from(TextLeaf.split(text, []));
  }
};
var TextLeaf = class _TextLeaf extends Text {
  constructor(text, length = textLength(text)) {
    super();
    this.text = text;
    this.length = length;
  }
  get lines() {
    return this.text.length;
  }
  get children() {
    return null;
  }
  lineInner(target, isLine, line, offset) {
    for (let i = 0; ; i++) {
      let string2 = this.text[i], end = offset + string2.length;
      if ((isLine ? line : end) >= target)
        return new Line(offset, end, line, string2);
      offset = end + 1;
      line++;
    }
  }
  decompose(from, to, target, open) {
    let text = from <= 0 && to >= this.length ? this : new _TextLeaf(sliceText(this.text, from, to), Math.min(to, this.length) - Math.max(0, from));
    if (open & 1) {
      let prev = target.pop();
      let joined = appendText(text.text, prev.text.slice(), 0, text.length);
      if (joined.length <= 32) {
        target.push(new _TextLeaf(joined, prev.length + text.length));
      } else {
        let mid = joined.length >> 1;
        target.push(new _TextLeaf(joined.slice(0, mid)), new _TextLeaf(joined.slice(mid)));
      }
    } else {
      target.push(text);
    }
  }
  replace(from, to, text) {
    if (!(text instanceof _TextLeaf))
      return super.replace(from, to, text);
    [from, to] = clip(this, from, to);
    let lines = appendText(this.text, appendText(text.text, sliceText(this.text, 0, from)), to);
    let newLen = this.length + text.length - (to - from);
    if (lines.length <= 32)
      return new _TextLeaf(lines, newLen);
    return TextNode.from(_TextLeaf.split(lines, []), newLen);
  }
  sliceString(from, to = this.length, lineSep = "\n") {
    [from, to] = clip(this, from, to);
    let result = "";
    for (let pos = 0, i = 0; pos <= to && i < this.text.length; i++) {
      let line = this.text[i], end = pos + line.length;
      if (pos > from && i)
        result += lineSep;
      if (from < end && to > pos)
        result += line.slice(Math.max(0, from - pos), to - pos);
      pos = end + 1;
    }
    return result;
  }
  flatten(target) {
    for (let line of this.text)
      target.push(line);
  }
  scanIdentical() {
    return 0;
  }
  static split(text, target) {
    let part = [], len = -1;
    for (let line of text) {
      part.push(line);
      len += line.length + 1;
      if (part.length == 32) {
        target.push(new _TextLeaf(part, len));
        part = [];
        len = -1;
      }
    }
    if (len > -1)
      target.push(new _TextLeaf(part, len));
    return target;
  }
};
var TextNode = class _TextNode extends Text {
  constructor(children, length) {
    super();
    this.children = children;
    this.length = length;
    this.lines = 0;
    for (let child of children)
      this.lines += child.lines;
  }
  lineInner(target, isLine, line, offset) {
    for (let i = 0; ; i++) {
      let child = this.children[i], end = offset + child.length, endLine = line + child.lines - 1;
      if ((isLine ? endLine : end) >= target)
        return child.lineInner(target, isLine, line, offset);
      offset = end + 1;
      line = endLine + 1;
    }
  }
  decompose(from, to, target, open) {
    for (let i = 0, pos = 0; pos <= to && i < this.children.length; i++) {
      let child = this.children[i], end = pos + child.length;
      if (from <= end && to >= pos) {
        let childOpen = open & ((pos <= from ? 1 : 0) | (end >= to ? 2 : 0));
        if (pos >= from && end <= to && !childOpen)
          target.push(child);
        else
          child.decompose(from - pos, to - pos, target, childOpen);
      }
      pos = end + 1;
    }
  }
  replace(from, to, text) {
    [from, to] = clip(this, from, to);
    if (text.lines < this.lines)
      for (let i = 0, pos = 0; i < this.children.length; i++) {
        let child = this.children[i], end = pos + child.length;
        if (from >= pos && to <= end) {
          let updated = child.replace(from - pos, to - pos, text);
          let totalLines = this.lines - child.lines + updated.lines;
          if (updated.lines < totalLines >> 5 - 1 && updated.lines > totalLines >> 5 + 1) {
            let copy = this.children.slice();
            copy[i] = updated;
            return new _TextNode(copy, this.length - (to - from) + text.length);
          }
          return super.replace(pos, end, updated);
        }
        pos = end + 1;
      }
    return super.replace(from, to, text);
  }
  sliceString(from, to = this.length, lineSep = "\n") {
    [from, to] = clip(this, from, to);
    let result = "";
    for (let i = 0, pos = 0; i < this.children.length && pos <= to; i++) {
      let child = this.children[i], end = pos + child.length;
      if (pos > from && i)
        result += lineSep;
      if (from < end && to > pos)
        result += child.sliceString(from - pos, to - pos, lineSep);
      pos = end + 1;
    }
    return result;
  }
  flatten(target) {
    for (let child of this.children)
      child.flatten(target);
  }
  scanIdentical(other, dir) {
    if (!(other instanceof _TextNode))
      return 0;
    let length = 0;
    let [iA, iB, eA, eB] = dir > 0 ? [0, 0, this.children.length, other.children.length] : [this.children.length - 1, other.children.length - 1, -1, -1];
    for (; ; iA += dir, iB += dir) {
      if (iA == eA || iB == eB)
        return length;
      let chA = this.children[iA], chB = other.children[iB];
      if (chA != chB)
        return length + chA.scanIdentical(chB, dir);
      length += chA.length + 1;
    }
  }
  static from(children, length = children.reduce((l, ch) => l + ch.length + 1, -1)) {
    let lines = 0;
    for (let ch of children)
      lines += ch.lines;
    if (lines < 32) {
      let flat = [];
      for (let ch of children)
        ch.flatten(flat);
      return new TextLeaf(flat, length);
    }
    let chunk = Math.max(
      32,
      lines >> 5
      /* Tree.BranchShift */
    ), maxChunk = chunk << 1, minChunk = chunk >> 1;
    let chunked = [], currentLines = 0, currentLen = -1, currentChunk = [];
    function add(child) {
      let last;
      if (child.lines > maxChunk && child instanceof _TextNode) {
        for (let node of child.children)
          add(node);
      } else if (child.lines > minChunk && (currentLines > minChunk || !currentLines)) {
        flush();
        chunked.push(child);
      } else if (child instanceof TextLeaf && currentLines && (last = currentChunk[currentChunk.length - 1]) instanceof TextLeaf && child.lines + last.lines <= 32) {
        currentLines += child.lines;
        currentLen += child.length + 1;
        currentChunk[currentChunk.length - 1] = new TextLeaf(last.text.concat(child.text), last.length + 1 + child.length);
      } else {
        if (currentLines + child.lines > chunk)
          flush();
        currentLines += child.lines;
        currentLen += child.length + 1;
        currentChunk.push(child);
      }
    }
    function flush() {
      if (currentLines == 0)
        return;
      chunked.push(currentChunk.length == 1 ? currentChunk[0] : _TextNode.from(currentChunk, currentLen));
      currentLen = -1;
      currentLines = currentChunk.length = 0;
    }
    for (let child of children)
      add(child);
    flush();
    return chunked.length == 1 ? chunked[0] : new _TextNode(chunked, length);
  }
};
Text.empty = /* @__PURE__ */ new TextLeaf([""], 0);
function textLength(text) {
  let length = -1;
  for (let line of text)
    length += line.length + 1;
  return length;
}
function appendText(text, target, from = 0, to = 1e9) {
  for (let pos = 0, i = 0, first = true; i < text.length && pos <= to; i++) {
    let line = text[i], end = pos + line.length;
    if (end >= from) {
      if (end > to)
        line = line.slice(0, to - pos);
      if (pos < from)
        line = line.slice(from - pos);
      if (first) {
        target[target.length - 1] += line;
        first = false;
      } else
        target.push(line);
    }
    pos = end + 1;
  }
  return target;
}
function sliceText(text, from, to) {
  return appendText(text, [""], from, to);
}
var RawTextCursor = class {
  constructor(text, dir = 1) {
    this.dir = dir;
    this.done = false;
    this.lineBreak = false;
    this.value = "";
    this.nodes = [text];
    this.offsets = [dir > 0 ? 1 : (text instanceof TextLeaf ? text.text.length : text.children.length) << 1];
  }
  nextInner(skip, dir) {
    this.done = this.lineBreak = false;
    for (; ; ) {
      let last = this.nodes.length - 1;
      let top = this.nodes[last], offsetValue = this.offsets[last], offset = offsetValue >> 1;
      let size = top instanceof TextLeaf ? top.text.length : top.children.length;
      if (offset == (dir > 0 ? size : 0)) {
        if (last == 0) {
          this.done = true;
          this.value = "";
          return this;
        }
        if (dir > 0)
          this.offsets[last - 1]++;
        this.nodes.pop();
        this.offsets.pop();
      } else if ((offsetValue & 1) == (dir > 0 ? 0 : 1)) {
        this.offsets[last] += dir;
        if (skip == 0) {
          this.lineBreak = true;
          this.value = "\n";
          return this;
        }
        skip--;
      } else if (top instanceof TextLeaf) {
        let next = top.text[offset + (dir < 0 ? -1 : 0)];
        this.offsets[last] += dir;
        if (next.length > Math.max(0, skip)) {
          this.value = skip == 0 ? next : dir > 0 ? next.slice(skip) : next.slice(0, next.length - skip);
          return this;
        }
        skip -= next.length;
      } else {
        let next = top.children[offset + (dir < 0 ? -1 : 0)];
        if (skip > next.length) {
          skip -= next.length;
          this.offsets[last] += dir;
        } else {
          if (dir < 0)
            this.offsets[last]--;
          this.nodes.push(next);
          this.offsets.push(dir > 0 ? 1 : (next instanceof TextLeaf ? next.text.length : next.children.length) << 1);
        }
      }
    }
  }
  next(skip = 0) {
    if (skip < 0) {
      this.nextInner(-skip, -this.dir);
      skip = this.value.length;
    }
    return this.nextInner(skip, this.dir);
  }
};
var PartialTextCursor = class {
  constructor(text, start, end) {
    this.value = "";
    this.done = false;
    this.cursor = new RawTextCursor(text, start > end ? -1 : 1);
    this.pos = start > end ? text.length : 0;
    this.from = Math.min(start, end);
    this.to = Math.max(start, end);
  }
  nextInner(skip, dir) {
    if (dir < 0 ? this.pos <= this.from : this.pos >= this.to) {
      this.value = "";
      this.done = true;
      return this;
    }
    skip += Math.max(0, dir < 0 ? this.pos - this.to : this.from - this.pos);
    let limit = dir < 0 ? this.pos - this.from : this.to - this.pos;
    if (skip > limit)
      skip = limit;
    limit -= skip;
    let { value } = this.cursor.next(skip);
    this.pos += (value.length + skip) * dir;
    this.value = value.length <= limit ? value : dir < 0 ? value.slice(value.length - limit) : value.slice(0, limit);
    this.done = !this.value;
    return this;
  }
  next(skip = 0) {
    if (skip < 0)
      skip = Math.max(skip, this.from - this.pos);
    else if (skip > 0)
      skip = Math.min(skip, this.to - this.pos);
    return this.nextInner(skip, this.cursor.dir);
  }
  get lineBreak() {
    return this.cursor.lineBreak && this.value != "";
  }
};
var LineCursor = class {
  constructor(inner) {
    this.inner = inner;
    this.afterBreak = true;
    this.value = "";
    this.done = false;
  }
  next(skip = 0) {
    let { done, lineBreak, value } = this.inner.next(skip);
    if (done && this.afterBreak) {
      this.value = "";
      this.afterBreak = false;
    } else if (done) {
      this.done = true;
      this.value = "";
    } else if (lineBreak) {
      if (this.afterBreak) {
        this.value = "";
      } else {
        this.afterBreak = true;
        this.next();
      }
    } else {
      this.value = value;
      this.afterBreak = false;
    }
    return this;
  }
  get lineBreak() {
    return false;
  }
};
if (typeof Symbol != "undefined") {
  Text.prototype[Symbol.iterator] = function() {
    return this.iter();
  };
  RawTextCursor.prototype[Symbol.iterator] = PartialTextCursor.prototype[Symbol.iterator] = LineCursor.prototype[Symbol.iterator] = function() {
    return this;
  };
}
var Line = class {
  /**
  @internal
  */
  constructor(from, to, number2, text) {
    this.from = from;
    this.to = to;
    this.number = number2;
    this.text = text;
  }
  /**
  The length of the line (not including any line break after it).
  */
  get length() {
    return this.to - this.from;
  }
};
function clip(text, from, to) {
  from = Math.max(0, Math.min(text.length, from));
  return [from, Math.max(from, Math.min(text.length, to))];
}
function findClusterBreak2(str, pos, forward = true, includeExtending = true) {
  return findClusterBreak(str, pos, forward, includeExtending);
}
function surrogateLow2(ch) {
  return ch >= 56320 && ch < 57344;
}
function surrogateHigh2(ch) {
  return ch >= 55296 && ch < 56320;
}
function codePointAt2(str, pos) {
  let code0 = str.charCodeAt(pos);
  if (!surrogateHigh2(code0) || pos + 1 == str.length)
    return code0;
  let code1 = str.charCodeAt(pos + 1);
  if (!surrogateLow2(code1))
    return code0;
  return (code0 - 55296 << 10) + (code1 - 56320) + 65536;
}
function fromCodePoint(code) {
  if (code <= 65535)
    return String.fromCharCode(code);
  code -= 65536;
  return String.fromCharCode((code >> 10) + 55296, (code & 1023) + 56320);
}
function codePointSize2(code) {
  return code < 65536 ? 1 : 2;
}
var DefaultSplit = /\r\n?|\n/;
var MapMode = /* @__PURE__ */ function(MapMode2) {
  MapMode2[MapMode2["Simple"] = 0] = "Simple";
  MapMode2[MapMode2["TrackDel"] = 1] = "TrackDel";
  MapMode2[MapMode2["TrackBefore"] = 2] = "TrackBefore";
  MapMode2[MapMode2["TrackAfter"] = 3] = "TrackAfter";
  return MapMode2;
}(MapMode || (MapMode = {}));
var ChangeDesc = class _ChangeDesc {
  // Sections are encoded as pairs of integers. The first is the
  // length in the current document, and the second is -1 for
  // unaffected sections, and the length of the replacement content
  // otherwise. So an insertion would be (0, n>0), a deletion (n>0,
  // 0), and a replacement two positive numbers.
  /**
  @internal
  */
  constructor(sections) {
    this.sections = sections;
  }
  /**
  The length of the document before the change.
  */
  get length() {
    let result = 0;
    for (let i = 0; i < this.sections.length; i += 2)
      result += this.sections[i];
    return result;
  }
  /**
  The length of the document after the change.
  */
  get newLength() {
    let result = 0;
    for (let i = 0; i < this.sections.length; i += 2) {
      let ins = this.sections[i + 1];
      result += ins < 0 ? this.sections[i] : ins;
    }
    return result;
  }
  /**
  False when there are actual changes in this set.
  */
  get empty() {
    return this.sections.length == 0 || this.sections.length == 2 && this.sections[1] < 0;
  }
  /**
  Iterate over the unchanged parts left by these changes. `posA`
  provides the position of the range in the old document, `posB`
  the new position in the changed document.
  */
  iterGaps(f) {
    for (let i = 0, posA = 0, posB = 0; i < this.sections.length; ) {
      let len = this.sections[i++], ins = this.sections[i++];
      if (ins < 0) {
        f(posA, posB, len);
        posB += len;
      } else {
        posB += ins;
      }
      posA += len;
    }
  }
  /**
  Iterate over the ranges changed by these changes. (See
  [`ChangeSet.iterChanges`](https://codemirror.net/6/docs/ref/#state.ChangeSet.iterChanges) for a
  variant that also provides you with the inserted text.)
  `fromA`/`toA` provides the extent of the change in the starting
  document, `fromB`/`toB` the extent of the replacement in the
  changed document.
  
  When `individual` is true, adjacent changes (which are kept
  separate for [position mapping](https://codemirror.net/6/docs/ref/#state.ChangeDesc.mapPos)) are
  reported separately.
  */
  iterChangedRanges(f, individual = false) {
    iterChanges(this, f, individual);
  }
  /**
  Get a description of the inverted form of these changes.
  */
  get invertedDesc() {
    let sections = [];
    for (let i = 0; i < this.sections.length; ) {
      let len = this.sections[i++], ins = this.sections[i++];
      if (ins < 0)
        sections.push(len, ins);
      else
        sections.push(ins, len);
    }
    return new _ChangeDesc(sections);
  }
  /**
  Compute the combined effect of applying another set of changes
  after this one. The length of the document after this set should
  match the length before `other`.
  */
  composeDesc(other) {
    return this.empty ? other : other.empty ? this : composeSets(this, other);
  }
  /**
  Map this description, which should start with the same document
  as `other`, over another set of changes, so that it can be
  applied after it. When `before` is true, map as if the changes
  in `this` happened before the ones in `other`.
  */
  mapDesc(other, before = false) {
    return other.empty ? this : mapSet(this, other, before);
  }
  mapPos(pos, assoc = -1, mode = MapMode.Simple) {
    let posA = 0, posB = 0;
    for (let i = 0; i < this.sections.length; ) {
      let len = this.sections[i++], ins = this.sections[i++], endA = posA + len;
      if (ins < 0) {
        if (endA > pos)
          return posB + (pos - posA);
        posB += len;
      } else {
        if (mode != MapMode.Simple && endA >= pos && (mode == MapMode.TrackDel && posA < pos && endA > pos || mode == MapMode.TrackBefore && posA < pos || mode == MapMode.TrackAfter && endA > pos))
          return null;
        if (endA > pos || endA == pos && assoc < 0 && !len)
          return pos == posA || assoc < 0 ? posB : posB + ins;
        posB += ins;
      }
      posA = endA;
    }
    if (pos > posA)
      throw new RangeError(`Position ${pos} is out of range for changeset of length ${posA}`);
    return posB;
  }
  /**
  Check whether these changes touch a given range. When one of the
  changes entirely covers the range, the string `"cover"` is
  returned.
  */
  touchesRange(from, to = from) {
    for (let i = 0, pos = 0; i < this.sections.length && pos <= to; ) {
      let len = this.sections[i++], ins = this.sections[i++], end = pos + len;
      if (ins >= 0 && pos <= to && end >= from)
        return pos < from && end > to ? "cover" : true;
      pos = end;
    }
    return false;
  }
  /**
  @internal
  */
  toString() {
    let result = "";
    for (let i = 0; i < this.sections.length; ) {
      let len = this.sections[i++], ins = this.sections[i++];
      result += (result ? " " : "") + len + (ins >= 0 ? ":" + ins : "");
    }
    return result;
  }
  /**
  Serialize this change desc to a JSON-representable value.
  */
  toJSON() {
    return this.sections;
  }
  /**
  Create a change desc from its JSON representation (as produced
  by [`toJSON`](https://codemirror.net/6/docs/ref/#state.ChangeDesc.toJSON).
  */
  static fromJSON(json) {
    if (!Array.isArray(json) || json.length % 2 || json.some((a) => typeof a != "number"))
      throw new RangeError("Invalid JSON representation of ChangeDesc");
    return new _ChangeDesc(json);
  }
  /**
  @internal
  */
  static create(sections) {
    return new _ChangeDesc(sections);
  }
};
var ChangeSet = class _ChangeSet extends ChangeDesc {
  constructor(sections, inserted) {
    super(sections);
    this.inserted = inserted;
  }
  /**
  Apply the changes to a document, returning the modified
  document.
  */
  apply(doc) {
    if (this.length != doc.length)
      throw new RangeError("Applying change set to a document with the wrong length");
    iterChanges(this, (fromA, toA, fromB, _toB, text) => doc = doc.replace(fromB, fromB + (toA - fromA), text), false);
    return doc;
  }
  mapDesc(other, before = false) {
    return mapSet(this, other, before, true);
  }
  /**
  Given the document as it existed _before_ the changes, return a
  change set that represents the inverse of this set, which could
  be used to go from the document created by the changes back to
  the document as it existed before the changes.
  */
  invert(doc) {
    let sections = this.sections.slice(), inserted = [];
    for (let i = 0, pos = 0; i < sections.length; i += 2) {
      let len = sections[i], ins = sections[i + 1];
      if (ins >= 0) {
        sections[i] = ins;
        sections[i + 1] = len;
        let index = i >> 1;
        while (inserted.length < index)
          inserted.push(Text.empty);
        inserted.push(len ? doc.slice(pos, pos + len) : Text.empty);
      }
      pos += len;
    }
    return new _ChangeSet(sections, inserted);
  }
  /**
  Combine two subsequent change sets into a single set. `other`
  must start in the document produced by `this`. If `this` goes
  `docA` → `docB` and `other` represents `docB` → `docC`, the
  returned value will represent the change `docA` → `docC`.
  */
  compose(other) {
    return this.empty ? other : other.empty ? this : composeSets(this, other, true);
  }
  /**
  Given another change set starting in the same document, maps this
  change set over the other, producing a new change set that can be
  applied to the document produced by applying `other`. When
  `before` is `true`, order changes as if `this` comes before
  `other`, otherwise (the default) treat `other` as coming first.
  
  Given two changes `A` and `B`, `A.compose(B.map(A))` and
  `B.compose(A.map(B, true))` will produce the same document. This
  provides a basic form of [operational
  transformation](https://en.wikipedia.org/wiki/Operational_transformation),
  and can be used for collaborative editing.
  */
  map(other, before = false) {
    return other.empty ? this : mapSet(this, other, before, true);
  }
  /**
  Iterate over the changed ranges in the document, calling `f` for
  each, with the range in the original document (`fromA`-`toA`)
  and the range that replaces it in the new document
  (`fromB`-`toB`).
  
  When `individual` is true, adjacent changes are reported
  separately.
  */
  iterChanges(f, individual = false) {
    iterChanges(this, f, individual);
  }
  /**
  Get a [change description](https://codemirror.net/6/docs/ref/#state.ChangeDesc) for this change
  set.
  */
  get desc() {
    return ChangeDesc.create(this.sections);
  }
  /**
  @internal
  */
  filter(ranges) {
    let resultSections = [], resultInserted = [], filteredSections = [];
    let iter = new SectionIter(this);
    done: for (let i = 0, pos = 0; ; ) {
      let next = i == ranges.length ? 1e9 : ranges[i++];
      while (pos < next || pos == next && iter.len == 0) {
        if (iter.done)
          break done;
        let len = Math.min(iter.len, next - pos);
        addSection(filteredSections, len, -1);
        let ins = iter.ins == -1 ? -1 : iter.off == 0 ? iter.ins : 0;
        addSection(resultSections, len, ins);
        if (ins > 0)
          addInsert(resultInserted, resultSections, iter.text);
        iter.forward(len);
        pos += len;
      }
      let end = ranges[i++];
      while (pos < end) {
        if (iter.done)
          break done;
        let len = Math.min(iter.len, end - pos);
        addSection(resultSections, len, -1);
        addSection(filteredSections, len, iter.ins == -1 ? -1 : iter.off == 0 ? iter.ins : 0);
        iter.forward(len);
        pos += len;
      }
    }
    return {
      changes: new _ChangeSet(resultSections, resultInserted),
      filtered: ChangeDesc.create(filteredSections)
    };
  }
  /**
  Serialize this change set to a JSON-representable value.
  */
  toJSON() {
    let parts = [];
    for (let i = 0; i < this.sections.length; i += 2) {
      let len = this.sections[i], ins = this.sections[i + 1];
      if (ins < 0)
        parts.push(len);
      else if (ins == 0)
        parts.push([len]);
      else
        parts.push([len].concat(this.inserted[i >> 1].toJSON()));
    }
    return parts;
  }
  /**
  Create a change set for the given changes, for a document of the
  given length, using `lineSep` as line separator.
  */
  static of(changes, length, lineSep) {
    let sections = [], inserted = [], pos = 0;
    let total = null;
    function flush(force = false) {
      if (!force && !sections.length)
        return;
      if (pos < length)
        addSection(sections, length - pos, -1);
      let set = new _ChangeSet(sections, inserted);
      total = total ? total.compose(set.map(total)) : set;
      sections = [];
      inserted = [];
      pos = 0;
    }
    function process2(spec) {
      if (Array.isArray(spec)) {
        for (let sub of spec)
          process2(sub);
      } else if (spec instanceof _ChangeSet) {
        if (spec.length != length)
          throw new RangeError(`Mismatched change set length (got ${spec.length}, expected ${length})`);
        flush();
        total = total ? total.compose(spec.map(total)) : spec;
      } else {
        let { from, to = from, insert: insert2 } = spec;
        if (from > to || from < 0 || to > length)
          throw new RangeError(`Invalid change range ${from} to ${to} (in doc of length ${length})`);
        let insText = !insert2 ? Text.empty : typeof insert2 == "string" ? Text.of(insert2.split(lineSep || DefaultSplit)) : insert2;
        let insLen = insText.length;
        if (from == to && insLen == 0)
          return;
        if (from < pos)
          flush();
        if (from > pos)
          addSection(sections, from - pos, -1);
        addSection(sections, to - from, insLen);
        addInsert(inserted, sections, insText);
        pos = to;
      }
    }
    process2(changes);
    flush(!total);
    return total;
  }
  /**
  Create an empty changeset of the given length.
  */
  static empty(length) {
    return new _ChangeSet(length ? [length, -1] : [], []);
  }
  /**
  Create a changeset from its JSON representation (as produced by
  [`toJSON`](https://codemirror.net/6/docs/ref/#state.ChangeSet.toJSON).
  */
  static fromJSON(json) {
    if (!Array.isArray(json))
      throw new RangeError("Invalid JSON representation of ChangeSet");
    let sections = [], inserted = [];
    for (let i = 0; i < json.length; i++) {
      let part = json[i];
      if (typeof part == "number") {
        sections.push(part, -1);
      } else if (!Array.isArray(part) || typeof part[0] != "number" || part.some((e, i2) => i2 && typeof e != "string")) {
        throw new RangeError("Invalid JSON representation of ChangeSet");
      } else if (part.length == 1) {
        sections.push(part[0], 0);
      } else {
        while (inserted.length < i)
          inserted.push(Text.empty);
        inserted[i] = Text.of(part.slice(1));
        sections.push(part[0], inserted[i].length);
      }
    }
    return new _ChangeSet(sections, inserted);
  }
  /**
  @internal
  */
  static createSet(sections, inserted) {
    return new _ChangeSet(sections, inserted);
  }
};
function addSection(sections, len, ins, forceJoin = false) {
  if (len == 0 && ins <= 0)
    return;
  let last = sections.length - 2;
  if (last >= 0 && ins <= 0 && ins == sections[last + 1])
    sections[last] += len;
  else if (last >= 0 && len == 0 && sections[last] == 0)
    sections[last + 1] += ins;
  else if (forceJoin) {
    sections[last] += len;
    sections[last + 1] += ins;
  } else
    sections.push(len, ins);
}
function addInsert(values, sections, value) {
  if (value.length == 0)
    return;
  let index = sections.length - 2 >> 1;
  if (index < values.length) {
    values[values.length - 1] = values[values.length - 1].append(value);
  } else {
    while (values.length < index)
      values.push(Text.empty);
    values.push(value);
  }
}
function iterChanges(desc, f, individual) {
  let inserted = desc.inserted;
  for (let posA = 0, posB = 0, i = 0; i < desc.sections.length; ) {
    let len = desc.sections[i++], ins = desc.sections[i++];
    if (ins < 0) {
      posA += len;
      posB += len;
    } else {
      let endA = posA, endB = posB, text = Text.empty;
      for (; ; ) {
        endA += len;
        endB += ins;
        if (ins && inserted)
          text = text.append(inserted[i - 2 >> 1]);
        if (individual || i == desc.sections.length || desc.sections[i + 1] < 0)
          break;
        len = desc.sections[i++];
        ins = desc.sections[i++];
      }
      f(posA, endA, posB, endB, text);
      posA = endA;
      posB = endB;
    }
  }
}
function mapSet(setA, setB, before, mkSet = false) {
  let sections = [], insert2 = mkSet ? [] : null;
  let a = new SectionIter(setA), b = new SectionIter(setB);
  for (let inserted = -1; ; ) {
    if (a.done && b.len || b.done && a.len) {
      throw new Error("Mismatched change set lengths");
    } else if (a.ins == -1 && b.ins == -1) {
      let len = Math.min(a.len, b.len);
      addSection(sections, len, -1);
      a.forward(len);
      b.forward(len);
    } else if (b.ins >= 0 && (a.ins < 0 || inserted == a.i || a.off == 0 && (b.len < a.len || b.len == a.len && !before))) {
      let len = b.len;
      addSection(sections, b.ins, -1);
      while (len) {
        let piece = Math.min(a.len, len);
        if (a.ins >= 0 && inserted < a.i && a.len <= piece) {
          addSection(sections, 0, a.ins);
          if (insert2)
            addInsert(insert2, sections, a.text);
          inserted = a.i;
        }
        a.forward(piece);
        len -= piece;
      }
      b.next();
    } else if (a.ins >= 0) {
      let len = 0, left = a.len;
      while (left) {
        if (b.ins == -1) {
          let piece = Math.min(left, b.len);
          len += piece;
          left -= piece;
          b.forward(piece);
        } else if (b.ins == 0 && b.len < left) {
          left -= b.len;
          b.next();
        } else {
          break;
        }
      }
      addSection(sections, len, inserted < a.i ? a.ins : 0);
      if (insert2 && inserted < a.i)
        addInsert(insert2, sections, a.text);
      inserted = a.i;
      a.forward(a.len - left);
    } else if (a.done && b.done) {
      return insert2 ? ChangeSet.createSet(sections, insert2) : ChangeDesc.create(sections);
    } else {
      throw new Error("Mismatched change set lengths");
    }
  }
}
function composeSets(setA, setB, mkSet = false) {
  let sections = [];
  let insert2 = mkSet ? [] : null;
  let a = new SectionIter(setA), b = new SectionIter(setB);
  for (let open = false; ; ) {
    if (a.done && b.done) {
      return insert2 ? ChangeSet.createSet(sections, insert2) : ChangeDesc.create(sections);
    } else if (a.ins == 0) {
      addSection(sections, a.len, 0, open);
      a.next();
    } else if (b.len == 0 && !b.done) {
      addSection(sections, 0, b.ins, open);
      if (insert2)
        addInsert(insert2, sections, b.text);
      b.next();
    } else if (a.done || b.done) {
      throw new Error("Mismatched change set lengths");
    } else {
      let len = Math.min(a.len2, b.len), sectionLen = sections.length;
      if (a.ins == -1) {
        let insB = b.ins == -1 ? -1 : b.off ? 0 : b.ins;
        addSection(sections, len, insB, open);
        if (insert2 && insB)
          addInsert(insert2, sections, b.text);
      } else if (b.ins == -1) {
        addSection(sections, a.off ? 0 : a.len, len, open);
        if (insert2)
          addInsert(insert2, sections, a.textBit(len));
      } else {
        addSection(sections, a.off ? 0 : a.len, b.off ? 0 : b.ins, open);
        if (insert2 && !b.off)
          addInsert(insert2, sections, b.text);
      }
      open = (a.ins > len || b.ins >= 0 && b.len > len) && (open || sections.length > sectionLen);
      a.forward2(len);
      b.forward(len);
    }
  }
}
var SectionIter = class {
  constructor(set) {
    this.set = set;
    this.i = 0;
    this.next();
  }
  next() {
    let { sections } = this.set;
    if (this.i < sections.length) {
      this.len = sections[this.i++];
      this.ins = sections[this.i++];
    } else {
      this.len = 0;
      this.ins = -2;
    }
    this.off = 0;
  }
  get done() {
    return this.ins == -2;
  }
  get len2() {
    return this.ins < 0 ? this.len : this.ins;
  }
  get text() {
    let { inserted } = this.set, index = this.i - 2 >> 1;
    return index >= inserted.length ? Text.empty : inserted[index];
  }
  textBit(len) {
    let { inserted } = this.set, index = this.i - 2 >> 1;
    return index >= inserted.length && !len ? Text.empty : inserted[index].slice(this.off, len == null ? void 0 : this.off + len);
  }
  forward(len) {
    if (len == this.len)
      this.next();
    else {
      this.len -= len;
      this.off += len;
    }
  }
  forward2(len) {
    if (this.ins == -1)
      this.forward(len);
    else if (len == this.ins)
      this.next();
    else {
      this.ins -= len;
      this.off += len;
    }
  }
};
var SelectionRange = class _SelectionRange {
  constructor(from, to, flags) {
    this.from = from;
    this.to = to;
    this.flags = flags;
  }
  /**
  The anchor of the range—the side that doesn't move when you
  extend it.
  */
  get anchor() {
    return this.flags & 32 ? this.to : this.from;
  }
  /**
  The head of the range, which is moved when the range is
  [extended](https://codemirror.net/6/docs/ref/#state.SelectionRange.extend).
  */
  get head() {
    return this.flags & 32 ? this.from : this.to;
  }
  /**
  True when `anchor` and `head` are at the same position.
  */
  get empty() {
    return this.from == this.to;
  }
  /**
  If this is a cursor that is explicitly associated with the
  character on one of its sides, this returns the side. -1 means
  the character before its position, 1 the character after, and 0
  means no association.
  */
  get assoc() {
    return this.flags & 8 ? -1 : this.flags & 16 ? 1 : 0;
  }
  /**
  The bidirectional text level associated with this cursor, if
  any.
  */
  get bidiLevel() {
    let level = this.flags & 7;
    return level == 7 ? null : level;
  }
  /**
  The goal column (stored vertical offset) associated with a
  cursor. This is used to preserve the vertical position when
  [moving](https://codemirror.net/6/docs/ref/#view.EditorView.moveVertically) across
  lines of different length.
  */
  get goalColumn() {
    let value = this.flags >> 6;
    return value == 16777215 ? void 0 : value;
  }
  /**
  Map this range through a change, producing a valid range in the
  updated document.
  */
  map(change, assoc = -1) {
    let from, to;
    if (this.empty) {
      from = to = change.mapPos(this.from, assoc);
    } else {
      from = change.mapPos(this.from, 1);
      to = change.mapPos(this.to, -1);
    }
    return from == this.from && to == this.to ? this : new _SelectionRange(from, to, this.flags);
  }
  /**
  Extend this range to cover at least `from` to `to`.
  */
  extend(from, to = from) {
    if (from <= this.anchor && to >= this.anchor)
      return EditorSelection.range(from, to);
    let head = Math.abs(from - this.anchor) > Math.abs(to - this.anchor) ? from : to;
    return EditorSelection.range(this.anchor, head);
  }
  /**
  Compare this range to another range.
  */
  eq(other, includeAssoc = false) {
    return this.anchor == other.anchor && this.head == other.head && (!includeAssoc || !this.empty || this.assoc == other.assoc);
  }
  /**
  Return a JSON-serializable object representing the range.
  */
  toJSON() {
    return { anchor: this.anchor, head: this.head };
  }
  /**
  Convert a JSON representation of a range to a `SelectionRange`
  instance.
  */
  static fromJSON(json) {
    if (!json || typeof json.anchor != "number" || typeof json.head != "number")
      throw new RangeError("Invalid JSON representation for SelectionRange");
    return EditorSelection.range(json.anchor, json.head);
  }
  /**
  @internal
  */
  static create(from, to, flags) {
    return new _SelectionRange(from, to, flags);
  }
};
var EditorSelection = class _EditorSelection {
  constructor(ranges, mainIndex) {
    this.ranges = ranges;
    this.mainIndex = mainIndex;
  }
  /**
  Map a selection through a change. Used to adjust the selection
  position for changes.
  */
  map(change, assoc = -1) {
    if (change.empty)
      return this;
    return _EditorSelection.create(this.ranges.map((r) => r.map(change, assoc)), this.mainIndex);
  }
  /**
  Compare this selection to another selection. By default, ranges
  are compared only by position. When `includeAssoc` is true,
  cursor ranges must also have the same
  [`assoc`](https://codemirror.net/6/docs/ref/#state.SelectionRange.assoc) value.
  */
  eq(other, includeAssoc = false) {
    if (this.ranges.length != other.ranges.length || this.mainIndex != other.mainIndex)
      return false;
    for (let i = 0; i < this.ranges.length; i++)
      if (!this.ranges[i].eq(other.ranges[i], includeAssoc))
        return false;
    return true;
  }
  /**
  Get the primary selection range. Usually, you should make sure
  your code applies to _all_ ranges, by using methods like
  [`changeByRange`](https://codemirror.net/6/docs/ref/#state.EditorState.changeByRange).
  */
  get main() {
    return this.ranges[this.mainIndex];
  }
  /**
  Make sure the selection only has one range. Returns a selection
  holding only the main range from this selection.
  */
  asSingle() {
    return this.ranges.length == 1 ? this : new _EditorSelection([this.main], 0);
  }
  /**
  Extend this selection with an extra range.
  */
  addRange(range, main = true) {
    return _EditorSelection.create([range].concat(this.ranges), main ? 0 : this.mainIndex + 1);
  }
  /**
  Replace a given range with another range, and then normalize the
  selection to merge and sort ranges if necessary.
  */
  replaceRange(range, which = this.mainIndex) {
    let ranges = this.ranges.slice();
    ranges[which] = range;
    return _EditorSelection.create(ranges, this.mainIndex);
  }
  /**
  Convert this selection to an object that can be serialized to
  JSON.
  */
  toJSON() {
    return { ranges: this.ranges.map((r) => r.toJSON()), main: this.mainIndex };
  }
  /**
  Create a selection from a JSON representation.
  */
  static fromJSON(json) {
    if (!json || !Array.isArray(json.ranges) || typeof json.main != "number" || json.main >= json.ranges.length)
      throw new RangeError("Invalid JSON representation for EditorSelection");
    return new _EditorSelection(json.ranges.map((r) => SelectionRange.fromJSON(r)), json.main);
  }
  /**
  Create a selection holding a single range.
  */
  static single(anchor, head = anchor) {
    return new _EditorSelection([_EditorSelection.range(anchor, head)], 0);
  }
  /**
  Sort and merge the given set of ranges, creating a valid
  selection.
  */
  static create(ranges, mainIndex = 0) {
    if (ranges.length == 0)
      throw new RangeError("A selection needs at least one range");
    for (let pos = 0, i = 0; i < ranges.length; i++) {
      let range = ranges[i];
      if (range.empty ? range.from <= pos : range.from < pos)
        return _EditorSelection.normalized(ranges.slice(), mainIndex);
      pos = range.to;
    }
    return new _EditorSelection(ranges, mainIndex);
  }
  /**
  Create a cursor selection range at the given position. You can
  safely ignore the optional arguments in most situations.
  */
  static cursor(pos, assoc = 0, bidiLevel, goalColumn) {
    return SelectionRange.create(pos, pos, (assoc == 0 ? 0 : assoc < 0 ? 8 : 16) | (bidiLevel == null ? 7 : Math.min(6, bidiLevel)) | (goalColumn !== null && goalColumn !== void 0 ? goalColumn : 16777215) << 6);
  }
  /**
  Create a selection range.
  */
  static range(anchor, head, goalColumn, bidiLevel) {
    let flags = (goalColumn !== null && goalColumn !== void 0 ? goalColumn : 16777215) << 6 | (bidiLevel == null ? 7 : Math.min(6, bidiLevel));
    return head < anchor ? SelectionRange.create(head, anchor, 32 | 16 | flags) : SelectionRange.create(anchor, head, (head > anchor ? 8 : 0) | flags);
  }
  /**
  @internal
  */
  static normalized(ranges, mainIndex = 0) {
    let main = ranges[mainIndex];
    ranges.sort((a, b) => a.from - b.from);
    mainIndex = ranges.indexOf(main);
    for (let i = 1; i < ranges.length; i++) {
      let range = ranges[i], prev = ranges[i - 1];
      if (range.empty ? range.from <= prev.to : range.from < prev.to) {
        let from = prev.from, to = Math.max(range.to, prev.to);
        if (i <= mainIndex)
          mainIndex--;
        ranges.splice(--i, 2, range.anchor > range.head ? _EditorSelection.range(to, from) : _EditorSelection.range(from, to));
      }
    }
    return new _EditorSelection(ranges, mainIndex);
  }
};
function checkSelection(selection, docLength) {
  for (let range of selection.ranges)
    if (range.to > docLength)
      throw new RangeError("Selection points outside of document");
}
var nextID = 0;
var Facet = class _Facet {
  constructor(combine, compareInput, compare2, isStatic, enables) {
    this.combine = combine;
    this.compareInput = compareInput;
    this.compare = compare2;
    this.isStatic = isStatic;
    this.id = nextID++;
    this.default = combine([]);
    this.extensions = typeof enables == "function" ? enables(this) : enables;
  }
  /**
  Returns a facet reader for this facet, which can be used to
  [read](https://codemirror.net/6/docs/ref/#state.EditorState.facet) it but not to define values for it.
  */
  get reader() {
    return this;
  }
  /**
  Define a new facet.
  */
  static define(config2 = {}) {
    return new _Facet(config2.combine || ((a) => a), config2.compareInput || ((a, b) => a === b), config2.compare || (!config2.combine ? sameArray : (a, b) => a === b), !!config2.static, config2.enables);
  }
  /**
  Returns an extension that adds the given value to this facet.
  */
  of(value) {
    return new FacetProvider([], this, 0, value);
  }
  /**
  Create an extension that computes a value for the facet from a
  state. You must take care to declare the parts of the state that
  this value depends on, since your function is only called again
  for a new state when one of those parts changed.
  
  In cases where your value depends only on a single field, you'll
  want to use the [`from`](https://codemirror.net/6/docs/ref/#state.Facet.from) method instead.
  */
  compute(deps, get) {
    if (this.isStatic)
      throw new Error("Can't compute a static facet");
    return new FacetProvider(deps, this, 1, get);
  }
  /**
  Create an extension that computes zero or more values for this
  facet from a state.
  */
  computeN(deps, get) {
    if (this.isStatic)
      throw new Error("Can't compute a static facet");
    return new FacetProvider(deps, this, 2, get);
  }
  from(field, get) {
    if (!get)
      get = (x) => x;
    return this.compute([field], (state) => get(state.field(field)));
  }
};
function sameArray(a, b) {
  return a == b || a.length == b.length && a.every((e, i) => e === b[i]);
}
var FacetProvider = class {
  constructor(dependencies, facet, type, value) {
    this.dependencies = dependencies;
    this.facet = facet;
    this.type = type;
    this.value = value;
    this.id = nextID++;
  }
  dynamicSlot(addresses) {
    var _a;
    let getter = this.value;
    let compare2 = this.facet.compareInput;
    let id = this.id, idx = addresses[id] >> 1, multi = this.type == 2;
    let depDoc = false, depSel = false, depAddrs = [];
    for (let dep of this.dependencies) {
      if (dep == "doc")
        depDoc = true;
      else if (dep == "selection")
        depSel = true;
      else if ((((_a = addresses[dep.id]) !== null && _a !== void 0 ? _a : 1) & 1) == 0)
        depAddrs.push(addresses[dep.id]);
    }
    return {
      create(state) {
        state.values[idx] = getter(state);
        return 1;
      },
      update(state, tr) {
        if (depDoc && tr.docChanged || depSel && (tr.docChanged || tr.selection) || ensureAll(state, depAddrs)) {
          let newVal = getter(state);
          if (multi ? !compareArray(newVal, state.values[idx], compare2) : !compare2(newVal, state.values[idx])) {
            state.values[idx] = newVal;
            return 1;
          }
        }
        return 0;
      },
      reconfigure: (state, oldState) => {
        let newVal, oldAddr = oldState.config.address[id];
        if (oldAddr != null) {
          let oldVal = getAddr(oldState, oldAddr);
          if (this.dependencies.every((dep) => {
            return dep instanceof Facet ? oldState.facet(dep) === state.facet(dep) : dep instanceof StateField ? oldState.field(dep, false) == state.field(dep, false) : true;
          }) || (multi ? compareArray(newVal = getter(state), oldVal, compare2) : compare2(newVal = getter(state), oldVal))) {
            state.values[idx] = oldVal;
            return 0;
          }
        } else {
          newVal = getter(state);
        }
        state.values[idx] = newVal;
        return 1;
      }
    };
  }
};
function compareArray(a, b, compare2) {
  if (a.length != b.length)
    return false;
  for (let i = 0; i < a.length; i++)
    if (!compare2(a[i], b[i]))
      return false;
  return true;
}
function ensureAll(state, addrs) {
  let changed = false;
  for (let addr of addrs)
    if (ensureAddr(state, addr) & 1)
      changed = true;
  return changed;
}
function dynamicFacetSlot(addresses, facet, providers) {
  let providerAddrs = providers.map((p) => addresses[p.id]);
  let providerTypes = providers.map((p) => p.type);
  let dynamic = providerAddrs.filter((p) => !(p & 1));
  let idx = addresses[facet.id] >> 1;
  function get(state) {
    let values = [];
    for (let i = 0; i < providerAddrs.length; i++) {
      let value = getAddr(state, providerAddrs[i]);
      if (providerTypes[i] == 2)
        for (let val of value)
          values.push(val);
      else
        values.push(value);
    }
    return facet.combine(values);
  }
  return {
    create(state) {
      for (let addr of providerAddrs)
        ensureAddr(state, addr);
      state.values[idx] = get(state);
      return 1;
    },
    update(state, tr) {
      if (!ensureAll(state, dynamic))
        return 0;
      let value = get(state);
      if (facet.compare(value, state.values[idx]))
        return 0;
      state.values[idx] = value;
      return 1;
    },
    reconfigure(state, oldState) {
      let depChanged = ensureAll(state, providerAddrs);
      let oldProviders = oldState.config.facets[facet.id], oldValue = oldState.facet(facet);
      if (oldProviders && !depChanged && sameArray(providers, oldProviders)) {
        state.values[idx] = oldValue;
        return 0;
      }
      let value = get(state);
      if (facet.compare(value, oldValue)) {
        state.values[idx] = oldValue;
        return 0;
      }
      state.values[idx] = value;
      return 1;
    }
  };
}
var initField = /* @__PURE__ */ Facet.define({ static: true });
var StateField = class _StateField {
  constructor(id, createF, updateF, compareF, spec) {
    this.id = id;
    this.createF = createF;
    this.updateF = updateF;
    this.compareF = compareF;
    this.spec = spec;
    this.provides = void 0;
  }
  /**
  Define a state field.
  */
  static define(config2) {
    let field = new _StateField(nextID++, config2.create, config2.update, config2.compare || ((a, b) => a === b), config2);
    if (config2.provide)
      field.provides = config2.provide(field);
    return field;
  }
  create(state) {
    let init = state.facet(initField).find((i) => i.field == this);
    return ((init === null || init === void 0 ? void 0 : init.create) || this.createF)(state);
  }
  /**
  @internal
  */
  slot(addresses) {
    let idx = addresses[this.id] >> 1;
    return {
      create: (state) => {
        state.values[idx] = this.create(state);
        return 1;
      },
      update: (state, tr) => {
        let oldVal = state.values[idx];
        let value = this.updateF(oldVal, tr);
        if (this.compareF(oldVal, value))
          return 0;
        state.values[idx] = value;
        return 1;
      },
      reconfigure: (state, oldState) => {
        let init = state.facet(initField), oldInit = oldState.facet(initField), reInit;
        if ((reInit = init.find((i) => i.field == this)) && reInit != oldInit.find((i) => i.field == this)) {
          state.values[idx] = reInit.create(state);
          return 1;
        }
        if (oldState.config.address[this.id] != null) {
          state.values[idx] = oldState.field(this);
          return 0;
        }
        state.values[idx] = this.create(state);
        return 1;
      }
    };
  }
  /**
  Returns an extension that enables this field and overrides the
  way it is initialized. Can be useful when you need to provide a
  non-default starting value for the field.
  */
  init(create) {
    return [this, initField.of({ field: this, create })];
  }
  /**
  State field instances can be used as
  [`Extension`](https://codemirror.net/6/docs/ref/#state.Extension) values to enable the field in a
  given state.
  */
  get extension() {
    return this;
  }
};
var Prec_ = { lowest: 4, low: 3, default: 2, high: 1, highest: 0 };
function prec(value) {
  return (ext) => new PrecExtension(ext, value);
}
var Prec = {
  /**
  The highest precedence level, for extensions that should end up
  near the start of the precedence ordering.
  */
  highest: /* @__PURE__ */ prec(Prec_.highest),
  /**
  A higher-than-default precedence, for extensions that should
  come before those with default precedence.
  */
  high: /* @__PURE__ */ prec(Prec_.high),
  /**
  The default precedence, which is also used for extensions
  without an explicit precedence.
  */
  default: /* @__PURE__ */ prec(Prec_.default),
  /**
  A lower-than-default precedence.
  */
  low: /* @__PURE__ */ prec(Prec_.low),
  /**
  The lowest precedence level. Meant for things that should end up
  near the end of the extension order.
  */
  lowest: /* @__PURE__ */ prec(Prec_.lowest)
};
var PrecExtension = class {
  constructor(inner, prec2) {
    this.inner = inner;
    this.prec = prec2;
  }
};
var Compartment = class _Compartment {
  /**
  Create an instance of this compartment to add to your [state
  configuration](https://codemirror.net/6/docs/ref/#state.EditorStateConfig.extensions).
  */
  of(ext) {
    return new CompartmentInstance(this, ext);
  }
  /**
  Create an [effect](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) that
  reconfigures this compartment.
  */
  reconfigure(content2) {
    return _Compartment.reconfigure.of({ compartment: this, extension: content2 });
  }
  /**
  Get the current content of the compartment in the state, or
  `undefined` if it isn't present.
  */
  get(state) {
    return state.config.compartments.get(this);
  }
};
var CompartmentInstance = class {
  constructor(compartment, inner) {
    this.compartment = compartment;
    this.inner = inner;
  }
};
var Configuration = class _Configuration {
  constructor(base, compartments, dynamicSlots, address, staticValues, facets) {
    this.base = base;
    this.compartments = compartments;
    this.dynamicSlots = dynamicSlots;
    this.address = address;
    this.staticValues = staticValues;
    this.facets = facets;
    this.statusTemplate = [];
    while (this.statusTemplate.length < dynamicSlots.length)
      this.statusTemplate.push(
        0
        /* SlotStatus.Unresolved */
      );
  }
  staticFacet(facet) {
    let addr = this.address[facet.id];
    return addr == null ? facet.default : this.staticValues[addr >> 1];
  }
  static resolve(base, compartments, oldState) {
    let fields = [];
    let facets = /* @__PURE__ */ Object.create(null);
    let newCompartments = /* @__PURE__ */ new Map();
    for (let ext of flatten(base, compartments, newCompartments)) {
      if (ext instanceof StateField)
        fields.push(ext);
      else
        (facets[ext.facet.id] || (facets[ext.facet.id] = [])).push(ext);
    }
    let address = /* @__PURE__ */ Object.create(null);
    let staticValues = [];
    let dynamicSlots = [];
    for (let field of fields) {
      address[field.id] = dynamicSlots.length << 1;
      dynamicSlots.push((a) => field.slot(a));
    }
    let oldFacets = oldState === null || oldState === void 0 ? void 0 : oldState.config.facets;
    for (let id in facets) {
      let providers = facets[id], facet = providers[0].facet;
      let oldProviders = oldFacets && oldFacets[id] || [];
      if (providers.every(
        (p) => p.type == 0
        /* Provider.Static */
      )) {
        address[facet.id] = staticValues.length << 1 | 1;
        if (sameArray(oldProviders, providers)) {
          staticValues.push(oldState.facet(facet));
        } else {
          let value = facet.combine(providers.map((p) => p.value));
          staticValues.push(oldState && facet.compare(value, oldState.facet(facet)) ? oldState.facet(facet) : value);
        }
      } else {
        for (let p of providers) {
          if (p.type == 0) {
            address[p.id] = staticValues.length << 1 | 1;
            staticValues.push(p.value);
          } else {
            address[p.id] = dynamicSlots.length << 1;
            dynamicSlots.push((a) => p.dynamicSlot(a));
          }
        }
        address[facet.id] = dynamicSlots.length << 1;
        dynamicSlots.push((a) => dynamicFacetSlot(a, facet, providers));
      }
    }
    let dynamic = dynamicSlots.map((f) => f(address));
    return new _Configuration(base, newCompartments, dynamic, address, staticValues, facets);
  }
};
function flatten(extension, compartments, newCompartments) {
  let result = [[], [], [], [], []];
  let seen = /* @__PURE__ */ new Map();
  function inner(ext, prec2) {
    let known = seen.get(ext);
    if (known != null) {
      if (known <= prec2)
        return;
      let found = result[known].indexOf(ext);
      if (found > -1)
        result[known].splice(found, 1);
      if (ext instanceof CompartmentInstance)
        newCompartments.delete(ext.compartment);
    }
    seen.set(ext, prec2);
    if (Array.isArray(ext)) {
      for (let e of ext)
        inner(e, prec2);
    } else if (ext instanceof CompartmentInstance) {
      if (newCompartments.has(ext.compartment))
        throw new RangeError(`Duplicate use of compartment in extensions`);
      let content2 = compartments.get(ext.compartment) || ext.inner;
      newCompartments.set(ext.compartment, content2);
      inner(content2, prec2);
    } else if (ext instanceof PrecExtension) {
      inner(ext.inner, ext.prec);
    } else if (ext instanceof StateField) {
      result[prec2].push(ext);
      if (ext.provides)
        inner(ext.provides, prec2);
    } else if (ext instanceof FacetProvider) {
      result[prec2].push(ext);
      if (ext.facet.extensions)
        inner(ext.facet.extensions, Prec_.default);
    } else {
      let content2 = ext.extension;
      if (!content2)
        throw new Error(`Unrecognized extension value in extension set (${ext}). This sometimes happens because multiple instances of @codemirror/state are loaded, breaking instanceof checks.`);
      inner(content2, prec2);
    }
  }
  inner(extension, Prec_.default);
  return result.reduce((a, b) => a.concat(b));
}
function ensureAddr(state, addr) {
  if (addr & 1)
    return 2;
  let idx = addr >> 1;
  let status = state.status[idx];
  if (status == 4)
    throw new Error("Cyclic dependency between fields and/or facets");
  if (status & 2)
    return status;
  state.status[idx] = 4;
  let changed = state.computeSlot(state, state.config.dynamicSlots[idx]);
  return state.status[idx] = 2 | changed;
}
function getAddr(state, addr) {
  return addr & 1 ? state.config.staticValues[addr >> 1] : state.values[addr >> 1];
}
var languageData = /* @__PURE__ */ Facet.define();
var allowMultipleSelections = /* @__PURE__ */ Facet.define({
  combine: (values) => values.some((v) => v),
  static: true
});
var lineSeparator = /* @__PURE__ */ Facet.define({
  combine: (values) => values.length ? values[0] : void 0,
  static: true
});
var changeFilter = /* @__PURE__ */ Facet.define();
var transactionFilter = /* @__PURE__ */ Facet.define();
var transactionExtender = /* @__PURE__ */ Facet.define();
var readOnly = /* @__PURE__ */ Facet.define({
  combine: (values) => values.length ? values[0] : false
});
var Annotation = class {
  /**
  @internal
  */
  constructor(type, value) {
    this.type = type;
    this.value = value;
  }
  /**
  Define a new type of annotation.
  */
  static define() {
    return new AnnotationType();
  }
};
var AnnotationType = class {
  /**
  Create an instance of this annotation.
  */
  of(value) {
    return new Annotation(this, value);
  }
};
var StateEffectType = class {
  /**
  @internal
  */
  constructor(map) {
    this.map = map;
  }
  /**
  Create a [state effect](https://codemirror.net/6/docs/ref/#state.StateEffect) instance of this
  type.
  */
  of(value) {
    return new StateEffect(this, value);
  }
};
var StateEffect = class _StateEffect {
  /**
  @internal
  */
  constructor(type, value) {
    this.type = type;
    this.value = value;
  }
  /**
  Map this effect through a position mapping. Will return
  `undefined` when that ends up deleting the effect.
  */
  map(mapping) {
    let mapped = this.type.map(this.value, mapping);
    return mapped === void 0 ? void 0 : mapped == this.value ? this : new _StateEffect(this.type, mapped);
  }
  /**
  Tells you whether this effect object is of a given
  [type](https://codemirror.net/6/docs/ref/#state.StateEffectType).
  */
  is(type) {
    return this.type == type;
  }
  /**
  Define a new effect type. The type parameter indicates the type
  of values that his effect holds. It should be a type that
  doesn't include `undefined`, since that is used in
  [mapping](https://codemirror.net/6/docs/ref/#state.StateEffect.map) to indicate that an effect is
  removed.
  */
  static define(spec = {}) {
    return new StateEffectType(spec.map || ((v) => v));
  }
  /**
  Map an array of effects through a change set.
  */
  static mapEffects(effects, mapping) {
    if (!effects.length)
      return effects;
    let result = [];
    for (let effect of effects) {
      let mapped = effect.map(mapping);
      if (mapped)
        result.push(mapped);
    }
    return result;
  }
};
StateEffect.reconfigure = /* @__PURE__ */ StateEffect.define();
StateEffect.appendConfig = /* @__PURE__ */ StateEffect.define();
var Transaction = class _Transaction {
  constructor(startState, changes, selection, effects, annotations, scrollIntoView2) {
    this.startState = startState;
    this.changes = changes;
    this.selection = selection;
    this.effects = effects;
    this.annotations = annotations;
    this.scrollIntoView = scrollIntoView2;
    this._doc = null;
    this._state = null;
    if (selection)
      checkSelection(selection, changes.newLength);
    if (!annotations.some((a) => a.type == _Transaction.time))
      this.annotations = annotations.concat(_Transaction.time.of(Date.now()));
  }
  /**
  @internal
  */
  static create(startState, changes, selection, effects, annotations, scrollIntoView2) {
    return new _Transaction(startState, changes, selection, effects, annotations, scrollIntoView2);
  }
  /**
  The new document produced by the transaction. Contrary to
  [`.state`](https://codemirror.net/6/docs/ref/#state.Transaction.state)`.doc`, accessing this won't
  force the entire new state to be computed right away, so it is
  recommended that [transaction
  filters](https://codemirror.net/6/docs/ref/#state.EditorState^transactionFilter) use this getter
  when they need to look at the new document.
  */
  get newDoc() {
    return this._doc || (this._doc = this.changes.apply(this.startState.doc));
  }
  /**
  The new selection produced by the transaction. If
  [`this.selection`](https://codemirror.net/6/docs/ref/#state.Transaction.selection) is undefined,
  this will [map](https://codemirror.net/6/docs/ref/#state.EditorSelection.map) the start state's
  current selection through the changes made by the transaction.
  */
  get newSelection() {
    return this.selection || this.startState.selection.map(this.changes);
  }
  /**
  The new state created by the transaction. Computed on demand
  (but retained for subsequent access), so it is recommended not to
  access it in [transaction
  filters](https://codemirror.net/6/docs/ref/#state.EditorState^transactionFilter) when possible.
  */
  get state() {
    if (!this._state)
      this.startState.applyTransaction(this);
    return this._state;
  }
  /**
  Get the value of the given annotation type, if any.
  */
  annotation(type) {
    for (let ann of this.annotations)
      if (ann.type == type)
        return ann.value;
    return void 0;
  }
  /**
  Indicates whether the transaction changed the document.
  */
  get docChanged() {
    return !this.changes.empty;
  }
  /**
  Indicates whether this transaction reconfigures the state
  (through a [configuration compartment](https://codemirror.net/6/docs/ref/#state.Compartment) or
  with a top-level configuration
  [effect](https://codemirror.net/6/docs/ref/#state.StateEffect^reconfigure).
  */
  get reconfigured() {
    return this.startState.config != this.state.config;
  }
  /**
  Returns true if the transaction has a [user
  event](https://codemirror.net/6/docs/ref/#state.Transaction^userEvent) annotation that is equal to
  or more specific than `event`. For example, if the transaction
  has `"select.pointer"` as user event, `"select"` and
  `"select.pointer"` will match it.
  */
  isUserEvent(event) {
    let e = this.annotation(_Transaction.userEvent);
    return !!(e && (e == event || e.length > event.length && e.slice(0, event.length) == event && e[event.length] == "."));
  }
};
Transaction.time = /* @__PURE__ */ Annotation.define();
Transaction.userEvent = /* @__PURE__ */ Annotation.define();
Transaction.addToHistory = /* @__PURE__ */ Annotation.define();
Transaction.remote = /* @__PURE__ */ Annotation.define();
function joinRanges(a, b) {
  let result = [];
  for (let iA = 0, iB = 0; ; ) {
    let from, to;
    if (iA < a.length && (iB == b.length || b[iB] >= a[iA])) {
      from = a[iA++];
      to = a[iA++];
    } else if (iB < b.length) {
      from = b[iB++];
      to = b[iB++];
    } else
      return result;
    if (!result.length || result[result.length - 1] < from)
      result.push(from, to);
    else if (result[result.length - 1] < to)
      result[result.length - 1] = to;
  }
}
function mergeTransaction(a, b, sequential) {
  var _a;
  let mapForA, mapForB, changes;
  if (sequential) {
    mapForA = b.changes;
    mapForB = ChangeSet.empty(b.changes.length);
    changes = a.changes.compose(b.changes);
  } else {
    mapForA = b.changes.map(a.changes);
    mapForB = a.changes.mapDesc(b.changes, true);
    changes = a.changes.compose(mapForA);
  }
  return {
    changes,
    selection: b.selection ? b.selection.map(mapForB) : (_a = a.selection) === null || _a === void 0 ? void 0 : _a.map(mapForA),
    effects: StateEffect.mapEffects(a.effects, mapForA).concat(StateEffect.mapEffects(b.effects, mapForB)),
    annotations: a.annotations.length ? a.annotations.concat(b.annotations) : b.annotations,
    scrollIntoView: a.scrollIntoView || b.scrollIntoView
  };
}
function resolveTransactionInner(state, spec, docSize) {
  let sel = spec.selection, annotations = asArray(spec.annotations);
  if (spec.userEvent)
    annotations = annotations.concat(Transaction.userEvent.of(spec.userEvent));
  return {
    changes: spec.changes instanceof ChangeSet ? spec.changes : ChangeSet.of(spec.changes || [], docSize, state.facet(lineSeparator)),
    selection: sel && (sel instanceof EditorSelection ? sel : EditorSelection.single(sel.anchor, sel.head)),
    effects: asArray(spec.effects),
    annotations,
    scrollIntoView: !!spec.scrollIntoView
  };
}
function resolveTransaction(state, specs, filter) {
  let s = resolveTransactionInner(state, specs.length ? specs[0] : {}, state.doc.length);
  if (specs.length && specs[0].filter === false)
    filter = false;
  for (let i = 1; i < specs.length; i++) {
    if (specs[i].filter === false)
      filter = false;
    let seq = !!specs[i].sequential;
    s = mergeTransaction(s, resolveTransactionInner(state, specs[i], seq ? s.changes.newLength : state.doc.length), seq);
  }
  let tr = Transaction.create(state, s.changes, s.selection, s.effects, s.annotations, s.scrollIntoView);
  return extendTransaction(filter ? filterTransaction(tr) : tr);
}
function filterTransaction(tr) {
  let state = tr.startState;
  let result = true;
  for (let filter of state.facet(changeFilter)) {
    let value = filter(tr);
    if (value === false) {
      result = false;
      break;
    }
    if (Array.isArray(value))
      result = result === true ? value : joinRanges(result, value);
  }
  if (result !== true) {
    let changes, back;
    if (result === false) {
      back = tr.changes.invertedDesc;
      changes = ChangeSet.empty(state.doc.length);
    } else {
      let filtered = tr.changes.filter(result);
      changes = filtered.changes;
      back = filtered.filtered.mapDesc(filtered.changes).invertedDesc;
    }
    tr = Transaction.create(state, changes, tr.selection && tr.selection.map(back), StateEffect.mapEffects(tr.effects, back), tr.annotations, tr.scrollIntoView);
  }
  let filters = state.facet(transactionFilter);
  for (let i = filters.length - 1; i >= 0; i--) {
    let filtered = filters[i](tr);
    if (filtered instanceof Transaction)
      tr = filtered;
    else if (Array.isArray(filtered) && filtered.length == 1 && filtered[0] instanceof Transaction)
      tr = filtered[0];
    else
      tr = resolveTransaction(state, asArray(filtered), false);
  }
  return tr;
}
function extendTransaction(tr) {
  let state = tr.startState, extenders = state.facet(transactionExtender), spec = tr;
  for (let i = extenders.length - 1; i >= 0; i--) {
    let extension = extenders[i](tr);
    if (extension && Object.keys(extension).length)
      spec = mergeTransaction(spec, resolveTransactionInner(state, extension, tr.changes.newLength), true);
  }
  return spec == tr ? tr : Transaction.create(state, tr.changes, tr.selection, spec.effects, spec.annotations, spec.scrollIntoView);
}
var none = [];
function asArray(value) {
  return value == null ? none : Array.isArray(value) ? value : [value];
}
var CharCategory = /* @__PURE__ */ function(CharCategory2) {
  CharCategory2[CharCategory2["Word"] = 0] = "Word";
  CharCategory2[CharCategory2["Space"] = 1] = "Space";
  CharCategory2[CharCategory2["Other"] = 2] = "Other";
  return CharCategory2;
}(CharCategory || (CharCategory = {}));
var nonASCIISingleCaseWordChar = /[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/;
var wordChar;
try {
  wordChar = /* @__PURE__ */ new RegExp("[\\p{Alphabetic}\\p{Number}_]", "u");
} catch (_) {
}
function hasWordChar(str) {
  if (wordChar)
    return wordChar.test(str);
  for (let i = 0; i < str.length; i++) {
    let ch = str[i];
    if (/\w/.test(ch) || ch > "\x80" && (ch.toUpperCase() != ch.toLowerCase() || nonASCIISingleCaseWordChar.test(ch)))
      return true;
  }
  return false;
}
function makeCategorizer(wordChars) {
  return (char) => {
    if (!/\S/.test(char))
      return CharCategory.Space;
    if (hasWordChar(char))
      return CharCategory.Word;
    for (let i = 0; i < wordChars.length; i++)
      if (char.indexOf(wordChars[i]) > -1)
        return CharCategory.Word;
    return CharCategory.Other;
  };
}
var EditorState = class _EditorState {
  constructor(config2, doc, selection, values, computeSlot, tr) {
    this.config = config2;
    this.doc = doc;
    this.selection = selection;
    this.values = values;
    this.status = config2.statusTemplate.slice();
    this.computeSlot = computeSlot;
    if (tr)
      tr._state = this;
    for (let i = 0; i < this.config.dynamicSlots.length; i++)
      ensureAddr(this, i << 1);
    this.computeSlot = null;
  }
  field(field, require2 = true) {
    let addr = this.config.address[field.id];
    if (addr == null) {
      if (require2)
        throw new RangeError("Field is not present in this state");
      return void 0;
    }
    ensureAddr(this, addr);
    return getAddr(this, addr);
  }
  /**
  Create a [transaction](https://codemirror.net/6/docs/ref/#state.Transaction) that updates this
  state. Any number of [transaction specs](https://codemirror.net/6/docs/ref/#state.TransactionSpec)
  can be passed. Unless
  [`sequential`](https://codemirror.net/6/docs/ref/#state.TransactionSpec.sequential) is set, the
  [changes](https://codemirror.net/6/docs/ref/#state.TransactionSpec.changes) (if any) of each spec
  are assumed to start in the _current_ document (not the document
  produced by previous specs), and its
  [selection](https://codemirror.net/6/docs/ref/#state.TransactionSpec.selection) and
  [effects](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) are assumed to refer
  to the document created by its _own_ changes. The resulting
  transaction contains the combined effect of all the different
  specs. For [selection](https://codemirror.net/6/docs/ref/#state.TransactionSpec.selection), later
  specs take precedence over earlier ones.
  */
  update(...specs) {
    return resolveTransaction(this, specs, true);
  }
  /**
  @internal
  */
  applyTransaction(tr) {
    let conf = this.config, { base, compartments } = conf;
    for (let effect of tr.effects) {
      if (effect.is(Compartment.reconfigure)) {
        if (conf) {
          compartments = /* @__PURE__ */ new Map();
          conf.compartments.forEach((val, key) => compartments.set(key, val));
          conf = null;
        }
        compartments.set(effect.value.compartment, effect.value.extension);
      } else if (effect.is(StateEffect.reconfigure)) {
        conf = null;
        base = effect.value;
      } else if (effect.is(StateEffect.appendConfig)) {
        conf = null;
        base = asArray(base).concat(effect.value);
      }
    }
    let startValues;
    if (!conf) {
      conf = Configuration.resolve(base, compartments, this);
      let intermediateState = new _EditorState(conf, this.doc, this.selection, conf.dynamicSlots.map(() => null), (state, slot) => slot.reconfigure(state, this), null);
      startValues = intermediateState.values;
    } else {
      startValues = tr.startState.values.slice();
    }
    let selection = tr.startState.facet(allowMultipleSelections) ? tr.newSelection : tr.newSelection.asSingle();
    new _EditorState(conf, tr.newDoc, selection, startValues, (state, slot) => slot.update(state, tr), tr);
  }
  /**
  Create a [transaction spec](https://codemirror.net/6/docs/ref/#state.TransactionSpec) that
  replaces every selection range with the given content.
  */
  replaceSelection(text) {
    if (typeof text == "string")
      text = this.toText(text);
    return this.changeByRange((range) => ({
      changes: { from: range.from, to: range.to, insert: text },
      range: EditorSelection.cursor(range.from + text.length)
    }));
  }
  /**
  Create a set of changes and a new selection by running the given
  function for each range in the active selection. The function
  can return an optional set of changes (in the coordinate space
  of the start document), plus an updated range (in the coordinate
  space of the document produced by the call's own changes). This
  method will merge all the changes and ranges into a single
  changeset and selection, and return it as a [transaction
  spec](https://codemirror.net/6/docs/ref/#state.TransactionSpec), which can be passed to
  [`update`](https://codemirror.net/6/docs/ref/#state.EditorState.update).
  */
  changeByRange(f) {
    let sel = this.selection;
    let result1 = f(sel.ranges[0]);
    let changes = this.changes(result1.changes), ranges = [result1.range];
    let effects = asArray(result1.effects);
    for (let i = 1; i < sel.ranges.length; i++) {
      let result = f(sel.ranges[i]);
      let newChanges = this.changes(result.changes), newMapped = newChanges.map(changes);
      for (let j = 0; j < i; j++)
        ranges[j] = ranges[j].map(newMapped);
      let mapBy = changes.mapDesc(newChanges, true);
      ranges.push(result.range.map(mapBy));
      changes = changes.compose(newMapped);
      effects = StateEffect.mapEffects(effects, newMapped).concat(StateEffect.mapEffects(asArray(result.effects), mapBy));
    }
    return {
      changes,
      selection: EditorSelection.create(ranges, sel.mainIndex),
      effects
    };
  }
  /**
  Create a [change set](https://codemirror.net/6/docs/ref/#state.ChangeSet) from the given change
  description, taking the state's document length and line
  separator into account.
  */
  changes(spec = []) {
    if (spec instanceof ChangeSet)
      return spec;
    return ChangeSet.of(spec, this.doc.length, this.facet(_EditorState.lineSeparator));
  }
  /**
  Using the state's [line
  separator](https://codemirror.net/6/docs/ref/#state.EditorState^lineSeparator), create a
  [`Text`](https://codemirror.net/6/docs/ref/#state.Text) instance from the given string.
  */
  toText(string2) {
    return Text.of(string2.split(this.facet(_EditorState.lineSeparator) || DefaultSplit));
  }
  /**
  Return the given range of the document as a string.
  */
  sliceDoc(from = 0, to = this.doc.length) {
    return this.doc.sliceString(from, to, this.lineBreak);
  }
  /**
  Get the value of a state [facet](https://codemirror.net/6/docs/ref/#state.Facet).
  */
  facet(facet) {
    let addr = this.config.address[facet.id];
    if (addr == null)
      return facet.default;
    ensureAddr(this, addr);
    return getAddr(this, addr);
  }
  /**
  Convert this state to a JSON-serializable object. When custom
  fields should be serialized, you can pass them in as an object
  mapping property names (in the resulting object, which should
  not use `doc` or `selection`) to fields.
  */
  toJSON(fields) {
    let result = {
      doc: this.sliceDoc(),
      selection: this.selection.toJSON()
    };
    if (fields)
      for (let prop in fields) {
        let value = fields[prop];
        if (value instanceof StateField && this.config.address[value.id] != null)
          result[prop] = value.spec.toJSON(this.field(fields[prop]), this);
      }
    return result;
  }
  /**
  Deserialize a state from its JSON representation. When custom
  fields should be deserialized, pass the same object you passed
  to [`toJSON`](https://codemirror.net/6/docs/ref/#state.EditorState.toJSON) when serializing as
  third argument.
  */
  static fromJSON(json, config2 = {}, fields) {
    if (!json || typeof json.doc != "string")
      throw new RangeError("Invalid JSON representation for EditorState");
    let fieldInit = [];
    if (fields)
      for (let prop in fields) {
        if (Object.prototype.hasOwnProperty.call(json, prop)) {
          let field = fields[prop], value = json[prop];
          fieldInit.push(field.init((state) => field.spec.fromJSON(value, state)));
        }
      }
    return _EditorState.create({
      doc: json.doc,
      selection: EditorSelection.fromJSON(json.selection),
      extensions: config2.extensions ? fieldInit.concat([config2.extensions]) : fieldInit
    });
  }
  /**
  Create a new state. You'll usually only need this when
  initializing an editor—updated states are created by applying
  transactions.
  */
  static create(config2 = {}) {
    let configuration = Configuration.resolve(config2.extensions || [], /* @__PURE__ */ new Map());
    let doc = config2.doc instanceof Text ? config2.doc : Text.of((config2.doc || "").split(configuration.staticFacet(_EditorState.lineSeparator) || DefaultSplit));
    let selection = !config2.selection ? EditorSelection.single(0) : config2.selection instanceof EditorSelection ? config2.selection : EditorSelection.single(config2.selection.anchor, config2.selection.head);
    checkSelection(selection, doc.length);
    if (!configuration.staticFacet(allowMultipleSelections))
      selection = selection.asSingle();
    return new _EditorState(configuration, doc, selection, configuration.dynamicSlots.map(() => null), (state, slot) => slot.create(state), null);
  }
  /**
  The size (in columns) of a tab in the document, determined by
  the [`tabSize`](https://codemirror.net/6/docs/ref/#state.EditorState^tabSize) facet.
  */
  get tabSize() {
    return this.facet(_EditorState.tabSize);
  }
  /**
  Get the proper [line-break](https://codemirror.net/6/docs/ref/#state.EditorState^lineSeparator)
  string for this state.
  */
  get lineBreak() {
    return this.facet(_EditorState.lineSeparator) || "\n";
  }
  /**
  Returns true when the editor is
  [configured](https://codemirror.net/6/docs/ref/#state.EditorState^readOnly) to be read-only.
  */
  get readOnly() {
    return this.facet(readOnly);
  }
  /**
  Look up a translation for the given phrase (via the
  [`phrases`](https://codemirror.net/6/docs/ref/#state.EditorState^phrases) facet), or return the
  original string if no translation is found.
  
  If additional arguments are passed, they will be inserted in
  place of markers like `$1` (for the first value) and `$2`, etc.
  A single `$` is equivalent to `$1`, and `$$` will produce a
  literal dollar sign.
  */
  phrase(phrase, ...insert2) {
    for (let map of this.facet(_EditorState.phrases))
      if (Object.prototype.hasOwnProperty.call(map, phrase)) {
        phrase = map[phrase];
        break;
      }
    if (insert2.length)
      phrase = phrase.replace(/\$(\$|\d*)/g, (m, i) => {
        if (i == "$")
          return "$";
        let n = +(i || 1);
        return !n || n > insert2.length ? m : insert2[n - 1];
      });
    return phrase;
  }
  /**
  Find the values for a given language data field, provided by the
  the [`languageData`](https://codemirror.net/6/docs/ref/#state.EditorState^languageData) facet.
  
  Examples of language data fields are...
  
  - [`"commentTokens"`](https://codemirror.net/6/docs/ref/#commands.CommentTokens) for specifying
    comment syntax.
  - [`"autocomplete"`](https://codemirror.net/6/docs/ref/#autocomplete.autocompletion^config.override)
    for providing language-specific completion sources.
  - [`"wordChars"`](https://codemirror.net/6/docs/ref/#state.EditorState.charCategorizer) for adding
    characters that should be considered part of words in this
    language.
  - [`"closeBrackets"`](https://codemirror.net/6/docs/ref/#autocomplete.CloseBracketConfig) controls
    bracket closing behavior.
  */
  languageDataAt(name2, pos, side = -1) {
    let values = [];
    for (let provider of this.facet(languageData)) {
      for (let result of provider(this, pos, side)) {
        if (Object.prototype.hasOwnProperty.call(result, name2))
          values.push(result[name2]);
      }
    }
    return values;
  }
  /**
  Return a function that can categorize strings (expected to
  represent a single [grapheme cluster](https://codemirror.net/6/docs/ref/#state.findClusterBreak))
  into one of:
  
   - Word (contains an alphanumeric character or a character
     explicitly listed in the local language's `"wordChars"`
     language data, which should be a string)
   - Space (contains only whitespace)
   - Other (anything else)
  */
  charCategorizer(at) {
    return makeCategorizer(this.languageDataAt("wordChars", at).join(""));
  }
  /**
  Find the word at the given position, meaning the range
  containing all [word](https://codemirror.net/6/docs/ref/#state.CharCategory.Word) characters
  around it. If no word characters are adjacent to the position,
  this returns null.
  */
  wordAt(pos) {
    let { text, from, length } = this.doc.lineAt(pos);
    let cat = this.charCategorizer(pos);
    let start = pos - from, end = pos - from;
    while (start > 0) {
      let prev = findClusterBreak2(text, start, false);
      if (cat(text.slice(prev, start)) != CharCategory.Word)
        break;
      start = prev;
    }
    while (end < length) {
      let next = findClusterBreak2(text, end);
      if (cat(text.slice(end, next)) != CharCategory.Word)
        break;
      end = next;
    }
    return start == end ? null : EditorSelection.range(start + from, end + from);
  }
};
EditorState.allowMultipleSelections = allowMultipleSelections;
EditorState.tabSize = /* @__PURE__ */ Facet.define({
  combine: (values) => values.length ? values[0] : 4
});
EditorState.lineSeparator = lineSeparator;
EditorState.readOnly = readOnly;
EditorState.phrases = /* @__PURE__ */ Facet.define({
  compare(a, b) {
    let kA = Object.keys(a), kB = Object.keys(b);
    return kA.length == kB.length && kA.every((k) => a[k] == b[k]);
  }
});
EditorState.languageData = languageData;
EditorState.changeFilter = changeFilter;
EditorState.transactionFilter = transactionFilter;
EditorState.transactionExtender = transactionExtender;
Compartment.reconfigure = /* @__PURE__ */ StateEffect.define();
function combineConfig(configs, defaults2, combine = {}) {
  let result = {};
  for (let config2 of configs)
    for (let key of Object.keys(config2)) {
      let value = config2[key], current = result[key];
      if (current === void 0)
        result[key] = value;
      else if (current === value || value === void 0) ;
      else if (Object.hasOwnProperty.call(combine, key))
        result[key] = combine[key](current, value);
      else
        throw new Error("Config merge conflict for field " + key);
    }
  for (let key in defaults2)
    if (result[key] === void 0)
      result[key] = defaults2[key];
  return result;
}
var RangeValue = class {
  /**
  Compare this value with another value. Used when comparing
  rangesets. The default implementation compares by identity.
  Unless you are only creating a fixed number of unique instances
  of your value type, it is a good idea to implement this
  properly.
  */
  eq(other) {
    return this == other;
  }
  /**
  Create a [range](https://codemirror.net/6/docs/ref/#state.Range) with this value.
  */
  range(from, to = from) {
    return Range.create(from, to, this);
  }
};
RangeValue.prototype.startSide = RangeValue.prototype.endSide = 0;
RangeValue.prototype.point = false;
RangeValue.prototype.mapMode = MapMode.TrackDel;
var Range = class _Range {
  constructor(from, to, value) {
    this.from = from;
    this.to = to;
    this.value = value;
  }
  /**
  @internal
  */
  static create(from, to, value) {
    return new _Range(from, to, value);
  }
};
function cmpRange(a, b) {
  return a.from - b.from || a.value.startSide - b.value.startSide;
}
var Chunk = class _Chunk {
  constructor(from, to, value, maxPoint) {
    this.from = from;
    this.to = to;
    this.value = value;
    this.maxPoint = maxPoint;
  }
  get length() {
    return this.to[this.to.length - 1];
  }
  // Find the index of the given position and side. Use the ranges'
  // `from` pos when `end == false`, `to` when `end == true`.
  findIndex(pos, side, end, startAt = 0) {
    let arr = end ? this.to : this.from;
    for (let lo = startAt, hi = arr.length; ; ) {
      if (lo == hi)
        return lo;
      let mid = lo + hi >> 1;
      let diff = arr[mid] - pos || (end ? this.value[mid].endSide : this.value[mid].startSide) - side;
      if (mid == lo)
        return diff >= 0 ? lo : hi;
      if (diff >= 0)
        hi = mid;
      else
        lo = mid + 1;
    }
  }
  between(offset, from, to, f) {
    for (let i = this.findIndex(from, -1e9, true), e = this.findIndex(to, 1e9, false, i); i < e; i++)
      if (f(this.from[i] + offset, this.to[i] + offset, this.value[i]) === false)
        return false;
  }
  map(offset, changes) {
    let value = [], from = [], to = [], newPos = -1, maxPoint = -1;
    for (let i = 0; i < this.value.length; i++) {
      let val = this.value[i], curFrom = this.from[i] + offset, curTo = this.to[i] + offset, newFrom, newTo;
      if (curFrom == curTo) {
        let mapped = changes.mapPos(curFrom, val.startSide, val.mapMode);
        if (mapped == null)
          continue;
        newFrom = newTo = mapped;
        if (val.startSide != val.endSide) {
          newTo = changes.mapPos(curFrom, val.endSide);
          if (newTo < newFrom)
            continue;
        }
      } else {
        newFrom = changes.mapPos(curFrom, val.startSide);
        newTo = changes.mapPos(curTo, val.endSide);
        if (newFrom > newTo || newFrom == newTo && val.startSide > 0 && val.endSide <= 0)
          continue;
      }
      if ((newTo - newFrom || val.endSide - val.startSide) < 0)
        continue;
      if (newPos < 0)
        newPos = newFrom;
      if (val.point)
        maxPoint = Math.max(maxPoint, newTo - newFrom);
      value.push(val);
      from.push(newFrom - newPos);
      to.push(newTo - newPos);
    }
    return { mapped: value.length ? new _Chunk(from, to, value, maxPoint) : null, pos: newPos };
  }
};
var RangeSet = class _RangeSet {
  constructor(chunkPos, chunk, nextLayer, maxPoint) {
    this.chunkPos = chunkPos;
    this.chunk = chunk;
    this.nextLayer = nextLayer;
    this.maxPoint = maxPoint;
  }
  /**
  @internal
  */
  static create(chunkPos, chunk, nextLayer, maxPoint) {
    return new _RangeSet(chunkPos, chunk, nextLayer, maxPoint);
  }
  /**
  @internal
  */
  get length() {
    let last = this.chunk.length - 1;
    return last < 0 ? 0 : Math.max(this.chunkEnd(last), this.nextLayer.length);
  }
  /**
  The number of ranges in the set.
  */
  get size() {
    if (this.isEmpty)
      return 0;
    let size = this.nextLayer.size;
    for (let chunk of this.chunk)
      size += chunk.value.length;
    return size;
  }
  /**
  @internal
  */
  chunkEnd(index) {
    return this.chunkPos[index] + this.chunk[index].length;
  }
  /**
  Update the range set, optionally adding new ranges or filtering
  out existing ones.
  
  (Note: The type parameter is just there as a kludge to work
  around TypeScript variance issues that prevented `RangeSet<X>`
  from being a subtype of `RangeSet<Y>` when `X` is a subtype of
  `Y`.)
  */
  update(updateSpec) {
    let { add = [], sort = false, filterFrom = 0, filterTo = this.length } = updateSpec;
    let filter = updateSpec.filter;
    if (add.length == 0 && !filter)
      return this;
    if (sort)
      add = add.slice().sort(cmpRange);
    if (this.isEmpty)
      return add.length ? _RangeSet.of(add) : this;
    let cur2 = new LayerCursor(this, null, -1).goto(0), i = 0, spill = [];
    let builder = new RangeSetBuilder();
    while (cur2.value || i < add.length) {
      if (i < add.length && (cur2.from - add[i].from || cur2.startSide - add[i].value.startSide) >= 0) {
        let range = add[i++];
        if (!builder.addInner(range.from, range.to, range.value))
          spill.push(range);
      } else if (cur2.rangeIndex == 1 && cur2.chunkIndex < this.chunk.length && (i == add.length || this.chunkEnd(cur2.chunkIndex) < add[i].from) && (!filter || filterFrom > this.chunkEnd(cur2.chunkIndex) || filterTo < this.chunkPos[cur2.chunkIndex]) && builder.addChunk(this.chunkPos[cur2.chunkIndex], this.chunk[cur2.chunkIndex])) {
        cur2.nextChunk();
      } else {
        if (!filter || filterFrom > cur2.to || filterTo < cur2.from || filter(cur2.from, cur2.to, cur2.value)) {
          if (!builder.addInner(cur2.from, cur2.to, cur2.value))
            spill.push(Range.create(cur2.from, cur2.to, cur2.value));
        }
        cur2.next();
      }
    }
    return builder.finishInner(this.nextLayer.isEmpty && !spill.length ? _RangeSet.empty : this.nextLayer.update({ add: spill, filter, filterFrom, filterTo }));
  }
  /**
  Map this range set through a set of changes, return the new set.
  */
  map(changes) {
    if (changes.empty || this.isEmpty)
      return this;
    let chunks = [], chunkPos = [], maxPoint = -1;
    for (let i = 0; i < this.chunk.length; i++) {
      let start = this.chunkPos[i], chunk = this.chunk[i];
      let touch = changes.touchesRange(start, start + chunk.length);
      if (touch === false) {
        maxPoint = Math.max(maxPoint, chunk.maxPoint);
        chunks.push(chunk);
        chunkPos.push(changes.mapPos(start));
      } else if (touch === true) {
        let { mapped, pos } = chunk.map(start, changes);
        if (mapped) {
          maxPoint = Math.max(maxPoint, mapped.maxPoint);
          chunks.push(mapped);
          chunkPos.push(pos);
        }
      }
    }
    let next = this.nextLayer.map(changes);
    return chunks.length == 0 ? next : new _RangeSet(chunkPos, chunks, next || _RangeSet.empty, maxPoint);
  }
  /**
  Iterate over the ranges that touch the region `from` to `to`,
  calling `f` for each. There is no guarantee that the ranges will
  be reported in any specific order. When the callback returns
  `false`, iteration stops.
  */
  between(from, to, f) {
    if (this.isEmpty)
      return;
    for (let i = 0; i < this.chunk.length; i++) {
      let start = this.chunkPos[i], chunk = this.chunk[i];
      if (to >= start && from <= start + chunk.length && chunk.between(start, from - start, to - start, f) === false)
        return;
    }
    this.nextLayer.between(from, to, f);
  }
  /**
  Iterate over the ranges in this set, in order, including all
  ranges that end at or after `from`.
  */
  iter(from = 0) {
    return HeapCursor.from([this]).goto(from);
  }
  /**
  @internal
  */
  get isEmpty() {
    return this.nextLayer == this;
  }
  /**
  Iterate over the ranges in a collection of sets, in order,
  starting from `from`.
  */
  static iter(sets, from = 0) {
    return HeapCursor.from(sets).goto(from);
  }
  /**
  Iterate over two groups of sets, calling methods on `comparator`
  to notify it of possible differences.
  */
  static compare(oldSets, newSets, textDiff, comparator, minPointSize = -1) {
    let a = oldSets.filter((set) => set.maxPoint > 0 || !set.isEmpty && set.maxPoint >= minPointSize);
    let b = newSets.filter((set) => set.maxPoint > 0 || !set.isEmpty && set.maxPoint >= minPointSize);
    let sharedChunks = findSharedChunks(a, b, textDiff);
    let sideA = new SpanCursor(a, sharedChunks, minPointSize);
    let sideB = new SpanCursor(b, sharedChunks, minPointSize);
    textDiff.iterGaps((fromA, fromB, length) => compare(sideA, fromA, sideB, fromB, length, comparator));
    if (textDiff.empty && textDiff.length == 0)
      compare(sideA, 0, sideB, 0, 0, comparator);
  }
  /**
  Compare the contents of two groups of range sets, returning true
  if they are equivalent in the given range.
  */
  static eq(oldSets, newSets, from = 0, to) {
    if (to == null)
      to = 1e9 - 1;
    let a = oldSets.filter((set) => !set.isEmpty && newSets.indexOf(set) < 0);
    let b = newSets.filter((set) => !set.isEmpty && oldSets.indexOf(set) < 0);
    if (a.length != b.length)
      return false;
    if (!a.length)
      return true;
    let sharedChunks = findSharedChunks(a, b);
    let sideA = new SpanCursor(a, sharedChunks, 0).goto(from), sideB = new SpanCursor(b, sharedChunks, 0).goto(from);
    for (; ; ) {
      if (sideA.to != sideB.to || !sameValues(sideA.active, sideB.active) || sideA.point && (!sideB.point || !sideA.point.eq(sideB.point)))
        return false;
      if (sideA.to > to)
        return true;
      sideA.next();
      sideB.next();
    }
  }
  /**
  Iterate over a group of range sets at the same time, notifying
  the iterator about the ranges covering every given piece of
  content. Returns the open count (see
  [`SpanIterator.span`](https://codemirror.net/6/docs/ref/#state.SpanIterator.span)) at the end
  of the iteration.
  */
  static spans(sets, from, to, iterator, minPointSize = -1) {
    let cursor = new SpanCursor(sets, null, minPointSize).goto(from), pos = from;
    let openRanges = cursor.openStart;
    for (; ; ) {
      let curTo = Math.min(cursor.to, to);
      if (cursor.point) {
        let active = cursor.activeForPoint(cursor.to);
        let openCount = cursor.pointFrom < from ? active.length + 1 : cursor.point.startSide < 0 ? active.length : Math.min(active.length, openRanges);
        iterator.point(pos, curTo, cursor.point, active, openCount, cursor.pointRank);
        openRanges = Math.min(cursor.openEnd(curTo), active.length);
      } else if (curTo > pos) {
        iterator.span(pos, curTo, cursor.active, openRanges);
        openRanges = cursor.openEnd(curTo);
      }
      if (cursor.to > to)
        return openRanges + (cursor.point && cursor.to > to ? 1 : 0);
      pos = cursor.to;
      cursor.next();
    }
  }
  /**
  Create a range set for the given range or array of ranges. By
  default, this expects the ranges to be _sorted_ (by start
  position and, if two start at the same position,
  `value.startSide`). You can pass `true` as second argument to
  cause the method to sort them.
  */
  static of(ranges, sort = false) {
    let build = new RangeSetBuilder();
    for (let range of ranges instanceof Range ? [ranges] : sort ? lazySort(ranges) : ranges)
      build.add(range.from, range.to, range.value);
    return build.finish();
  }
  /**
  Join an array of range sets into a single set.
  */
  static join(sets) {
    if (!sets.length)
      return _RangeSet.empty;
    let result = sets[sets.length - 1];
    for (let i = sets.length - 2; i >= 0; i--) {
      for (let layer = sets[i]; layer != _RangeSet.empty; layer = layer.nextLayer)
        result = new _RangeSet(layer.chunkPos, layer.chunk, result, Math.max(layer.maxPoint, result.maxPoint));
    }
    return result;
  }
};
RangeSet.empty = /* @__PURE__ */ new RangeSet([], [], null, -1);
function lazySort(ranges) {
  if (ranges.length > 1)
    for (let prev = ranges[0], i = 1; i < ranges.length; i++) {
      let cur2 = ranges[i];
      if (cmpRange(prev, cur2) > 0)
        return ranges.slice().sort(cmpRange);
      prev = cur2;
    }
  return ranges;
}
RangeSet.empty.nextLayer = RangeSet.empty;
var RangeSetBuilder = class _RangeSetBuilder {
  finishChunk(newArrays) {
    this.chunks.push(new Chunk(this.from, this.to, this.value, this.maxPoint));
    this.chunkPos.push(this.chunkStart);
    this.chunkStart = -1;
    this.setMaxPoint = Math.max(this.setMaxPoint, this.maxPoint);
    this.maxPoint = -1;
    if (newArrays) {
      this.from = [];
      this.to = [];
      this.value = [];
    }
  }
  /**
  Create an empty builder.
  */
  constructor() {
    this.chunks = [];
    this.chunkPos = [];
    this.chunkStart = -1;
    this.last = null;
    this.lastFrom = -1e9;
    this.lastTo = -1e9;
    this.from = [];
    this.to = [];
    this.value = [];
    this.maxPoint = -1;
    this.setMaxPoint = -1;
    this.nextLayer = null;
  }
  /**
  Add a range. Ranges should be added in sorted (by `from` and
  `value.startSide`) order.
  */
  add(from, to, value) {
    if (!this.addInner(from, to, value))
      (this.nextLayer || (this.nextLayer = new _RangeSetBuilder())).add(from, to, value);
  }
  /**
  @internal
  */
  addInner(from, to, value) {
    let diff = from - this.lastTo || value.startSide - this.last.endSide;
    if (diff <= 0 && (from - this.lastFrom || value.startSide - this.last.startSide) < 0)
      throw new Error("Ranges must be added sorted by `from` position and `startSide`");
    if (diff < 0)
      return false;
    if (this.from.length == 250)
      this.finishChunk(true);
    if (this.chunkStart < 0)
      this.chunkStart = from;
    this.from.push(from - this.chunkStart);
    this.to.push(to - this.chunkStart);
    this.last = value;
    this.lastFrom = from;
    this.lastTo = to;
    this.value.push(value);
    if (value.point)
      this.maxPoint = Math.max(this.maxPoint, to - from);
    return true;
  }
  /**
  @internal
  */
  addChunk(from, chunk) {
    if ((from - this.lastTo || chunk.value[0].startSide - this.last.endSide) < 0)
      return false;
    if (this.from.length)
      this.finishChunk(true);
    this.setMaxPoint = Math.max(this.setMaxPoint, chunk.maxPoint);
    this.chunks.push(chunk);
    this.chunkPos.push(from);
    let last = chunk.value.length - 1;
    this.last = chunk.value[last];
    this.lastFrom = chunk.from[last] + from;
    this.lastTo = chunk.to[last] + from;
    return true;
  }
  /**
  Finish the range set. Returns the new set. The builder can't be
  used anymore after this has been called.
  */
  finish() {
    return this.finishInner(RangeSet.empty);
  }
  /**
  @internal
  */
  finishInner(next) {
    if (this.from.length)
      this.finishChunk(false);
    if (this.chunks.length == 0)
      return next;
    let result = RangeSet.create(this.chunkPos, this.chunks, this.nextLayer ? this.nextLayer.finishInner(next) : next, this.setMaxPoint);
    this.from = null;
    return result;
  }
};
function findSharedChunks(a, b, textDiff) {
  let inA = /* @__PURE__ */ new Map();
  for (let set of a)
    for (let i = 0; i < set.chunk.length; i++)
      if (set.chunk[i].maxPoint <= 0)
        inA.set(set.chunk[i], set.chunkPos[i]);
  let shared = /* @__PURE__ */ new Set();
  for (let set of b)
    for (let i = 0; i < set.chunk.length; i++) {
      let known = inA.get(set.chunk[i]);
      if (known != null && (textDiff ? textDiff.mapPos(known) : known) == set.chunkPos[i] && !(textDiff === null || textDiff === void 0 ? void 0 : textDiff.touchesRange(known, known + set.chunk[i].length)))
        shared.add(set.chunk[i]);
    }
  return shared;
}
var LayerCursor = class {
  constructor(layer, skip, minPoint, rank = 0) {
    this.layer = layer;
    this.skip = skip;
    this.minPoint = minPoint;
    this.rank = rank;
  }
  get startSide() {
    return this.value ? this.value.startSide : 0;
  }
  get endSide() {
    return this.value ? this.value.endSide : 0;
  }
  goto(pos, side = -1e9) {
    this.chunkIndex = this.rangeIndex = 0;
    this.gotoInner(pos, side, false);
    return this;
  }
  gotoInner(pos, side, forward) {
    while (this.chunkIndex < this.layer.chunk.length) {
      let next = this.layer.chunk[this.chunkIndex];
      if (!(this.skip && this.skip.has(next) || this.layer.chunkEnd(this.chunkIndex) < pos || next.maxPoint < this.minPoint))
        break;
      this.chunkIndex++;
      forward = false;
    }
    if (this.chunkIndex < this.layer.chunk.length) {
      let rangeIndex = this.layer.chunk[this.chunkIndex].findIndex(pos - this.layer.chunkPos[this.chunkIndex], side, true);
      if (!forward || this.rangeIndex < rangeIndex)
        this.setRangeIndex(rangeIndex);
    }
    this.next();
  }
  forward(pos, side) {
    if ((this.to - pos || this.endSide - side) < 0)
      this.gotoInner(pos, side, true);
  }
  next() {
    for (; ; ) {
      if (this.chunkIndex == this.layer.chunk.length) {
        this.from = this.to = 1e9;
        this.value = null;
        break;
      } else {
        let chunkPos = this.layer.chunkPos[this.chunkIndex], chunk = this.layer.chunk[this.chunkIndex];
        let from = chunkPos + chunk.from[this.rangeIndex];
        this.from = from;
        this.to = chunkPos + chunk.to[this.rangeIndex];
        this.value = chunk.value[this.rangeIndex];
        this.setRangeIndex(this.rangeIndex + 1);
        if (this.minPoint < 0 || this.value.point && this.to - this.from >= this.minPoint)
          break;
      }
    }
  }
  setRangeIndex(index) {
    if (index == this.layer.chunk[this.chunkIndex].value.length) {
      this.chunkIndex++;
      if (this.skip) {
        while (this.chunkIndex < this.layer.chunk.length && this.skip.has(this.layer.chunk[this.chunkIndex]))
          this.chunkIndex++;
      }
      this.rangeIndex = 0;
    } else {
      this.rangeIndex = index;
    }
  }
  nextChunk() {
    this.chunkIndex++;
    this.rangeIndex = 0;
    this.next();
  }
  compare(other) {
    return this.from - other.from || this.startSide - other.startSide || this.rank - other.rank || this.to - other.to || this.endSide - other.endSide;
  }
};
var HeapCursor = class _HeapCursor {
  constructor(heap) {
    this.heap = heap;
  }
  static from(sets, skip = null, minPoint = -1) {
    let heap = [];
    for (let i = 0; i < sets.length; i++) {
      for (let cur2 = sets[i]; !cur2.isEmpty; cur2 = cur2.nextLayer) {
        if (cur2.maxPoint >= minPoint)
          heap.push(new LayerCursor(cur2, skip, minPoint, i));
      }
    }
    return heap.length == 1 ? heap[0] : new _HeapCursor(heap);
  }
  get startSide() {
    return this.value ? this.value.startSide : 0;
  }
  goto(pos, side = -1e9) {
    for (let cur2 of this.heap)
      cur2.goto(pos, side);
    for (let i = this.heap.length >> 1; i >= 0; i--)
      heapBubble(this.heap, i);
    this.next();
    return this;
  }
  forward(pos, side) {
    for (let cur2 of this.heap)
      cur2.forward(pos, side);
    for (let i = this.heap.length >> 1; i >= 0; i--)
      heapBubble(this.heap, i);
    if ((this.to - pos || this.value.endSide - side) < 0)
      this.next();
  }
  next() {
    if (this.heap.length == 0) {
      this.from = this.to = 1e9;
      this.value = null;
      this.rank = -1;
    } else {
      let top = this.heap[0];
      this.from = top.from;
      this.to = top.to;
      this.value = top.value;
      this.rank = top.rank;
      if (top.value)
        top.next();
      heapBubble(this.heap, 0);
    }
  }
};
function heapBubble(heap, index) {
  for (let cur2 = heap[index]; ; ) {
    let childIndex = (index << 1) + 1;
    if (childIndex >= heap.length)
      break;
    let child = heap[childIndex];
    if (childIndex + 1 < heap.length && child.compare(heap[childIndex + 1]) >= 0) {
      child = heap[childIndex + 1];
      childIndex++;
    }
    if (cur2.compare(child) < 0)
      break;
    heap[childIndex] = cur2;
    heap[index] = child;
    index = childIndex;
  }
}
var SpanCursor = class {
  constructor(sets, skip, minPoint) {
    this.minPoint = minPoint;
    this.active = [];
    this.activeTo = [];
    this.activeRank = [];
    this.minActive = -1;
    this.point = null;
    this.pointFrom = 0;
    this.pointRank = 0;
    this.to = -1e9;
    this.endSide = 0;
    this.openStart = -1;
    this.cursor = HeapCursor.from(sets, skip, minPoint);
  }
  goto(pos, side = -1e9) {
    this.cursor.goto(pos, side);
    this.active.length = this.activeTo.length = this.activeRank.length = 0;
    this.minActive = -1;
    this.to = pos;
    this.endSide = side;
    this.openStart = -1;
    this.next();
    return this;
  }
  forward(pos, side) {
    while (this.minActive > -1 && (this.activeTo[this.minActive] - pos || this.active[this.minActive].endSide - side) < 0)
      this.removeActive(this.minActive);
    this.cursor.forward(pos, side);
  }
  removeActive(index) {
    remove(this.active, index);
    remove(this.activeTo, index);
    remove(this.activeRank, index);
    this.minActive = findMinIndex(this.active, this.activeTo);
  }
  addActive(trackOpen) {
    let i = 0, { value, to, rank } = this.cursor;
    while (i < this.activeRank.length && (rank - this.activeRank[i] || to - this.activeTo[i]) > 0)
      i++;
    insert(this.active, i, value);
    insert(this.activeTo, i, to);
    insert(this.activeRank, i, rank);
    if (trackOpen)
      insert(trackOpen, i, this.cursor.from);
    this.minActive = findMinIndex(this.active, this.activeTo);
  }
  // After calling this, if `this.point` != null, the next range is a
  // point. Otherwise, it's a regular range, covered by `this.active`.
  next() {
    let from = this.to, wasPoint = this.point;
    this.point = null;
    let trackOpen = this.openStart < 0 ? [] : null;
    for (; ; ) {
      let a = this.minActive;
      if (a > -1 && (this.activeTo[a] - this.cursor.from || this.active[a].endSide - this.cursor.startSide) < 0) {
        if (this.activeTo[a] > from) {
          this.to = this.activeTo[a];
          this.endSide = this.active[a].endSide;
          break;
        }
        this.removeActive(a);
        if (trackOpen)
          remove(trackOpen, a);
      } else if (!this.cursor.value) {
        this.to = this.endSide = 1e9;
        break;
      } else if (this.cursor.from > from) {
        this.to = this.cursor.from;
        this.endSide = this.cursor.startSide;
        break;
      } else {
        let nextVal = this.cursor.value;
        if (!nextVal.point) {
          this.addActive(trackOpen);
          this.cursor.next();
        } else if (wasPoint && this.cursor.to == this.to && this.cursor.from < this.cursor.to) {
          this.cursor.next();
        } else {
          this.point = nextVal;
          this.pointFrom = this.cursor.from;
          this.pointRank = this.cursor.rank;
          this.to = this.cursor.to;
          this.endSide = nextVal.endSide;
          this.cursor.next();
          this.forward(this.to, this.endSide);
          break;
        }
      }
    }
    if (trackOpen) {
      this.openStart = 0;
      for (let i = trackOpen.length - 1; i >= 0 && trackOpen[i] < from; i--)
        this.openStart++;
    }
  }
  activeForPoint(to) {
    if (!this.active.length)
      return this.active;
    let active = [];
    for (let i = this.active.length - 1; i >= 0; i--) {
      if (this.activeRank[i] < this.pointRank)
        break;
      if (this.activeTo[i] > to || this.activeTo[i] == to && this.active[i].endSide >= this.point.endSide)
        active.push(this.active[i]);
    }
    return active.reverse();
  }
  openEnd(to) {
    let open = 0;
    for (let i = this.activeTo.length - 1; i >= 0 && this.activeTo[i] > to; i--)
      open++;
    return open;
  }
};
function compare(a, startA, b, startB, length, comparator) {
  a.goto(startA);
  b.goto(startB);
  let endB = startB + length;
  let pos = startB, dPos = startB - startA;
  for (; ; ) {
    let dEnd = a.to + dPos - b.to, diff = dEnd || a.endSide - b.endSide;
    let end = diff < 0 ? a.to + dPos : b.to, clipEnd = Math.min(end, endB);
    if (a.point || b.point) {
      if (!(a.point && b.point && (a.point == b.point || a.point.eq(b.point)) && sameValues(a.activeForPoint(a.to), b.activeForPoint(b.to))))
        comparator.comparePoint(pos, clipEnd, a.point, b.point);
    } else {
      if (clipEnd > pos && !sameValues(a.active, b.active))
        comparator.compareRange(pos, clipEnd, a.active, b.active);
    }
    if (end > endB)
      break;
    if ((dEnd || a.openEnd != b.openEnd) && comparator.boundChange)
      comparator.boundChange(end);
    pos = end;
    if (diff <= 0)
      a.next();
    if (diff >= 0)
      b.next();
  }
}
function sameValues(a, b) {
  if (a.length != b.length)
    return false;
  for (let i = 0; i < a.length; i++)
    if (a[i] != b[i] && !a[i].eq(b[i]))
      return false;
  return true;
}
function remove(array, index) {
  for (let i = index, e = array.length - 1; i < e; i++)
    array[i] = array[i + 1];
  array.pop();
}
function insert(array, index, value) {
  for (let i = array.length - 1; i >= index; i--)
    array[i + 1] = array[i];
  array[index] = value;
}
function findMinIndex(value, array) {
  let found = -1, foundPos = 1e9;
  for (let i = 0; i < array.length; i++)
    if ((array[i] - foundPos || value[i].endSide - value[found].endSide) < 0) {
      found = i;
      foundPos = array[i];
    }
  return found;
}

// node_modules/@codemirror/autocomplete/dist/index.js
import { Direction, logException, showTooltip, EditorView, ViewPlugin, getTooltip, Decoration, WidgetType, keymap } from "@codemirror/view";
import { syntaxTree, indentUnit } from "@codemirror/language";
var CompletionContext = class {
  /**
  Create a new completion context. (Mostly useful for testing
  completion sources—in the editor, the extension will create
  these for you.)
  */
  constructor(state, pos, explicit, view) {
    this.state = state;
    this.pos = pos;
    this.explicit = explicit;
    this.view = view;
    this.abortListeners = [];
    this.abortOnDocChange = false;
  }
  /**
  Get the extent, content, and (if there is a token) type of the
  token before `this.pos`.
  */
  tokenBefore(types) {
    let token = syntaxTree(this.state).resolveInner(this.pos, -1);
    while (token && types.indexOf(token.name) < 0)
      token = token.parent;
    return token ? {
      from: token.from,
      to: this.pos,
      text: this.state.sliceDoc(token.from, this.pos),
      type: token.type
    } : null;
  }
  /**
  Get the match of the given expression directly before the
  cursor.
  */
  matchBefore(expr) {
    let line = this.state.doc.lineAt(this.pos);
    let start = Math.max(line.from, this.pos - 250);
    let str = line.text.slice(start - line.from, this.pos - line.from);
    let found = str.search(ensureAnchor(expr, false));
    return found < 0 ? null : { from: start + found, to: this.pos, text: str.slice(found) };
  }
  /**
  Yields true when the query has been aborted. Can be useful in
  asynchronous queries to avoid doing work that will be ignored.
  */
  get aborted() {
    return this.abortListeners == null;
  }
  /**
  Allows you to register abort handlers, which will be called when
  the query is
  [aborted](https://codemirror.net/6/docs/ref/#autocomplete.CompletionContext.aborted).
  
  By default, running queries will not be aborted for regular
  typing or backspacing, on the assumption that they are likely to
  return a result with a
  [`validFor`](https://codemirror.net/6/docs/ref/#autocomplete.CompletionResult.validFor) field that
  allows the result to be used after all. Passing `onDocChange:
  true` will cause this query to be aborted for any document
  change.
  */
  addEventListener(type, listener, options) {
    if (type == "abort" && this.abortListeners) {
      this.abortListeners.push(listener);
      if (options && options.onDocChange)
        this.abortOnDocChange = true;
    }
  }
};
function toSet(chars) {
  let flat = Object.keys(chars).join("");
  let words = /\w/.test(flat);
  if (words)
    flat = flat.replace(/\w/g, "");
  return `[${words ? "\\w" : ""}${flat.replace(/[^\w\s]/g, "\\$&")}]`;
}
function prefixMatch(options) {
  let first = /* @__PURE__ */ Object.create(null), rest = /* @__PURE__ */ Object.create(null);
  for (let { label } of options) {
    first[label[0]] = true;
    for (let i = 1; i < label.length; i++)
      rest[label[i]] = true;
  }
  let source = toSet(first) + toSet(rest) + "*$";
  return [new RegExp("^" + source), new RegExp(source)];
}
function completeFromList(list) {
  let options = list.map((o) => typeof o == "string" ? { label: o } : o);
  let [validFor, match] = options.every((o) => /^\w+$/.test(o.label)) ? [/\w*$/, /\w+$/] : prefixMatch(options);
  return (context) => {
    let token = context.matchBefore(match);
    return token || context.explicit ? { from: token ? token.from : context.pos, options, validFor } : null;
  };
}
var Option = class {
  constructor(completion, source, match, score2) {
    this.completion = completion;
    this.source = source;
    this.match = match;
    this.score = score2;
  }
};
function cur(state) {
  return state.selection.main.from;
}
function ensureAnchor(expr, start) {
  var _a;
  let { source } = expr;
  let addStart = start && source[0] != "^", addEnd = source[source.length - 1] != "$";
  if (!addStart && !addEnd)
    return expr;
  return new RegExp(`${addStart ? "^" : ""}(?:${source})${addEnd ? "$" : ""}`, (_a = expr.flags) !== null && _a !== void 0 ? _a : expr.ignoreCase ? "i" : "");
}
var pickedCompletion = /* @__PURE__ */ Annotation.define();
function insertCompletionText(state, text, from, to) {
  let { main } = state.selection, fromOff = from - main.from, toOff = to - main.from;
  return Object.assign(Object.assign({}, state.changeByRange((range) => {
    if (range != main && from != to && state.sliceDoc(range.from + fromOff, range.from + toOff) != state.sliceDoc(from, to))
      return { range };
    let lines = state.toText(text);
    return {
      changes: { from: range.from + fromOff, to: to == main.from ? range.to : range.from + toOff, insert: lines },
      range: EditorSelection.cursor(range.from + fromOff + lines.length)
    };
  })), { scrollIntoView: true, userEvent: "input.complete" });
}
var SourceCache = /* @__PURE__ */ new WeakMap();
function asSource(source) {
  if (!Array.isArray(source))
    return source;
  let known = SourceCache.get(source);
  if (!known)
    SourceCache.set(source, known = completeFromList(source));
  return known;
}
var startCompletionEffect = /* @__PURE__ */ StateEffect.define();
var closeCompletionEffect = /* @__PURE__ */ StateEffect.define();
var FuzzyMatcher = class {
  constructor(pattern) {
    this.pattern = pattern;
    this.chars = [];
    this.folded = [];
    this.any = [];
    this.precise = [];
    this.byWord = [];
    this.score = 0;
    this.matched = [];
    for (let p = 0; p < pattern.length; ) {
      let char = codePointAt2(pattern, p), size = codePointSize2(char);
      this.chars.push(char);
      let part = pattern.slice(p, p + size), upper = part.toUpperCase();
      this.folded.push(codePointAt2(upper == part ? part.toLowerCase() : upper, 0));
      p += size;
    }
    this.astral = pattern.length != this.chars.length;
  }
  ret(score2, matched) {
    this.score = score2;
    this.matched = matched;
    return this;
  }
  // Matches a given word (completion) against the pattern (input).
  // Will return a boolean indicating whether there was a match and,
  // on success, set `this.score` to the score, `this.matched` to an
  // array of `from, to` pairs indicating the matched parts of `word`.
  //
  // The score is a number that is more negative the worse the match
  // is. See `Penalty` above.
  match(word) {
    if (this.pattern.length == 0)
      return this.ret(-100, []);
    if (word.length < this.pattern.length)
      return null;
    let { chars, folded, any, precise, byWord } = this;
    if (chars.length == 1) {
      let first = codePointAt2(word, 0), firstSize = codePointSize2(first);
      let score2 = firstSize == word.length ? 0 : -100;
      if (first == chars[0]) ;
      else if (first == folded[0])
        score2 += -200;
      else
        return null;
      return this.ret(score2, [0, firstSize]);
    }
    let direct = word.indexOf(this.pattern);
    if (direct == 0)
      return this.ret(word.length == this.pattern.length ? 0 : -100, [0, this.pattern.length]);
    let len = chars.length, anyTo = 0;
    if (direct < 0) {
      for (let i = 0, e = Math.min(word.length, 200); i < e && anyTo < len; ) {
        let next = codePointAt2(word, i);
        if (next == chars[anyTo] || next == folded[anyTo])
          any[anyTo++] = i;
        i += codePointSize2(next);
      }
      if (anyTo < len)
        return null;
    }
    let preciseTo = 0;
    let byWordTo = 0, byWordFolded = false;
    let adjacentTo = 0, adjacentStart = -1, adjacentEnd = -1;
    let hasLower = /[a-z]/.test(word), wordAdjacent = true;
    for (let i = 0, e = Math.min(word.length, 200), prevType = 0; i < e && byWordTo < len; ) {
      let next = codePointAt2(word, i);
      if (direct < 0) {
        if (preciseTo < len && next == chars[preciseTo])
          precise[preciseTo++] = i;
        if (adjacentTo < len) {
          if (next == chars[adjacentTo] || next == folded[adjacentTo]) {
            if (adjacentTo == 0)
              adjacentStart = i;
            adjacentEnd = i + 1;
            adjacentTo++;
          } else {
            adjacentTo = 0;
          }
        }
      }
      let ch, type = next < 255 ? next >= 48 && next <= 57 || next >= 97 && next <= 122 ? 2 : next >= 65 && next <= 90 ? 1 : 0 : (ch = fromCodePoint(next)) != ch.toLowerCase() ? 1 : ch != ch.toUpperCase() ? 2 : 0;
      if (!i || type == 1 && hasLower || prevType == 0 && type != 0) {
        if (chars[byWordTo] == next || folded[byWordTo] == next && (byWordFolded = true))
          byWord[byWordTo++] = i;
        else if (byWord.length)
          wordAdjacent = false;
      }
      prevType = type;
      i += codePointSize2(next);
    }
    if (byWordTo == len && byWord[0] == 0 && wordAdjacent)
      return this.result(-100 + (byWordFolded ? -200 : 0), byWord, word);
    if (adjacentTo == len && adjacentStart == 0)
      return this.ret(-200 - word.length + (adjacentEnd == word.length ? 0 : -100), [0, adjacentEnd]);
    if (direct > -1)
      return this.ret(-700 - word.length, [direct, direct + this.pattern.length]);
    if (adjacentTo == len)
      return this.ret(-200 + -700 - word.length, [adjacentStart, adjacentEnd]);
    if (byWordTo == len)
      return this.result(-100 + (byWordFolded ? -200 : 0) + -700 + (wordAdjacent ? 0 : -1100), byWord, word);
    return chars.length == 2 ? null : this.result((any[0] ? -700 : 0) + -200 + -1100, any, word);
  }
  result(score2, positions, word) {
    let result = [], i = 0;
    for (let pos of positions) {
      let to = pos + (this.astral ? codePointSize2(codePointAt2(word, pos)) : 1);
      if (i && result[i - 1] == pos)
        result[i - 1] = to;
      else {
        result[i++] = pos;
        result[i++] = to;
      }
    }
    return this.ret(score2 - word.length, result);
  }
};
var StrictMatcher = class {
  constructor(pattern) {
    this.pattern = pattern;
    this.matched = [];
    this.score = 0;
    this.folded = pattern.toLowerCase();
  }
  match(word) {
    if (word.length < this.pattern.length)
      return null;
    let start = word.slice(0, this.pattern.length);
    let match = start == this.pattern ? 0 : start.toLowerCase() == this.folded ? -200 : null;
    if (match == null)
      return null;
    this.matched = [0, start.length];
    this.score = match + (word.length == this.pattern.length ? 0 : -100);
    return this;
  }
};
var completionConfig = /* @__PURE__ */ Facet.define({
  combine(configs) {
    return combineConfig(configs, {
      activateOnTyping: true,
      activateOnCompletion: () => false,
      activateOnTypingDelay: 100,
      selectOnOpen: true,
      override: null,
      closeOnBlur: true,
      maxRenderedOptions: 100,
      defaultKeymap: true,
      tooltipClass: () => "",
      optionClass: () => "",
      aboveCursor: false,
      icons: true,
      addToOptions: [],
      positionInfo: defaultPositionInfo,
      filterStrict: false,
      compareCompletions: (a, b) => a.label.localeCompare(b.label),
      interactionDelay: 75,
      updateSyncTime: 100
    }, {
      defaultKeymap: (a, b) => a && b,
      closeOnBlur: (a, b) => a && b,
      icons: (a, b) => a && b,
      tooltipClass: (a, b) => (c) => joinClass(a(c), b(c)),
      optionClass: (a, b) => (c) => joinClass(a(c), b(c)),
      addToOptions: (a, b) => a.concat(b),
      filterStrict: (a, b) => a || b
    });
  }
});
function joinClass(a, b) {
  return a ? b ? a + " " + b : a : b;
}
function defaultPositionInfo(view, list, option, info, space, tooltip) {
  let rtl = view.textDirection == Direction.RTL, left = rtl, narrow = false;
  let side = "top", offset, maxWidth;
  let spaceLeft = list.left - space.left, spaceRight = space.right - list.right;
  let infoWidth = info.right - info.left, infoHeight = info.bottom - info.top;
  if (left && spaceLeft < Math.min(infoWidth, spaceRight))
    left = false;
  else if (!left && spaceRight < Math.min(infoWidth, spaceLeft))
    left = true;
  if (infoWidth <= (left ? spaceLeft : spaceRight)) {
    offset = Math.max(space.top, Math.min(option.top, space.bottom - infoHeight)) - list.top;
    maxWidth = Math.min(400, left ? spaceLeft : spaceRight);
  } else {
    narrow = true;
    maxWidth = Math.min(
      400,
      (rtl ? list.right : space.right - list.left) - 30
      /* Info.Margin */
    );
    let spaceBelow = space.bottom - list.bottom;
    if (spaceBelow >= infoHeight || spaceBelow > list.top) {
      offset = option.bottom - list.top;
    } else {
      side = "bottom";
      offset = list.bottom - option.top;
    }
  }
  let scaleY = (list.bottom - list.top) / tooltip.offsetHeight;
  let scaleX = (list.right - list.left) / tooltip.offsetWidth;
  return {
    style: `${side}: ${offset / scaleY}px; max-width: ${maxWidth / scaleX}px`,
    class: "cm-completionInfo-" + (narrow ? rtl ? "left-narrow" : "right-narrow" : left ? "left" : "right")
  };
}
function optionContent(config2) {
  let content2 = config2.addToOptions.slice();
  if (config2.icons)
    content2.push({
      render(completion) {
        let icon = document.createElement("div");
        icon.classList.add("cm-completionIcon");
        if (completion.type)
          icon.classList.add(...completion.type.split(/\s+/g).map((cls) => "cm-completionIcon-" + cls));
        icon.setAttribute("aria-hidden", "true");
        return icon;
      },
      position: 20
    });
  content2.push({
    render(completion, _s, _v, match) {
      let labelElt = document.createElement("span");
      labelElt.className = "cm-completionLabel";
      let label = completion.displayLabel || completion.label, off = 0;
      for (let j = 0; j < match.length; ) {
        let from = match[j++], to = match[j++];
        if (from > off)
          labelElt.appendChild(document.createTextNode(label.slice(off, from)));
        let span = labelElt.appendChild(document.createElement("span"));
        span.appendChild(document.createTextNode(label.slice(from, to)));
        span.className = "cm-completionMatchedText";
        off = to;
      }
      if (off < label.length)
        labelElt.appendChild(document.createTextNode(label.slice(off)));
      return labelElt;
    },
    position: 50
  }, {
    render(completion) {
      if (!completion.detail)
        return null;
      let detailElt = document.createElement("span");
      detailElt.className = "cm-completionDetail";
      detailElt.textContent = completion.detail;
      return detailElt;
    },
    position: 80
  });
  return content2.sort((a, b) => a.position - b.position).map((a) => a.render);
}
function rangeAroundSelected(total, selected, max) {
  if (total <= max)
    return { from: 0, to: total };
  if (selected < 0)
    selected = 0;
  if (selected <= total >> 1) {
    let off2 = Math.floor(selected / max);
    return { from: off2 * max, to: (off2 + 1) * max };
  }
  let off = Math.floor((total - selected) / max);
  return { from: total - (off + 1) * max, to: total - off * max };
}
var CompletionTooltip = class {
  constructor(view, stateField, applyCompletion2) {
    this.view = view;
    this.stateField = stateField;
    this.applyCompletion = applyCompletion2;
    this.info = null;
    this.infoDestroy = null;
    this.placeInfoReq = {
      read: () => this.measureInfo(),
      write: (pos) => this.placeInfo(pos),
      key: this
    };
    this.space = null;
    this.currentClass = "";
    let cState = view.state.field(stateField);
    let { options, selected } = cState.open;
    let config2 = view.state.facet(completionConfig);
    this.optionContent = optionContent(config2);
    this.optionClass = config2.optionClass;
    this.tooltipClass = config2.tooltipClass;
    this.range = rangeAroundSelected(options.length, selected, config2.maxRenderedOptions);
    this.dom = document.createElement("div");
    this.dom.className = "cm-tooltip-autocomplete";
    this.updateTooltipClass(view.state);
    this.dom.addEventListener("mousedown", (e) => {
      let { options: options2 } = view.state.field(stateField).open;
      for (let dom2 = e.target, match; dom2 && dom2 != this.dom; dom2 = dom2.parentNode) {
        if (dom2.nodeName == "LI" && (match = /-(\d+)$/.exec(dom2.id)) && +match[1] < options2.length) {
          this.applyCompletion(view, options2[+match[1]]);
          e.preventDefault();
          return;
        }
      }
    });
    this.dom.addEventListener("focusout", (e) => {
      let state = view.state.field(this.stateField, false);
      if (state && state.tooltip && view.state.facet(completionConfig).closeOnBlur && e.relatedTarget != view.contentDOM)
        view.dispatch({ effects: closeCompletionEffect.of(null) });
    });
    this.showOptions(options, cState.id);
  }
  mount() {
    this.updateSel();
  }
  showOptions(options, id) {
    if (this.list)
      this.list.remove();
    this.list = this.dom.appendChild(this.createListBox(options, id, this.range));
    this.list.addEventListener("scroll", () => {
      if (this.info)
        this.view.requestMeasure(this.placeInfoReq);
    });
  }
  update(update) {
    var _a;
    let cState = update.state.field(this.stateField);
    let prevState = update.startState.field(this.stateField);
    this.updateTooltipClass(update.state);
    if (cState != prevState) {
      let { options, selected, disabled } = cState.open;
      if (!prevState.open || prevState.open.options != options) {
        this.range = rangeAroundSelected(options.length, selected, update.state.facet(completionConfig).maxRenderedOptions);
        this.showOptions(options, cState.id);
      }
      this.updateSel();
      if (disabled != ((_a = prevState.open) === null || _a === void 0 ? void 0 : _a.disabled))
        this.dom.classList.toggle("cm-tooltip-autocomplete-disabled", !!disabled);
    }
  }
  updateTooltipClass(state) {
    let cls = this.tooltipClass(state);
    if (cls != this.currentClass) {
      for (let c of this.currentClass.split(" "))
        if (c)
          this.dom.classList.remove(c);
      for (let c of cls.split(" "))
        if (c)
          this.dom.classList.add(c);
      this.currentClass = cls;
    }
  }
  positioned(space) {
    this.space = space;
    if (this.info)
      this.view.requestMeasure(this.placeInfoReq);
  }
  updateSel() {
    let cState = this.view.state.field(this.stateField), open = cState.open;
    if (open.selected > -1 && open.selected < this.range.from || open.selected >= this.range.to) {
      this.range = rangeAroundSelected(open.options.length, open.selected, this.view.state.facet(completionConfig).maxRenderedOptions);
      this.showOptions(open.options, cState.id);
    }
    if (this.updateSelectedOption(open.selected)) {
      this.destroyInfo();
      let { completion } = open.options[open.selected];
      let { info } = completion;
      if (!info)
        return;
      let infoResult = typeof info === "string" ? document.createTextNode(info) : info(completion);
      if (!infoResult)
        return;
      if ("then" in infoResult) {
        infoResult.then((obj) => {
          if (obj && this.view.state.field(this.stateField, false) == cState)
            this.addInfoPane(obj, completion);
        }).catch((e) => logException(this.view.state, e, "completion info"));
      } else {
        this.addInfoPane(infoResult, completion);
      }
    }
  }
  addInfoPane(content2, completion) {
    this.destroyInfo();
    let wrap = this.info = document.createElement("div");
    wrap.className = "cm-tooltip cm-completionInfo";
    if (content2.nodeType != null) {
      wrap.appendChild(content2);
      this.infoDestroy = null;
    } else {
      let { dom: dom2, destroy } = content2;
      wrap.appendChild(dom2);
      this.infoDestroy = destroy || null;
    }
    this.dom.appendChild(wrap);
    this.view.requestMeasure(this.placeInfoReq);
  }
  updateSelectedOption(selected) {
    let set = null;
    for (let opt = this.list.firstChild, i = this.range.from; opt; opt = opt.nextSibling, i++) {
      if (opt.nodeName != "LI" || !opt.id) {
        i--;
      } else if (i == selected) {
        if (!opt.hasAttribute("aria-selected")) {
          opt.setAttribute("aria-selected", "true");
          set = opt;
        }
      } else {
        if (opt.hasAttribute("aria-selected"))
          opt.removeAttribute("aria-selected");
      }
    }
    if (set)
      scrollIntoView(this.list, set);
    return set;
  }
  measureInfo() {
    let sel = this.dom.querySelector("[aria-selected]");
    if (!sel || !this.info)
      return null;
    let listRect = this.dom.getBoundingClientRect();
    let infoRect = this.info.getBoundingClientRect();
    let selRect = sel.getBoundingClientRect();
    let space = this.space;
    if (!space) {
      let docElt = this.dom.ownerDocument.documentElement;
      space = { left: 0, top: 0, right: docElt.clientWidth, bottom: docElt.clientHeight };
    }
    if (selRect.top > Math.min(space.bottom, listRect.bottom) - 10 || selRect.bottom < Math.max(space.top, listRect.top) + 10)
      return null;
    return this.view.state.facet(completionConfig).positionInfo(this.view, listRect, selRect, infoRect, space, this.dom);
  }
  placeInfo(pos) {
    if (this.info) {
      if (pos) {
        if (pos.style)
          this.info.style.cssText = pos.style;
        this.info.className = "cm-tooltip cm-completionInfo " + (pos.class || "");
      } else {
        this.info.style.cssText = "top: -1e6px";
      }
    }
  }
  createListBox(options, id, range) {
    const ul = document.createElement("ul");
    ul.id = id;
    ul.setAttribute("role", "listbox");
    ul.setAttribute("aria-expanded", "true");
    ul.setAttribute("aria-label", this.view.state.phrase("Completions"));
    ul.addEventListener("mousedown", (e) => {
      if (e.target == ul)
        e.preventDefault();
    });
    let curSection = null;
    for (let i = range.from; i < range.to; i++) {
      let { completion, match } = options[i], { section } = completion;
      if (section) {
        let name2 = typeof section == "string" ? section : section.name;
        if (name2 != curSection && (i > range.from || range.from == 0)) {
          curSection = name2;
          if (typeof section != "string" && section.header) {
            ul.appendChild(section.header(section));
          } else {
            let header = ul.appendChild(document.createElement("completion-section"));
            header.textContent = name2;
          }
        }
      }
      const li = ul.appendChild(document.createElement("li"));
      li.id = id + "-" + i;
      li.setAttribute("role", "option");
      let cls = this.optionClass(completion);
      if (cls)
        li.className = cls;
      for (let source of this.optionContent) {
        let node = source(completion, this.view.state, this.view, match);
        if (node)
          li.appendChild(node);
      }
    }
    if (range.from)
      ul.classList.add("cm-completionListIncompleteTop");
    if (range.to < options.length)
      ul.classList.add("cm-completionListIncompleteBottom");
    return ul;
  }
  destroyInfo() {
    if (this.info) {
      if (this.infoDestroy)
        this.infoDestroy();
      this.info.remove();
      this.info = null;
    }
  }
  destroy() {
    this.destroyInfo();
  }
};
function completionTooltip(stateField, applyCompletion2) {
  return (view) => new CompletionTooltip(view, stateField, applyCompletion2);
}
function scrollIntoView(container, element) {
  let parent = container.getBoundingClientRect();
  let self = element.getBoundingClientRect();
  let scaleY = parent.height / container.offsetHeight;
  if (self.top < parent.top)
    container.scrollTop -= (parent.top - self.top) / scaleY;
  else if (self.bottom > parent.bottom)
    container.scrollTop += (self.bottom - parent.bottom) / scaleY;
}
function score(option) {
  return (option.boost || 0) * 100 + (option.apply ? 10 : 0) + (option.info ? 5 : 0) + (option.type ? 1 : 0);
}
function sortOptions(active, state) {
  let options = [];
  let sections = null;
  let addOption = (option) => {
    options.push(option);
    let { section } = option.completion;
    if (section) {
      if (!sections)
        sections = [];
      let name2 = typeof section == "string" ? section : section.name;
      if (!sections.some((s) => s.name == name2))
        sections.push(typeof section == "string" ? { name: name2 } : section);
    }
  };
  let conf = state.facet(completionConfig);
  for (let a of active)
    if (a.hasResult()) {
      let getMatch = a.result.getMatch;
      if (a.result.filter === false) {
        for (let option of a.result.options) {
          addOption(new Option(option, a.source, getMatch ? getMatch(option) : [], 1e9 - options.length));
        }
      } else {
        let pattern = state.sliceDoc(a.from, a.to), match;
        let matcher = conf.filterStrict ? new StrictMatcher(pattern) : new FuzzyMatcher(pattern);
        for (let option of a.result.options)
          if (match = matcher.match(option.label)) {
            let matched = !option.displayLabel ? match.matched : getMatch ? getMatch(option, match.matched) : [];
            addOption(new Option(option, a.source, matched, match.score + (option.boost || 0)));
          }
      }
    }
  if (sections) {
    let sectionOrder = /* @__PURE__ */ Object.create(null), pos = 0;
    let cmp = (a, b) => {
      var _a, _b;
      return ((_a = a.rank) !== null && _a !== void 0 ? _a : 1e9) - ((_b = b.rank) !== null && _b !== void 0 ? _b : 1e9) || (a.name < b.name ? -1 : 1);
    };
    for (let s of sections.sort(cmp)) {
      pos -= 1e5;
      sectionOrder[s.name] = pos;
    }
    for (let option of options) {
      let { section } = option.completion;
      if (section)
        option.score += sectionOrder[typeof section == "string" ? section : section.name];
    }
  }
  let result = [], prev = null;
  let compare2 = conf.compareCompletions;
  for (let opt of options.sort((a, b) => b.score - a.score || compare2(a.completion, b.completion))) {
    let cur2 = opt.completion;
    if (!prev || prev.label != cur2.label || prev.detail != cur2.detail || prev.type != null && cur2.type != null && prev.type != cur2.type || prev.apply != cur2.apply || prev.boost != cur2.boost)
      result.push(opt);
    else if (score(opt.completion) > score(prev))
      result[result.length - 1] = opt;
    prev = opt.completion;
  }
  return result;
}
var CompletionDialog = class _CompletionDialog {
  constructor(options, attrs, tooltip, timestamp, selected, disabled) {
    this.options = options;
    this.attrs = attrs;
    this.tooltip = tooltip;
    this.timestamp = timestamp;
    this.selected = selected;
    this.disabled = disabled;
  }
  setSelected(selected, id) {
    return selected == this.selected || selected >= this.options.length ? this : new _CompletionDialog(this.options, makeAttrs(id, selected), this.tooltip, this.timestamp, selected, this.disabled);
  }
  static build(active, state, id, prev, conf, didSetActive) {
    if (prev && !didSetActive && active.some((s) => s.isPending))
      return prev.setDisabled();
    let options = sortOptions(active, state);
    if (!options.length)
      return prev && active.some((a) => a.isPending) ? prev.setDisabled() : null;
    let selected = state.facet(completionConfig).selectOnOpen ? 0 : -1;
    if (prev && prev.selected != selected && prev.selected != -1) {
      let selectedValue = prev.options[prev.selected].completion;
      for (let i = 0; i < options.length; i++)
        if (options[i].completion == selectedValue) {
          selected = i;
          break;
        }
    }
    return new _CompletionDialog(options, makeAttrs(id, selected), {
      pos: active.reduce((a, b) => b.hasResult() ? Math.min(a, b.from) : a, 1e8),
      create: createTooltip,
      above: conf.aboveCursor
    }, prev ? prev.timestamp : Date.now(), selected, false);
  }
  map(changes) {
    return new _CompletionDialog(this.options, this.attrs, Object.assign(Object.assign({}, this.tooltip), { pos: changes.mapPos(this.tooltip.pos) }), this.timestamp, this.selected, this.disabled);
  }
  setDisabled() {
    return new _CompletionDialog(this.options, this.attrs, this.tooltip, this.timestamp, this.selected, true);
  }
};
var CompletionState = class _CompletionState {
  constructor(active, id, open) {
    this.active = active;
    this.id = id;
    this.open = open;
  }
  static start() {
    return new _CompletionState(none2, "cm-ac-" + Math.floor(Math.random() * 2e6).toString(36), null);
  }
  update(tr) {
    let { state } = tr, conf = state.facet(completionConfig);
    let sources = conf.override || state.languageDataAt("autocomplete", cur(state)).map(asSource);
    let active = sources.map((source) => {
      let value = this.active.find((s) => s.source == source) || new ActiveSource(
        source,
        this.active.some(
          (a) => a.state != 0
          /* State.Inactive */
        ) ? 1 : 0
        /* State.Inactive */
      );
      return value.update(tr, conf);
    });
    if (active.length == this.active.length && active.every((a, i) => a == this.active[i]))
      active = this.active;
    let open = this.open, didSet = tr.effects.some((e) => e.is(setActiveEffect));
    if (open && tr.docChanged)
      open = open.map(tr.changes);
    if (tr.selection || active.some((a) => a.hasResult() && tr.changes.touchesRange(a.from, a.to)) || !sameResults(active, this.active) || didSet)
      open = CompletionDialog.build(active, state, this.id, open, conf, didSet);
    else if (open && open.disabled && !active.some((a) => a.isPending))
      open = null;
    if (!open && active.every((a) => !a.isPending) && active.some((a) => a.hasResult()))
      active = active.map((a) => a.hasResult() ? new ActiveSource(
        a.source,
        0
        /* State.Inactive */
      ) : a);
    for (let effect of tr.effects)
      if (effect.is(setSelectedEffect))
        open = open && open.setSelected(effect.value, this.id);
    return active == this.active && open == this.open ? this : new _CompletionState(active, this.id, open);
  }
  get tooltip() {
    return this.open ? this.open.tooltip : null;
  }
  get attrs() {
    return this.open ? this.open.attrs : this.active.length ? baseAttrs : noAttrs;
  }
};
function sameResults(a, b) {
  if (a == b)
    return true;
  for (let iA = 0, iB = 0; ; ) {
    while (iA < a.length && !a[iA].hasResult())
      iA++;
    while (iB < b.length && !b[iB].hasResult())
      iB++;
    let endA = iA == a.length, endB = iB == b.length;
    if (endA || endB)
      return endA == endB;
    if (a[iA++].result != b[iB++].result)
      return false;
  }
}
var baseAttrs = {
  "aria-autocomplete": "list"
};
var noAttrs = {};
function makeAttrs(id, selected) {
  let result = {
    "aria-autocomplete": "list",
    "aria-haspopup": "listbox",
    "aria-controls": id
  };
  if (selected > -1)
    result["aria-activedescendant"] = id + "-" + selected;
  return result;
}
var none2 = [];
function getUpdateType(tr, conf) {
  if (tr.isUserEvent("input.complete")) {
    let completion = tr.annotation(pickedCompletion);
    if (completion && conf.activateOnCompletion(completion))
      return 4 | 8;
  }
  let typing = tr.isUserEvent("input.type");
  return typing && conf.activateOnTyping ? 4 | 1 : typing ? 1 : tr.isUserEvent("delete.backward") ? 2 : tr.selection ? 8 : tr.docChanged ? 16 : 0;
}
var ActiveSource = class _ActiveSource {
  constructor(source, state, explicit = false) {
    this.source = source;
    this.state = state;
    this.explicit = explicit;
  }
  hasResult() {
    return false;
  }
  get isPending() {
    return this.state == 1;
  }
  update(tr, conf) {
    let type = getUpdateType(tr, conf), value = this;
    if (type & 8 || type & 16 && this.touches(tr))
      value = new _ActiveSource(
        value.source,
        0
        /* State.Inactive */
      );
    if (type & 4 && value.state == 0)
      value = new _ActiveSource(
        this.source,
        1
        /* State.Pending */
      );
    value = value.updateFor(tr, type);
    for (let effect of tr.effects) {
      if (effect.is(startCompletionEffect))
        value = new _ActiveSource(value.source, 1, effect.value);
      else if (effect.is(closeCompletionEffect))
        value = new _ActiveSource(
          value.source,
          0
          /* State.Inactive */
        );
      else if (effect.is(setActiveEffect)) {
        for (let active of effect.value)
          if (active.source == value.source)
            value = active;
      }
    }
    return value;
  }
  updateFor(tr, type) {
    return this.map(tr.changes);
  }
  map(changes) {
    return this;
  }
  touches(tr) {
    return tr.changes.touchesRange(cur(tr.state));
  }
};
var ActiveResult = class _ActiveResult extends ActiveSource {
  constructor(source, explicit, limit, result, from, to) {
    super(source, 3, explicit);
    this.limit = limit;
    this.result = result;
    this.from = from;
    this.to = to;
  }
  hasResult() {
    return true;
  }
  updateFor(tr, type) {
    var _a;
    if (!(type & 3))
      return this.map(tr.changes);
    let result = this.result;
    if (result.map && !tr.changes.empty)
      result = result.map(result, tr.changes);
    let from = tr.changes.mapPos(this.from), to = tr.changes.mapPos(this.to, 1);
    let pos = cur(tr.state);
    if (pos > to || !result || type & 2 && (cur(tr.startState) == this.from || pos < this.limit))
      return new ActiveSource(
        this.source,
        type & 4 ? 1 : 0
        /* State.Inactive */
      );
    let limit = tr.changes.mapPos(this.limit);
    if (checkValid(result.validFor, tr.state, from, to))
      return new _ActiveResult(this.source, this.explicit, limit, result, from, to);
    if (result.update && (result = result.update(result, from, to, new CompletionContext(tr.state, pos, false))))
      return new _ActiveResult(this.source, this.explicit, limit, result, result.from, (_a = result.to) !== null && _a !== void 0 ? _a : cur(tr.state));
    return new ActiveSource(this.source, 1, this.explicit);
  }
  map(mapping) {
    if (mapping.empty)
      return this;
    let result = this.result.map ? this.result.map(this.result, mapping) : this.result;
    if (!result)
      return new ActiveSource(
        this.source,
        0
        /* State.Inactive */
      );
    return new _ActiveResult(this.source, this.explicit, mapping.mapPos(this.limit), this.result, mapping.mapPos(this.from), mapping.mapPos(this.to, 1));
  }
  touches(tr) {
    return tr.changes.touchesRange(this.from, this.to);
  }
};
function checkValid(validFor, state, from, to) {
  if (!validFor)
    return false;
  let text = state.sliceDoc(from, to);
  return typeof validFor == "function" ? validFor(text, from, to, state) : ensureAnchor(validFor, true).test(text);
}
var setActiveEffect = /* @__PURE__ */ StateEffect.define({
  map(sources, mapping) {
    return sources.map((s) => s.map(mapping));
  }
});
var setSelectedEffect = /* @__PURE__ */ StateEffect.define();
var completionState = /* @__PURE__ */ StateField.define({
  create() {
    return CompletionState.start();
  },
  update(value, tr) {
    return value.update(tr);
  },
  provide: (f) => [
    showTooltip.from(f, (val) => val.tooltip),
    EditorView.contentAttributes.from(f, (state) => state.attrs)
  ]
});
function applyCompletion(view, option) {
  const apply = option.completion.apply || option.completion.label;
  let result = view.state.field(completionState).active.find((a) => a.source == option.source);
  if (!(result instanceof ActiveResult))
    return false;
  if (typeof apply == "string")
    view.dispatch(Object.assign(Object.assign({}, insertCompletionText(view.state, apply, result.from, result.to)), { annotations: pickedCompletion.of(option.completion) }));
  else
    apply(view, option.completion, result.from, result.to);
  return true;
}
var createTooltip = /* @__PURE__ */ completionTooltip(completionState, applyCompletion);
var acceptCompletion = (view) => {
  let cState = view.state.field(completionState, false);
  if (view.state.readOnly || !cState || !cState.open || cState.open.selected < 0 || cState.open.disabled || Date.now() - cState.open.timestamp < view.state.facet(completionConfig).interactionDelay)
    return false;
  return applyCompletion(view, cState.open.options[cState.open.selected]);
};
var closeCompletion = (view) => {
  let cState = view.state.field(completionState, false);
  if (!cState || !cState.active.some(
    (a) => a.state != 0
    /* State.Inactive */
  ))
    return false;
  view.dispatch({ effects: closeCompletionEffect.of(null) });
  return true;
};
var windows = typeof navigator == "object" && /* @__PURE__ */ /Win/.test(navigator.platform);
var defaults = {
  brackets: ["(", "[", "{", "'", '"'],
  before: ")]}:;>",
  stringPrefixes: []
};
var closeBracketEffect = /* @__PURE__ */ StateEffect.define({
  map(value, mapping) {
    let mapped = mapping.mapPos(value, -1, MapMode.TrackAfter);
    return mapped == null ? void 0 : mapped;
  }
});
var closedBracket = /* @__PURE__ */ new class extends RangeValue {
}();
closedBracket.startSide = 1;
closedBracket.endSide = -1;
var bracketState = /* @__PURE__ */ StateField.define({
  create() {
    return RangeSet.empty;
  },
  update(value, tr) {
    value = value.map(tr.changes);
    if (tr.selection) {
      let line = tr.state.doc.lineAt(tr.selection.main.head);
      value = value.update({ filter: (from) => from >= line.from && from <= line.to });
    }
    for (let effect of tr.effects)
      if (effect.is(closeBracketEffect))
        value = value.update({ add: [closedBracket.range(effect.value, effect.value + 1)] });
    return value;
  }
});
function closeBrackets() {
  return [inputHandler, bracketState];
}
var definedClosing = "()[]{}<>\xAB\xBB\xBB\xAB\uFF3B\uFF3D\uFF5B\uFF5D";
function closing(ch) {
  for (let i = 0; i < definedClosing.length; i += 2)
    if (definedClosing.charCodeAt(i) == ch)
      return definedClosing.charAt(i + 1);
  return fromCodePoint(ch < 128 ? ch : ch + 1);
}
function config(state, pos) {
  return state.languageDataAt("closeBrackets", pos)[0] || defaults;
}
var android = typeof navigator == "object" && /* @__PURE__ */ /Android\b/.test(navigator.userAgent);
var inputHandler = /* @__PURE__ */ EditorView.inputHandler.of((view, from, to, insert2) => {
  if ((android ? view.composing : view.compositionStarted) || view.state.readOnly)
    return false;
  let sel = view.state.selection.main;
  if (insert2.length > 2 || insert2.length == 2 && codePointSize2(codePointAt2(insert2, 0)) == 1 || from != sel.from || to != sel.to)
    return false;
  let tr = insertBracket(view.state, insert2);
  if (!tr)
    return false;
  view.dispatch(tr);
  return true;
});
function insertBracket(state, bracket2) {
  let conf = config(state, state.selection.main.head);
  let tokens = conf.brackets || defaults.brackets;
  for (let tok of tokens) {
    let closed = closing(codePointAt2(tok, 0));
    if (bracket2 == tok)
      return closed == tok ? handleSame(state, tok, tokens.indexOf(tok + tok + tok) > -1, conf) : handleOpen(state, tok, closed, conf.before || defaults.before);
    if (bracket2 == closed && closedBracketAt(state, state.selection.main.from))
      return handleClose(state, tok, closed);
  }
  return null;
}
function closedBracketAt(state, pos) {
  let found = false;
  state.field(bracketState).between(0, state.doc.length, (from) => {
    if (from == pos)
      found = true;
  });
  return found;
}
function nextChar(doc, pos) {
  let next = doc.sliceString(pos, pos + 2);
  return next.slice(0, codePointSize2(codePointAt2(next, 0)));
}
function handleOpen(state, open, close, closeBefore) {
  let dont = null, changes = state.changeByRange((range) => {
    if (!range.empty)
      return {
        changes: [{ insert: open, from: range.from }, { insert: close, from: range.to }],
        effects: closeBracketEffect.of(range.to + open.length),
        range: EditorSelection.range(range.anchor + open.length, range.head + open.length)
      };
    let next = nextChar(state.doc, range.head);
    if (!next || /\s/.test(next) || closeBefore.indexOf(next) > -1)
      return {
        changes: { insert: open + close, from: range.head },
        effects: closeBracketEffect.of(range.head + open.length),
        range: EditorSelection.cursor(range.head + open.length)
      };
    return { range: dont = range };
  });
  return dont ? null : state.update(changes, {
    scrollIntoView: true,
    userEvent: "input.type"
  });
}
function handleClose(state, _open, close) {
  let dont = null, changes = state.changeByRange((range) => {
    if (range.empty && nextChar(state.doc, range.head) == close)
      return {
        changes: { from: range.head, to: range.head + close.length, insert: close },
        range: EditorSelection.cursor(range.head + close.length)
      };
    return dont = { range };
  });
  return dont ? null : state.update(changes, {
    scrollIntoView: true,
    userEvent: "input.type"
  });
}
function handleSame(state, token, allowTriple, config2) {
  let stringPrefixes = config2.stringPrefixes || defaults.stringPrefixes;
  let dont = null, changes = state.changeByRange((range) => {
    if (!range.empty)
      return {
        changes: [{ insert: token, from: range.from }, { insert: token, from: range.to }],
        effects: closeBracketEffect.of(range.to + token.length),
        range: EditorSelection.range(range.anchor + token.length, range.head + token.length)
      };
    let pos = range.head, next = nextChar(state.doc, pos), start;
    if (next == token) {
      if (nodeStart(state, pos)) {
        return {
          changes: { insert: token + token, from: pos },
          effects: closeBracketEffect.of(pos + token.length),
          range: EditorSelection.cursor(pos + token.length)
        };
      } else if (closedBracketAt(state, pos)) {
        let isTriple = allowTriple && state.sliceDoc(pos, pos + token.length * 3) == token + token + token;
        let content2 = isTriple ? token + token + token : token;
        return {
          changes: { from: pos, to: pos + content2.length, insert: content2 },
          range: EditorSelection.cursor(pos + content2.length)
        };
      }
    } else if (allowTriple && state.sliceDoc(pos - 2 * token.length, pos) == token + token && (start = canStartStringAt(state, pos - 2 * token.length, stringPrefixes)) > -1 && nodeStart(state, start)) {
      return {
        changes: { insert: token + token + token + token, from: pos },
        effects: closeBracketEffect.of(pos + token.length),
        range: EditorSelection.cursor(pos + token.length)
      };
    } else if (state.charCategorizer(pos)(next) != CharCategory.Word) {
      if (canStartStringAt(state, pos, stringPrefixes) > -1 && !probablyInString(state, pos, token, stringPrefixes))
        return {
          changes: { insert: token + token, from: pos },
          effects: closeBracketEffect.of(pos + token.length),
          range: EditorSelection.cursor(pos + token.length)
        };
    }
    return { range: dont = range };
  });
  return dont ? null : state.update(changes, {
    scrollIntoView: true,
    userEvent: "input.type"
  });
}
function nodeStart(state, pos) {
  let tree = syntaxTree(state).resolveInner(pos + 1);
  return tree.parent && tree.from == pos;
}
function probablyInString(state, pos, quoteToken, prefixes) {
  let node = syntaxTree(state).resolveInner(pos, -1);
  let maxPrefix = prefixes.reduce((m, p) => Math.max(m, p.length), 0);
  for (let i = 0; i < 5; i++) {
    let start = state.sliceDoc(node.from, Math.min(node.to, node.from + quoteToken.length + maxPrefix));
    let quotePos = start.indexOf(quoteToken);
    if (!quotePos || quotePos > -1 && prefixes.indexOf(start.slice(0, quotePos)) > -1) {
      let first = node.firstChild;
      while (first && first.from == node.from && first.to - first.from > quoteToken.length + quotePos) {
        if (state.sliceDoc(first.to - quoteToken.length, first.to) == quoteToken)
          return false;
        first = first.firstChild;
      }
      return true;
    }
    let parent = node.to == pos && node.parent;
    if (!parent)
      break;
    node = parent;
  }
  return false;
}
function canStartStringAt(state, pos, prefixes) {
  let charCat = state.charCategorizer(pos);
  if (charCat(state.sliceDoc(pos - 1, pos)) != CharCategory.Word)
    return pos;
  for (let prefix of prefixes) {
    let start = pos - prefix.length;
    if (state.sliceDoc(start, pos) == prefix && charCat(state.sliceDoc(start - 1, start)) != CharCategory.Word)
      return start;
  }
  return -1;
}

// src/editor.ts
import { forceParsing } from "@codemirror/language";
import { linter as linter2, lintGutter } from "@codemirror/lint";
import { indentWithTab } from "@codemirror/commands";
import { html } from "@codemirror/lang-html";
import { css } from "@codemirror/lang-css";
import { javascript } from "@codemirror/lang-javascript";

// src/i18n/en_us.ts
var en_us = {
  // Buttons
  Add: () => "Add",
  Remove: () => "Remove",
  Explain: () => "Explain",
  Fix: () => "Fix",
  // Linting messages
  "Unrecognized breed name _": (Name) => `Cannot recognize the breed name "${Name}". Did you define it at the beginning?`,
  "Unrecognized identifier _": (Name) => `Nothing called "${Name}" was defined or reserved by NetLogo. Did you forget to define it?`,
  "Unrecognized identifier with replacement _": (Name, Suggested) => `Nothing called "${Name}" was defined or reserved by NetLogo. Maybe try "${Suggested}"?`,
  "Unrecognized global statement _": (Name) => `Cannot recognize "${Name}" as a proper global statement here. Did you spell it correctly?`,
  "Unrecognized statement _": (Name) => `"${Name}" is out of place. Did you put it in the correct place?`,
  "Unrecognized statement with replacement _": (Name, Suggested) => `"${Name}" is out of place. Maybe try "${Suggested}"\uFF1F`,
  "Invalid content for code block _": (Name) => `"${Name}" is out of place in the surrounding code block.`,
  "Invalid content for list _": (Name) => `"${Name}" is out of place in the surrounding list.`,
  "Unsupported statement _": (Name) => `"${Name}" is not supported in this version of NetLogo.`,
  "Unsupported extension statement _": (Name) => `"${Name}" is not supported in this version of NetLogo. The parsing could be wrong.`,
  "Invalid for Normal mode _": (Value) => `This editor mode expects a full NetLogo model.`,
  "Invalid for Embedded mode _": (Value) => `This editor mode expects a few command statements.`,
  "Invalid for Oneline mode _": (Value) => `This editor mode expects command statements or a single expression.`,
  "Invalid for Reporter mode _": (Value) => `This editor mode expects a single expression.`,
  "Problem identifying primitive _. Expected _, found _.": (Name, Expected, Actual) => `"${Name}" is not a valid primitive. Expected ${Expected} but found ${Actual}.`,
  "Left args for _. Expected _, found _.": (Name, Expected, Actual) => `"${Name}" expects ${Expected} left argument(s). ${Actual} argument(s) found.`,
  "Too few right args for _. Expected _, found _.": (Name, Expected, Actual) => `"${Name}" expects at least ${Expected} right argument(s). ${Actual} argument(s) found.`,
  "Too many right args for _. Expected _, found _.": (Name, Expected, Actual) => `"${Name}" expects at most ${Expected} right argument(s). ${Actual} argument(s) found.`,
  "Missing extension _": (Name) => `Seems that you need to put "${Name}" in the "extensions" section. Do you want to do that now?`,
  "Unsupported missing extension _": (Name) => `"${Name}" is missing in the "extensions" section; this extension might not yet be supported by this version of NetLogo.`,
  "Unsupported extension _": (Name) => `The extension "${Name}" is not supported in this editor.`,
  "Term _ already used": (Name, Type) => `"${Name}" is already defined in the code. Try a different ${en_us[Type]().toLowerCase()} name.`,
  "Term _ reserved": (Name, Type) => `"${Name}" is a reserved keyword in NetLogo. Try a different ${en_us[Type]().toLowerCase()} name.`,
  "Variable _ reserved": (Name, Type) => `"${Name}" is a built-in variable in NetLogo. There is no need to define this ${en_us[Type]().toLowerCase()} in the code.`,
  "Invalid breed procedure _": (Name) => `It seems that you forgot to declare "${Name}" as a breed. Do you want to do that now?`,
  "Missing command _": () => `Every NetLogo statement has to start with a command.`,
  "Missing command before _": (Name) => `The statement "${Name}" needs to start with a command. What do you want to do with it?`,
  "Improperly placed procedure _": (Name) => `The procedure "${Name}" cannot be written prior to global statements. Do you want to move the procedure?`,
  "Unmatched item _": (Current, Expected) => `This "${Current}" needs a matching ${Expected}.`,
  "Invalid context _": (Prior, New, Primitive2) => `Based on preceding statements, the context of this codeblock is "${Prior}", but "${Primitive2}" has a "${New}" context.`,
  "Duplicate global statement _": (Name) => `The global "${Name}" statement is already defined. Do you want to combine into one?`,
  "Infinite loop _": (Name) => `This "${Name}" loop will run forever and likely block the model. Do you want to re-write into a "go" loop?`,
  "Argument is reserved _": (Name) => `The argument "${Name}" is a reserved NetLogo keyword. Do you want to replace it?`,
  "Argument is invalid _": (Name) => `The argument "${Name}" is invalid. Do you want to replace it?`,
  "Negation _": (Name) => `This expression looks like an incorrect negation. The correct format is "(- ${Name.substring(1)})".`,
  "Deprecated usage of ?": (Name) => `This expression looks like an incorrect anonymous procedure. The correct format looks like "[[ arg ] -> print arg]".`,
  "Incorrect usage of ,": (Name) => `In NetLogo, spaces " " are used to separate meanings. There is no need to use ",".`,
  "Invalid report _": (Name) => `"Report" can only be used in a procedure beginning with "to-report".`,
  "Invalid report warning _": (Name) => `"report" can only be used in a procedure beginning with "to-report". Would you like to change to "to-report"?`,
  "Invalid to-report _": (Name) => `Any procedure beginning with "to-report" must include the "report" command. Would you like to change to "to"?`,
  "Missing breed names _": (Name) => `A breed statement must contain a plural and a singular name inside of the brackets, e.g. "breed [ sheep a-sheep ]".`,
  "Invalid breed type _": (Name) => `This breed type cannot be used in this type of command`,
  // Agent types and basic names
  Observer: () => "Observer",
  Turtle: () => "Turtle",
  Turtles: () => "Turtles",
  Patch: () => "Patch",
  Patches: () => "Patches",
  Link: () => "Link",
  Links: () => "Links",
  Utility: () => "Utility",
  Command: () => "Command",
  Reporter: () => "Reporter",
  Argument: () => "Argument",
  Arguments: (Number2) => "Argument" + (Number2 > 1 ? "s" : ""),
  Breed: () => "Breed",
  Procedure: () => "Procedure",
  "Global variable": () => "Global variable",
  "Turtle variable": () => "Turtle variable",
  "Patch variable": () => "Patch variable",
  "Link variable": () => "Link variable",
  "Local variable": () => "Local variable",
  // Help messages
  "~VariableName": (Name) => `A (unknown) variable. `,
  "~ProcedureName": (Name) => `The name of a procedure. `,
  "~Arguments": (Name) => `The name of an argument. `,
  "~PatchVar": (Name) => `A built-in variable for every patch. `,
  "~TurtleVar": (Name) => `A built-in variable for every turtle. `,
  "~LinkVar": (Name) => `A built-in variable for every link. `,
  "~Reporter": (Name) => `A NetLogo reporter. `,
  "~Command": (Name) => `A NetLogo command. `,
  "~Constant": (Name) => `A NetLogo constant. `,
  "~Extension": (Name) => `A NetLogo extension. `,
  "~Numeric": (Name) => `A number. `,
  "~String": (Name) => `A string, which is a sequence of characters.`,
  "~LineComment": (Name) => `Comments do nothing in the program, but could help others read the code. `,
  "~Globals/Identifier": (Name) => `A code-defined global variable. `,
  "~WidgetGlobal": (Name) => `A widget-defined global variable. `,
  "~BreedVars/Identifier": (Name) => `A model-defined variable for a breed. `,
  "~BreedPlural": (Name) => `The plural name of a model-defined breed. `,
  "~BreedSingular": (Name) => `The singular name of a model-defined breed. `,
  "~BreedVariable": (Name) => `A custom variable for the "${Name}" breed. `,
  "~LocalVariable": (Name) => `A local variable within the "${Name.includes("{anonymous}") ? "{anonymous}" : Name}" procedure or reporter. `,
  "~BreedReporter": (Name) => `A reporter for the "${Name}" breed. `,
  "~CustomReporter": (Name) => `A user-defined reporter. `,
  "~BreedCommand": (Name) => `A command for the "${Name}" breed. `,
  "~CustomCommand": (Name) => `A user-defined command. `,
  // Chat and AI assistant
  ClickHere: () => "Click here",
  Reconnect: () => `Try it again`,
  RunCode: () => `Run`,
  "Trying to run the code": () => `Trying to run the code...`,
  "Trying to run the procedure _": (Name) => `Trying to run the procedure \`${Name}\`...`,
  FixCode: () => `Fix`,
  AskCode: () => `Ask`,
  AddCode: () => `Add to Code`,
  CopyCode: () => `Copy Code`,
  "Trying to add the code": () => `Trying to add the code to the project...`,
  PreviousVersion: () => `Back`,
  NextVersion: () => `Next`,
  PreviousPage: () => `Previous page`,
  NextPage: () => `Next page`,
  "Original version": () => `Showing the original content.`,
  "Translated version": () => `Showing the AI translated content.`,
  "Switch to original": () => `switch to original.`,
  "Switch to translated": () => `switch to AI translated.`,
  Need: () => `Need`,
  Finish: () => `Finish`,
  "Expand options _": (Number2) => `Expand ${Number2} option` + (Number2 > 1 ? "s" : ""),
  "Expand messages _": (Number2) => `Expand ${Number2} message` + (Number2 > 1 ? "s" : ""),
  "Code placeholder _": (Number2) => `Click to work on ${Number2} ${Number2 > 1 ? "lines" : "line"} of code`,
  FullText: () => `Read more`,
  Acknowledgement: () => "Acknowledgement",
  SeeAlso: () => `See Also`,
  OK: () => `OK`,
  Cancel: () => `Cancel`,
  "Run command": () => `Run command`,
  "Run reporter": () => `Run reporter`,
  "Execute the procedure": () => `Execute the procedure now`,
  // Editor interfaces
  MoreFeatures: () => "More features",
  SelectAll: () => "Select all",
  Undo: () => "Undo",
  Redo: () => "Redo",
  JumpToLine: () => "Jump to line",
  JumpToProcedure: () => "Jump to procedure",
  "There is no procedure": () => "There is no procedure in the code.",
  Prettify: () => "Prettify",
  ResetCode: () => "Reset code",
  "Do you want to reset the code": () => "Do you want to reset the code to the last successful compilation?",
  "Type NetLogo command here": () => "Type NetLogo command here",
  "Talk to the computer in NetLogo or natural languages": () => `Talk to the computer in NetLogo or natural languages`,
  "Press enter to execute again": () => `Press Enter will execute the code again.`,
  "Copied to clipboard": () => "The item has been copied to clipboard.",
  "Feature not supported": () => "The feature is not supported yet. Stay tuned!",
  // Chat and execution messages
  "Connection to server failed _": (Error2) => `Sorry, the connection to our server failed. Code ${Error2}.`,
  "Summary of request": () => `Below is a summary of my request: `,
  "We need to fix the following errors _": (Number2) => `Sorry, but we need to fix the ${Number2} errors in the code (marked with ___red squiggly lines___) before continuing.`,
  "Successfully executed": () => `Successfully executed the code.`,
  "Successfully compiled": () => `Successfully compiled the code. We can run them now!`,
  "Runtime error _": (Error2) => `Sorry, the code failed to run: ${Error2}`,
  "Runtime error in snippet _": (Number2) => `Sorry, there are ${Number2} errors during this run.`,
  "Compile error _": (Error2) => `Sorry, I cannot understand the code: ${Error2}`,
  "Compile error in snippet _": (Number2) => `Sorry, there are still ${Number2} errors in the code snippet.`,
  "Compile error unknown": (Number2) => `Sorry, there is an unknown error. Please report it as a bug.`,
  "Compile error in model": () => `Sorry, there are errors in the open project. Please fix the issue in the code tab first.`,
  "Showing full text help of _": (Name) => `Here is the help information of [${Name}](<observer=help ${Name} -full>).`,
  "Arguments needed for execution _": (Name, Arguments) => `The "${Name}" procedure needs ${Arguments > 1 ? "" : "an "}argument${Arguments > 1 ? "s" : ""} to run. Please provide ${Arguments > 1 ? "them" : "it"}.`,
  "Please download Turtle Universe": () => `The feature is unavailable in Web Preview. Please download [Turtle Universe](https://www.turtlesim.com/products/turtle-universe/) to continue.`,
  "Failed to retrieve knowledge": () => `Sorry, we did not find the specific knowledge.`,
  "Execute again": () => "Execute the code **again**",
  // Options
  "Help me fix this code": () => `Help me fix this code`,
  "Explain the error": () => `Explain the error`,
  // Default messages
  "Command center welcome (user)": () => `What is here about? Where should I start with?`,
  "Command center welcome (command)": () => `Here is the command center. You can type in NetLogo code and run it here, but there is always more to explore. Here are something you can try out.`,
  "Command center welcome (assistant)": () => `Hello! This is an AI assistant. I can help you learn NetLogo or build your own project, but there is always more to explore. Here are something you can try out.`,
  "Run NetLogo code directly": () => `Run **NetLogo** code directly`,
  "Check out the code tab": () => `Check out the **code** tab of the project`,
  "Talk to the computer in natural languages": () => `Talk to the computer in **natural languages**`,
  "Look for the documentation": () => `Look for the **learning materials** of NetLogo`,
  "Ask questions about NetLogo": () => `Ask **questions** about NetLogo`,
  // Color picker messages
  Grid: () => `Grid`,
  Wheel: () => `Wheel`,
  Slider: () => `Slider`,
  Red: () => `Red`,
  Blue: () => `Blue`,
  Green: () => `Green`,
  Alpha: () => `Alpha`,
  Hue: () => `Hue`,
  Saturation: () => `Saturation`,
  Luminance: () => `Luminance`,
  "Color Parameters": () => `Current Color`,
  "Color Swatches": () => `NetLogo Color Picker`,
  "Foreground Color": () => `Foreground Color`,
  "Background Color": () => `Background Color`,
  Increment: () => `Increment`,
  Numbers: () => `Numbers`
};

// src/i18n/zh_cn.ts
var zh_cn = {
  // Buttons
  Add: () => "\u6DFB\u52A0",
  Remove: () => "Remove",
  Explain: () => "Explain",
  Fix: () => "Fix",
  // Linting messages
  "Unrecognized breed name _": (Name) => `\u672A\u80FD\u8BC6\u522B\u51FA\u540D\u4E3A "${Name}" \u7684\u6D77\u9F9F\u79CD\u7C7B\u3002\u79CD\u7C7B\u9700\u8981\u5728\u4EE3\u7801\u7684\u5F00\u5934\u5904\u8FDB\u884C\u5B9A\u4E49\u3002`,
  "Unrecognized identifier _": (Name) => `"${Name}" \u65E2\u6CA1\u6709\u88AB\u5B9A\u4E49\uFF0C\u4E5F\u4E0D\u662F NetLogo \u7684\u5173\u952E\u5B57\u3002`,
  "Unrecognized identifier with replacement _": (Name, Suggested) => `"${Name}" \u65E2\u6CA1\u6709\u88AB\u5B9A\u4E49\uFF0C\u4E5F\u4E0D\u662F NetLogo \u7684\u5173\u952E\u5B57\u3002\u4E5F\u8BB8\u4F60\u60F3\u7528\u7684\u662F "${Suggested}"\uFF1F`,
  "Unrecognized global statement _": (Name) => `\u672A\u80FD\u8BC6\u522B\u51FA\u540D\u4E3A "${Name}" \u7684\u5168\u5C40\u58F0\u660E\u3002\u8BF7\u68C0\u67E5\u4F60\u7684\u62FC\u5199\u662F\u5426\u6B63\u786E\u3002`,
  "Unrecognized statement _": (Name) => `"${Name}" \u4E0D\u662F\u5408\u7406\u7684 NetLogo \u4EE3\u7801\u3002`,
  "Unrecognized statement with replacement _": (Name, Suggested) => `"${Name}" \u4E0D\u662F\u5408\u7406\u7684 NetLogo \u4EE3\u7801\u3002\u8BD5\u8BD5 "${Suggested}"\u3002`,
  "Invalid content for code block _": (Name) => `"${Name}" \u4E0D\u5E94\u5B58\u5728\u4E8E\u4EE3\u7801\u5757\u4E4B\u4E2D\u3002`,
  "Invalid content for list _": (Name) => `"${Name}" \u4E0D\u5E94\u5B58\u5728\u4E8E\u5217\u8868\u4E4B\u4E2D`,
  "Unsupported statement _": (Name) => `\u6B64\u7248\u672C NetLogo \u4E0D\u652F\u6301 "${Name}"\u3002`,
  "Unsupported extension statement _": (Name) => `\u6B64\u7248\u672C NetLogo \u4E0D\u652F\u6301 "${Name}"\u3002\u63D0\u793A\u548C\u9519\u8BEF\u4FE1\u606F\u53EF\u80FD\u4E0D\u6B63\u786E\u3002`,
  "Invalid for Normal mode _": (Value) => `\u6B64\u7F16\u8F91\u5668\u6A21\u5F0F\u53EA\u7528\u4E8E\u7F16\u8F91 NetLogo \u6A21\u578B\u3002`,
  "Invalid for Embedded mode _": (Value) => `\u6B64\u7F16\u8F91\u5668\u6A21\u5F0F\u53EA\u7528\u4E8E\u7F16\u8F91 NetLogo \u6A21\u578B\u4E2D\u7684\u4E00\u5C0F\u6BB5\u4EE3\u7801\u3002`,
  "Invalid for Reporter mode _": (Value) => `\u6B64\u7F16\u8F91\u5668\u6A21\u5F0F\u53EA\u7528\u4E8E\u7F16\u8F91 NetLogo \u6A21\u578B\u4E2D\u7684\u4E00\u5C0F\u6BB5\u8868\u8FBE\u5F0F\u3002`,
  "Invalid for Oneline mode _": (Value) => `\u6B64\u7F16\u8F91\u5668\u6A21\u5F0F\u53EA\u7528\u4E8E\u7F16\u8F91\u5355\u884C\u547D\u4EE4\u6216\u5355\u884C\u51FD\u6570\u3002`,
  "Problem identifying primitive _. Expected _, found _.": (Name, Expected, Actual) => `"${Name}" \u4E0D\u662F\u6709\u6548\u7684\u539F\u8BED\u3002\u9884\u8BA1 "${Expected}" \u5374\u5F97\u5230 "${Actual}"\u3002`,
  "Left args for _. Expected _, found _.": (Name, Expected, Actual) => `\u539F\u8BED "${Name}" \u9700\u8981 ${Expected} \u4E2A\u5DE6\u4FA7\u53C2\u6570\uFF0C\u4F46\u4EE3\u7801\u4E2D\u53EA\u6709 ${Actual} \u4E2A\u3002`,
  "Too few right args for _. Expected _, found _.": (Name, Expected, Actual) => `\u539F\u8BED "${Name}" \u9700\u8981\u81F3\u5C11 ${Expected} \u4E2A\u53F3\u4FA7\u53C2\u6570\uFF0C\u4F46\u4EE3\u7801\u4E2D\u53EA\u6709 ${Actual} \u4E2A\u3002`,
  "Too many right args for _. Expected _, found _.": (Name, Expected, Actual) => `"\u539F\u8BED "${Name}" \u9700\u8981\u81F3\u591A ${Expected} \u4E2A\u53F3\u4FA7\u53C2\u6570\uFF0C\u4F46\u4EE3\u7801\u4E2D\u53EA\u6709 ${Actual} \u4E2A\u3002`,
  "Invalid extension _.": (Name) => `\u770B\u8D77\u6765\u4F60\u9700\u8981\u5728 "extensions" \u4E2D\u52A0\u5165 "${Name}"\u3002\u60F3\u73B0\u5728\u8BD5\u8BD5\u5417\uFF1F`,
  "Term _ already used": (Name, Type) => `"${zh_cn[Type]()} ${Name}" \u5DF2\u7ECF\u88AB\u5B9A\u4E49\u8FC7\u4E86\u3002\u8BD5\u8BD5\u6362\u4E2A\u540D\u5B57\u5427\u3002`,
  "Term _ reserved": (Name, Type) => `"${zh_cn[Type]()} ${Name}" \u662F\u4E00\u4E2A NetLogo \u5173\u952E\u5B57\u3002\u8BD5\u8BD5\u6362\u4E2A\u540D\u5B57\u5427\u3002`,
  "Invalid breed procedure _": (Name) => `\u4F60\u8FD8\u6CA1\u6709\u5B9A\u4E49\u540D\u4E3A "${Name}" \u7684\u79CD\u7C7B\u3002\u60F3\u73B0\u5728\u8BD5\u8BD5\u5417\uFF1F`,
  "Missing command before _": (Name) => `\u8BED\u53E5 "${Name}" \u4E4B\u524D\u9700\u8981\u4E00\u4E2A\u547D\u4EE4\u3002\u4F60\u6253\u7B97\u7528\u5B83\u505A\u4E9B\u4EC0\u4E48\uFF1F`,
  "Improperly placed procedure _": (Name) => `\u8FC7\u7A0B\u6216\u51FD\u6570 "${Name}" \u5FC5\u987B\u653E\u5728\u6A21\u578B\u58F0\u660E\u7684\u540E\u9762\u3002\u60F3\u79FB\u52A8\u5B83\u5417\uFF1F`,
  "Unmatched item _": (Current, Expected) => `"${Current}" \u9700\u8981\u5BF9\u5E94\u7684 ${Expected}\u3002`,
  "Unsupported extension _": (Name) => `\u8FD9\u4E2A\u7F16\u8F91\u5668\u4E0D\u652F\u6301\u6269\u5C55 "${Name}"\u3002`,
  "Missing command _": () => `\u8FD9\u91CC\u9700\u8981\u589E\u52A0\u4E00\u4E2A\u547D\u4EE4\u3002`,
  "Missing extension _": (Name) => `\u4F60\u9700\u8981\u5C06\u6269\u5C55 "${Name}" \u653E\u8FDB "extensions" \u4E2D\u3002\u60F3\u73B0\u5728\u8BD5\u8BD5\u5417\uFF1F`,
  "Unsupported missing extension _": (Name) => `\u4F60\u9700\u8981\u5C06\u6269\u5C55 "${Name}" \u653E\u8FDB "extensions" \u4E2D\uFF0C\u4F46\u662F\u8FD9\u4E2A\u7F16\u8F91\u5668\u4E0D\u652F\u6301\u5B83\u3002`,
  "Invalid context _": (Prior, New, Primitive2) => `\u6839\u636E\u4E4B\u524D\u7684\u8BED\u53E5\uFF0C\u8FD9\u6BB5\u4EE3\u7801\u4E2D\u53EA\u80FD\u4F7F\u7528 "${Prior}" \u8BED\u53E5\uFF0C\u4F46 "${Primitive2}" \u5374\u53EA\u80FD\u7528\u4E8E "${New}"\u3002`,
  "Duplicate global statement _": (Name) => `\u5168\u5C40\u58F0\u660E "${Name}" \u5DF2\u7ECF\u88AB\u5B9A\u4E49\u8FC7\u4E86\u3002\u4F60\u60F3\u5408\u5E76\u5417\uFF1F`,
  "Infinite loop _": (Name) => `\u8FD9\u4E2A "${Name}" \u5FAA\u73AF\u5C06\u6C38\u8FDC\u8FD0\u884C\u4E0B\u53BB\uFF0C\u53EF\u80FD\u4F1A\u963B\u585E\u6A21\u578B\u3002\u4F60\u60F3\u5C06\u5B83\u6539\u6210 "go" \u5FAA\u73AF\u5417\uFF1F`,
  "Argument is reserved _": (Name) => `\u53C2\u6570\u540D\u79F0 "${Name}" \u548C NetLogo \u7684\u5173\u952E\u5B57\u91CD\u590D\u4E86\u3002\u4F60\u60F3\u6362\u4E00\u4E2A\u540D\u5B57\u5417\uFF1F`,
  "Argument is invalid _": (Name) => `\u53C2\u6570\u540D\u79F0 "${Name}" \u4E0D\u53EF\u7528\u3002\u4F60\u60F3\u6362\u4E00\u4E2A\u540D\u5B57\u5417\uFF1F`,
  "Inconsistent code block type _": (Prior, New) => `\u4E2D\u62EC\u53F7\u5185\u7684 "${New}" \u548C\u6B64\u524D\u89C2\u5BDF\u5230\u7684 "${Prior}" \u4E0D\u5339\u914D\u3002`,
  "Negation _": (Name) => `\u53D6\u8D1F\u503C\u7684\u65B9\u5F0F\u4E0D\u53D7\u652F\u6301\u3002\u6B63\u786E\u7684\u683C\u5F0F\u662F\uFF1A"(- ${Name.substring(1)})"\u3002`,
  "Deprecated usage of ?": (Name) => `\u533F\u540D\u51FD\u6570\u7684\u5199\u6CD5\u4E0D\u53D7\u652F\u6301\u3002\u6B63\u786E\u7684\u683C\u5F0F\u7C7B\u4F3C\u4E8E "[[ \u53C2\u6570 ] -> print \u53C2\u6570]".`,
  "Incorrect usage of ,": (Name) => `NetLogo \u8BED\u8A00\u4E2D\u4F7F\u7528\u7A7A\u683C\u5206\u9694\u8BCD\u4E49\uFF0C\u65E0\u987B\u4F7F\u7528 ","\u3002`,
  "Invalid report _": (Name) => `'report' \u53EA\u80FD\u5728\u51FD\u6570\uFF08to-report\uFF09\u4E2D\u4F7F\u7528\u3002`,
  "Invalid report warning _": (Name) => `'report' \u53EA\u80FD\u5728\u51FD\u6570\uFF08to-report\uFF09\u4E2D\u4F7F\u7528\u3002\u4F60\u60F3\u5C06\u8FC7\u7A0B\uFF08to\uFF09\u6539\u4E3A\u51FD\u6570\uFF08to-report\uFF09\u5417\uFF1F`,
  "Invalid to-report _": (Name) => `\u51FD\u6570\uFF08to-report\uFF09\u5FC5\u987B\u8FD4\u56DE\uFF08report\uFF09\u4E00\u4E2A\u503C\u3002\u4F60\u60F3\u5C06\u51FD\u6570\u6539\u4E3A\u8FC7\u7A0B\uFF08to\uFF09\u5417?`,
  "Missing breed names _": (Name) => `\u79CD\u7C7B\uFF08breed\uFF09\u8BED\u53E5\u4E2D\u5FC5\u987B\u5305\u62EC\u4E00\u4E2A\u590D\u6570\u548C\u4E00\u4E2A\u5355\u6570\u540D\u79F0\uFF0C\u4F8B\u5982 "breed [ sheep a-sheep ]"\u3002`,
  // Agent types and basic names
  Observer: () => "\u89C2\u5BDF\u8005",
  Turtle: () => "\u6D77\u9F9F",
  Turtles: () => "\u6D77\u9F9F\u4EEC",
  Patch: () => "\u683C\u5B50",
  Patches: () => "\u683C\u5B50\u4EEC",
  Link: () => "\u94FE\u63A5",
  Links: () => "\u94FE\u63A5\u4EEC",
  Utility: () => "\u5DE5\u5177",
  Command: () => "\u547D\u4EE4",
  Reporter: () => "\u51FD\u6570",
  Argument: () => "\u53C2\u6570",
  Arguments: () => "\u53C2\u6570",
  Breed: () => "\u79CD\u7C7B",
  Procedure: () => "\u8FC7\u7A0B",
  "Global variable": () => "\u5168\u5C40\u53D8\u91CF",
  "Turtle variable": () => "\u6D77\u9F9F\u53D8\u91CF",
  "Patch variable": () => "\u683C\u5B50\u53D8\u91CF",
  "Link variable": () => "\u94FE\u63A5\u53D8\u91CF",
  "Local variable": () => "\u672C\u5730\u53D8\u91CF",
  // Help messages
  "~VariableName": (Name) => `\u4E00\u4E2A\uFF08\u672A\u77E5\u7684\uFF09\u53D8\u91CF\u3002`,
  "~ProcedureName": (Name) => `\u8FC7\u7A0B\u6216\u51FD\u6570\u7684\u540D\u79F0\u3002`,
  "~Arguments": (Name) => `\u8FC7\u7A0B\u6216\u51FD\u6570\u5B9A\u4E49\u7684\u53C2\u6570\u540D\u79F0\u3002`,
  "~PatchVar": (Name) => `\u683C\u5B50\u7684\u5185\u7F6E\u53D8\u91CF\u3002`,
  "~TurtleVar": (Name) => `\u6D77\u9F9F\u7684\u5185\u7F6E\u53D8\u91CF\u3002`,
  "~LinkVar": (Name) => `\u94FE\u63A5\u7684\u5185\u7F6E\u53D8\u91CF\u3002`,
  "~Reporter": (Name) => `NetLogo \u8BED\u8A00\u7684\u5185\u7F6E\u51FD\u6570\u3002`,
  "~Command": (Name) => `NetLogo \u8BED\u8A00\u7684\u5185\u7F6E\u547D\u4EE4\u3002`,
  "~Constant": (Name) => `NetLogo \u8BED\u8A00\u89C4\u5B9A\u7684\u5E38\u91CF\u3002`,
  "~Extension": (Name) => `NetLogo \u8BED\u8A00\u7684\u6269\u5C55\u3002`,
  "~Numeric": (Name) => `\u4E00\u4E2A\u6570\u5B57\u3002`,
  "~String": (Name) => `\u5B57\u7B26\u4E32\uFF0C\u6216\u8005\u8BF4\u4E00\u4E32\u6587\u5B57\u3002`,
  "~LineComment": (Name) => `\u6CE8\u91CA\u5728\u4EE3\u7801\u4E2D\u6CA1\u6709\u76F4\u63A5\u4F5C\u7528\uFF0C\u4F46\u53EF\u4EE5\u5E2E\u52A9\u5176\u4ED6\u4EBA\u7406\u89E3\u4EE3\u7801\u3002`,
  "~Globals/Identifier": (Name) => `\u6A21\u578B\u4EE3\u7801\u4E2D\u5B9A\u4E49\u7684\u5168\u5C40\u53D8\u91CF\u3002`,
  "~BreedVars/Identifier": (Name) => `\u67D0\u7C7B\u6A21\u578B\u4E2D\u5B9A\u4E49\u7684\u6D77\u9F9F\u6216\u94FE\u63A5\u5177\u6709\u7684\u53D8\u91CF\u3002`,
  "~BreedPlural": (Name) => `\u67D0\u7C7B\u6A21\u578B\u4E2D\u5B9A\u4E49\u7684\u6D77\u9F9F\u7684\u590D\u6570\u540D\u79F0\u3002`,
  "~BreedSingular": (Name) => `\u67D0\u7C7B\u6A21\u578B\u4E2D\u5B9A\u4E49\u7684\u6D77\u9F9F\u7684\u5355\u6570\u540D\u79F0\u3002`,
  "~WidgetGlobal": (Name) => `\u901A\u8FC7\u754C\u9762\u7EC4\u4EF6\u5B9A\u4E49\u7684\u5168\u5C40\u53D8\u91CF\u3002 `,
  "~BreedVariable": (Name) => `\u79CD\u7C7B "${Name}" \u5B9A\u4E49\u7684\u53D8\u91CF\u3002`,
  "~LocalVariable": (Name) => `"${Name.includes("{anonymous}") ? "{\u533F\u540D}" : Name}" \u8FC7\u7A0B\u6216\u51FD\u6570\u5B9A\u4E49\u7684\u672C\u5730\u53D8\u91CF\u3002 `,
  "~BreedReporter": (Name) => `\u5173\u4E8E "${Name}" \u79CD\u7C7B\u7684\u51FD\u6570\u3002`,
  "~CustomReporter": (Name) => `\u4EE3\u7801\u4E2D\u5B9A\u4E49\u7684\u4E00\u4E2A\u51FD\u6570\u3002`,
  "~BreedCommand": (Name) => `\u5173\u4E8E "${Name}" \u79CD\u7C7B\u7684\u8FC7\u7A0B\u3002 `,
  "~CustomCommand": (Name) => `\u4EE3\u7801\u4E2D\u5B9A\u4E49\u7684\u4E00\u4E2A\u8FC7\u7A0B\u3002`,
  // Editor interfaces
  ClickHere: () => "\u70B9\u51FB\u8FD9\u91CC",
  MoreFeatures: () => "\u66F4\u591A\u529F\u80FD",
  SelectAll: () => "\u5168\u9009",
  Undo: () => "\u64A4\u9500",
  Redo: () => "\u91CD\u505A",
  JumpToLine: () => "\u8DF3\u8F6C\u5230\u884C",
  JumpToProcedure: () => "\u8DF3\u8F6C\u5230\u5B50\u7A0B\u5E8F",
  "There is no procedure": () => "\u4EE3\u7801\u4E2D\u8FD8\u6CA1\u6709\u4EFB\u4F55\u5B50\u7A0B\u5E8F\u3002",
  Prettify: () => "\u6574\u7406\u4EE3\u7801",
  ResetCode: () => "\u91CD\u7F6E\u4EE3\u7801",
  "Do you want to reset the code": () => "\u662F\u5426\u5C06\u4EE3\u7801\u91CD\u7F6E\u5230\u6700\u540E\u4E00\u6B21\u6210\u529F\u7F16\u8BD1\u7684\u72B6\u6001\uFF1F",
  "Type NetLogo command here": () => "\u5728\u8FD9\u91CC\u8F93\u5165 NetLogo \u547D\u4EE4",
  "Talk to the computer in NetLogo or natural languages": () => `\u7528 NetLogo \u6216\u81EA\u7136\u8BED\u8A00\u5199\u4EE3\u7801`,
  // Chat and AI interface
  Reconnect: () => `\u518D\u8BD5\u4E00\u6B21`,
  RunCode: () => `\u8FD0\u884C`,
  "Trying to run the code": () => `\u5C1D\u8BD5\u8FD0\u884C\u4EE3\u7801\u2026\u2026`,
  "Trying to run the procedure _": (Name) => `\u5C1D\u8BD5\u8FD0\u884C\u5B50\u7A0B\u5E8F \`${Name}\`\u2026\u2026`,
  FixCode: () => `\u4FEE\u590D`,
  AskCode: () => `\u63D0\u95EE`,
  AddCode: () => `\u653E\u5165\u4F5C\u54C1`,
  CopyCode: () => `\u590D\u5236\u4EE3\u7801`,
  "Trying to add the code": () => `\u5C1D\u8BD5\u5C06\u4EE3\u7801\u653E\u5165\u4F5C\u54C1\u2026\u2026`,
  PreviousVersion: () => `\u540E\u9000`,
  NextVersion: () => `\u524D\u8FDB`,
  PreviousPage: () => `\u8FD4\u56DE\u4E0A\u4E00\u9875`,
  NextPage: () => `\u8FDB\u5165\u4E0B\u4E00\u9875`,
  "Original version": () => `\u6B63\u5728\u663E\u793A\u539F\u6587\u3002`,
  "Translated version": () => `\u6B63\u5728\u663E\u793A AI \u7FFB\u8BD1\u7684\u5185\u5BB9\u3002`,
  "Switch to original": () => `\u663E\u793A\u539F\u6587\u3002`,
  "Switch to translated": () => `\u663E\u793A AI \u7FFB\u8BD1\u7684\u5185\u5BB9\u3002`,
  Need: () => `\u9700\u6C42`,
  Finish: () => `\u5B8C\u6210`,
  "Expand options _": (Number2) => `\u5C55\u5F00 ${Number2} \u4E2A\u9009\u9879`,
  "Expand messages _": (Number2) => `\u5C55\u5F00 ${Number2} \u6761\u6D88\u606F`,
  "Code placeholder _": (Number2) => `\u70B9\u51FB\u7F16\u8F91 ${Number2} \u884C\u4EE3\u7801`,
  FullText: () => `\u9605\u8BFB\u5168\u6587`,
  Acknowledgement: () => "\u81F4\u8C22",
  SeeAlso: () => `\u53C2\u89C1`,
  OK: () => `\u786E\u5B9A`,
  Cancel: () => `\u53D6\u6D88`,
  "Run command": () => `\u6267\u884C\u547D\u4EE4`,
  "Run reporter": () => `\u6267\u884C\u51FD\u6570`,
  "Execute the procedure": () => `\u5F00\u59CB\u6267\u884C\u8FD9\u6BB5\u7A0B\u5E8F`,
  "Press enter to execute again": () => `\u6309\u56DE\u8F66\u952E\u53EF\u4EE5\u518D\u6B21\u6267\u884C\u3002`,
  "Copied to clipboard": () => `\u5185\u5BB9\u5DF2\u590D\u5236\u5230\u526A\u8D34\u677F\u3002`,
  "Feature not supported": () => "\u6B64\u529F\u80FD\u5C1A\u672A\u63A8\u51FA\uFF0C\u656C\u8BF7\u671F\u5F85\uFF01",
  // Chat and execution messages
  "Connection to server failed _": (Error2) => `\u62B1\u6B49\uFF0C\u548C\u670D\u52A1\u5668\u7684\u8FDE\u63A5\u4E2D\u65AD\u4E86\u3002\u4EE3\u7801 ${Error2}\u3002`,
  "Summary of request": () => `\u7B80\u5355\u603B\u7ED3\u6211\u7684\u8BF7\u6C42\u7684\u8981\u70B9\uFF1A`,
  "We need to fix the following errors _": (Number2) => `\u6211\u4EEC\u9700\u8981\u5148\u4FEE\u590D\u4EE3\u7801\u4E2D\u7684 ${Number2} \u4E2A\u9519\u8BEF\uFF08\u7528___\u7EA2\u8272\u6CE2\u6D6A\u7EBF___\u6807\u8BB0\uFF09\u3002`,
  "Successfully executed": () => `\u6210\u529F\u6267\u884C\u4E86\u4EE3\u7801\u3002`,
  "Successfully compiled": () => `\u6210\u529F\u7F16\u8BD1\u4E86\u4EE3\u7801\u3002\u73B0\u5728\u53EF\u4EE5\u5F00\u59CB\u6267\u884C\u4E86\uFF01`,
  "Runtime error _": (Error2) => `\u8FD0\u884C\u65F6\u9519\u8BEF\uFF1A${Error2}`,
  "Compile error _": (Error2) => `\u62B1\u6B49\uFF0C\u672A\u80FD\u7406\u89E3\u4F60\u8F93\u5165\u7684\u547D\u4EE4\uFF1A${Error2}`,
  "Runtime error in snippet _": (Number2) => `\u62B1\u6B49\uFF0C\u4EE3\u7801\u8FD0\u884C\u65F6\u51FA\u73B0\u4E86 ${Number2} \u4E2A\u9519\u8BEF\u3002`,
  "Compile error in snippet _": (Number2) => `\u62B1\u6B49\uFF0C\u4EE3\u7801\u4E2D\u8FD8\u6709 ${Number2} \u4E2A\u9519\u8BEF\u3002`,
  "Compile error unknown": (Number2) => `\u62B1\u6B49\uFF0C\u7F16\u8BD1\u8FC7\u7A0B\u4E2D\u5B58\u5728\u672A\u77E5\u9519\u8BEF\u3002\u8BF7\u5C06 BUG \u62A5\u544A\u7ED9\u5F00\u53D1\u8005\u3002`,
  "Compile error in model": () => `\u7F16\u8BD1\u6A21\u578B\u65F6\u9047\u5230\u9519\u8BEF\u3002\u8BF7\u5148\u4FEE\u590D\u4EE3\u7801\u9762\u677F\u4E2D\u7684\u9519\u8BEF\uFF0C\u7136\u540E\u5C1D\u8BD5\u6267\u884C\u3002`,
  "Showing full text help of _": (Name) => `\u663E\u793A [${Name}](<observer=help ${Name} -full>) \u7684\u5E2E\u52A9\u6587\u6863\u3002`,
  "Arguments needed for execution _": (Name, Arguments) => `\u5728\u6267\u884C \`${Name}\` \u4E4B\u524D\uFF0C\u9700\u8981\u77E5\u9053\u5B83\u7684\u53C2\u6570\u3002`,
  "Please download Turtle Universe": () => `\u529F\u80FD\u5728\u7F51\u9875\u6A21\u5F0F\u4E0B\u4E0D\u53EF\u7528\u3002\u8BF7\u4E0B\u8F7D[\u6D77\u9F9F\u5B9E\u9A8C\u5BA4](https://www.turtlesim.com/products/turtle-universe/index-cn.html)\u4EE5\u83B7\u5F97\u66F4\u597D\u7684\u4F53\u9A8C\u3002`,
  "Failed to retrieve knowledge": () => `\u62B1\u6B49\uFF0C\u672A\u80FD\u627E\u5230\u76F8\u5E94\u77E5\u8BC6\u3002`,
  "Execute again": () => "**\u518D\u6B21\u6267\u884C**\u8FD9\u6BB5\u4EE3\u7801",
  // Options
  "Help me fix this code": () => `\u8BD5\u8BD5 AI \u81EA\u52A8\u4FEE\u590D\u4EE3\u7801`,
  "Explain the error": () => `\u8BA9 AI \u89E3\u91CA\u9519\u8BEF\u4FE1\u606F`,
  // Default messages
  "Command center welcome (user)": () => `\u8FD9\u662F\u54EA\u513F\uFF1F\u6211\u5E94\u8BE5\u600E\u4E48\u5F00\u59CB\u4F7F\u7528\uFF1F`,
  "Command center welcome (command)": () => `\u4F60\u597D\uFF01\u8FD9\u91CC\u662F\u63A7\u5236\u53F0\u3002\u4F60\u53EF\u4EE5\u5728\u8FD9\u91CC\u8F93\u5165 NetLogo \u547D\u4EE4\u5E76\u7ACB\u5373\u6267\u884C\u3002\u8FD8\u6709\u8BB8\u591A\u503C\u5F97\u63A2\u7D22\u7684\u529F\u80FD\uFF0C\u4F8B\u5982\uFF1A`,
  "Command center welcome (assistant)": () => `\u4F60\u597D\uFF01\u8FD9\u91CC\u662F AI \u52A9\u624B\u3002\u6211\u53EF\u4EE5\u5E2E\u52A9\u4F60\u5B66\u4E60 NetLogo \u6216\u521B\u4F5C\u4F60\u7684\u4F5C\u54C1\u3002\u8FD8\u6709\u8BB8\u591A\u503C\u5F97\u63A2\u7D22\u7684\u529F\u80FD\uFF0C\u4F8B\u5982\uFF1A`,
  "Run NetLogo code directly": () => `\u76F4\u63A5\u8FD0\u884C **NetLogo** \u4EE3\u7801`,
  "Check out the code tab": () => `\u67E5\u770B\u4F5C\u54C1\u7684**\u4EE3\u7801**`,
  "Talk to the computer in natural languages": () => `\u7528**\u81EA\u7136\u8BED\u8A00**\u5199\u4EE3\u7801`,
  "Look for the documentation": () => `\u67E5\u770B NetLogo \u8BED\u8A00\u7684**\u5E2E\u52A9\u6587\u6863**`,
  "Ask questions about NetLogo": () => `\u8BE2\u95EE\u5173\u4E8E NetLogo \u7684**\u95EE\u9898**`,
  // Color picker messages
  Grid: () => `\u7F51\u683C`,
  Wheel: () => `\u8272\u8F6E`,
  Slider: () => `\u6ED1\u5757`,
  Red: () => `R`,
  Blue: () => `B`,
  Green: () => `G`,
  Alpha: () => `A`,
  Hue: () => `H \u8272\u76F8`,
  Saturation: () => `S \u9971\u548C\u5EA6`,
  Luminance: () => `L \u4EAE\u5EA6`,
  "Color Parameters": () => `\u989C\u8272\u503C`,
  "Color Swatches": () => `NetLogo \u8272\u677F`,
  "Foreground Color": () => `\u7F16\u8F91\u524D\u666F\u989C\u8272`,
  "Background Color": () => `\u7F16\u8F91\u80CC\u666F\u989C\u8272`,
  Increment: () => `\u589E\u91CF`,
  Numbers: () => `\u6570\u5B57`
};

// src/i18n/localized.ts
var LocalizationManager = class {
  constructor() {
    this.Current = en_us;
  }
  /** Get: Get a localized key. */
  Get(Key, ...Args) {
    var Bundle = this.Current;
    if (!Bundle.hasOwnProperty(Key)) Bundle = en_us;
    if (!Bundle.hasOwnProperty(Key)) return Key;
    try {
      return Bundle[Key].apply(this, Args);
    } catch {
      return `Error in producing message: ${Key}`;
    }
  }
  /** Switch: Switch to another language. */
  Switch(Locale) {
    switch (Locale.toLowerCase()) {
      case "zh_cn":
      case "chinese":
        this.Current = zh_cn;
        break;
      default:
        this.Current = en_us;
        break;
    }
  }
};

// src/i18n/dictionary.ts
var DictionaryManager = class {
  constructor() {
    /** Data: Data of the dictionary. */
    this.Data = {};
  }
  // Initialize: Initialize the manager with given data.
  Initialize(Data) {
    this.Data = Data;
    this.RegisterBuiltin("~VariableName");
    this.RegisterBuiltin("~ProcedureName");
    this.RegisterBuiltin("~Arguments");
    this.RegisterBuiltin("~PatchVar");
    this.RegisterBuiltin("~TurtleVar");
    this.RegisterBuiltin("~LinkVar");
    this.RegisterBuiltin("~Reporter");
    this.RegisterBuiltin("~Command");
    this.RegisterBuiltin("~Constant");
    this.RegisterBuiltin("~Extension");
    this.RegisterBuiltin("~Numeric");
    this.RegisterBuiltin("~String");
    this.RegisterBuiltin("~LineComment");
    this.RegisterBuiltin("~Globals/Identifier");
    this.RegisterBuiltin("~BreedVars/Identifier");
    this.RegisterBuiltin("~BreedPlural");
    this.RegisterBuiltin("~BreedSingular");
    this.RegisterBuiltin("~BreedVariable");
    this.RegisterBuiltin("~BreedReporter");
    this.RegisterBuiltin("~BreedCommand");
    this.RegisterBuiltin("~WidgetGlobal");
    this.RegisterBuiltin("~CustomCommand");
    this.RegisterBuiltin("~CustomReporter");
    this.RegisterBuiltin("~LocalVariable");
  }
  // RegisterInternal: Register some built-in explanations.
  RegisterBuiltin(...Args) {
    Args.map((Arg) => this.Data[Arg.toLowerCase()] = Localized.Get(Args[0], "{0}"));
  }
  // Get: Get an explanation from the dictionary.
  Get(Key, Value) {
    if (Dictionary.Check(Key)) return Dictionary.Data[Key.trim().toLowerCase()].replace("{0}", Value);
    return Key;
  }
  // Check: Check if a key exists in the dictionary.
  Check(Key) {
    return this.Data && this.Data.hasOwnProperty(Key.trim().toLowerCase());
  }
};
var Dictionary = new DictionaryManager();
try {
  window.EditorDictionary = Dictionary;
} catch (error) {
}

// src/editor-config.ts
var EditorLanguage = /* @__PURE__ */ ((EditorLanguage2) => {
  EditorLanguage2[EditorLanguage2["NetLogo"] = 0] = "NetLogo";
  EditorLanguage2[EditorLanguage2["Javascript"] = 1] = "Javascript";
  EditorLanguage2[EditorLanguage2["HTML"] = 2] = "HTML";
  EditorLanguage2[EditorLanguage2["CSS"] = 3] = "CSS";
  return EditorLanguage2;
})(EditorLanguage || {});
try {
  window.EditorLanguage = EditorLanguage;
} catch (error) {
}

// node_modules/@lezer/common/dist/index.js
var DefaultBufferLength = 1024;
var nextPropID = 0;
var NodeProp = class {
  /**
  Create a new node prop type.
  */
  constructor(config2 = {}) {
    this.id = nextPropID++;
    this.perNode = !!config2.perNode;
    this.deserialize = config2.deserialize || (() => {
      throw new Error("This node type doesn't define a deserialize function");
    });
  }
  /**
  This is meant to be used with
  [`NodeSet.extend`](#common.NodeSet.extend) or
  [`LRParser.configure`](#lr.ParserConfig.props) to compute
  prop values for each node type in the set. Takes a [match
  object](#common.NodeType^match) or function that returns undefined
  if the node type doesn't get this prop, and the prop's value if
  it does.
  */
  add(match) {
    if (this.perNode)
      throw new RangeError("Can't add per-node props to node types");
    if (typeof match != "function")
      match = NodeType.match(match);
    return (type) => {
      let result = match(type);
      return result === void 0 ? null : [this, result];
    };
  }
};
NodeProp.closedBy = new NodeProp({ deserialize: (str) => str.split(" ") });
NodeProp.openedBy = new NodeProp({ deserialize: (str) => str.split(" ") });
NodeProp.group = new NodeProp({ deserialize: (str) => str.split(" ") });
NodeProp.isolate = new NodeProp({ deserialize: (value) => {
  if (value && value != "rtl" && value != "ltr" && value != "auto")
    throw new RangeError("Invalid value for isolate: " + value);
  return value || "auto";
} });
NodeProp.contextHash = new NodeProp({ perNode: true });
NodeProp.lookAhead = new NodeProp({ perNode: true });
NodeProp.mounted = new NodeProp({ perNode: true });
var MountedTree = class {
  constructor(tree, overlay, parser2) {
    this.tree = tree;
    this.overlay = overlay;
    this.parser = parser2;
  }
  /**
  @internal
  */
  static get(tree) {
    return tree && tree.props && tree.props[NodeProp.mounted.id];
  }
};
var noProps = /* @__PURE__ */ Object.create(null);
var NodeType = class _NodeType {
  /**
  @internal
  */
  constructor(name2, props, id, flags = 0) {
    this.name = name2;
    this.props = props;
    this.id = id;
    this.flags = flags;
  }
  /**
  Define a node type.
  */
  static define(spec) {
    let props = spec.props && spec.props.length ? /* @__PURE__ */ Object.create(null) : noProps;
    let flags = (spec.top ? 1 : 0) | (spec.skipped ? 2 : 0) | (spec.error ? 4 : 0) | (spec.name == null ? 8 : 0);
    let type = new _NodeType(spec.name || "", props, spec.id, flags);
    if (spec.props)
      for (let src of spec.props) {
        if (!Array.isArray(src))
          src = src(type);
        if (src) {
          if (src[0].perNode)
            throw new RangeError("Can't store a per-node prop on a node type");
          props[src[0].id] = src[1];
        }
      }
    return type;
  }
  /**
  Retrieves a node prop for this type. Will return `undefined` if
  the prop isn't present on this node.
  */
  prop(prop) {
    return this.props[prop.id];
  }
  /**
  True when this is the top node of a grammar.
  */
  get isTop() {
    return (this.flags & 1) > 0;
  }
  /**
  True when this node is produced by a skip rule.
  */
  get isSkipped() {
    return (this.flags & 2) > 0;
  }
  /**
  Indicates whether this is an error node.
  */
  get isError() {
    return (this.flags & 4) > 0;
  }
  /**
  When true, this node type doesn't correspond to a user-declared
  named node, for example because it is used to cache repetition.
  */
  get isAnonymous() {
    return (this.flags & 8) > 0;
  }
  /**
  Returns true when this node's name or one of its
  [groups](#common.NodeProp^group) matches the given string.
  */
  is(name2) {
    if (typeof name2 == "string") {
      if (this.name == name2)
        return true;
      let group = this.prop(NodeProp.group);
      return group ? group.indexOf(name2) > -1 : false;
    }
    return this.id == name2;
  }
  /**
  Create a function from node types to arbitrary values by
  specifying an object whose property names are node or
  [group](#common.NodeProp^group) names. Often useful with
  [`NodeProp.add`](#common.NodeProp.add). You can put multiple
  names, separated by spaces, in a single property name to map
  multiple node names to a single value.
  */
  static match(map) {
    let direct = /* @__PURE__ */ Object.create(null);
    for (let prop in map)
      for (let name2 of prop.split(" "))
        direct[name2] = map[prop];
    return (node) => {
      for (let groups = node.prop(NodeProp.group), i = -1; i < (groups ? groups.length : 0); i++) {
        let found = direct[i < 0 ? node.name : groups[i]];
        if (found)
          return found;
      }
    };
  }
};
NodeType.none = new NodeType(
  "",
  /* @__PURE__ */ Object.create(null),
  0,
  8
  /* NodeFlag.Anonymous */
);
var CachedNode = /* @__PURE__ */ new WeakMap();
var CachedInnerNode = /* @__PURE__ */ new WeakMap();
var IterMode;
(function(IterMode2) {
  IterMode2[IterMode2["ExcludeBuffers"] = 1] = "ExcludeBuffers";
  IterMode2[IterMode2["IncludeAnonymous"] = 2] = "IncludeAnonymous";
  IterMode2[IterMode2["IgnoreMounts"] = 4] = "IgnoreMounts";
  IterMode2[IterMode2["IgnoreOverlays"] = 8] = "IgnoreOverlays";
})(IterMode || (IterMode = {}));
var Tree = class _Tree {
  /**
  Construct a new tree. See also [`Tree.build`](#common.Tree^build).
  */
  constructor(type, children, positions, length, props) {
    this.type = type;
    this.children = children;
    this.positions = positions;
    this.length = length;
    this.props = null;
    if (props && props.length) {
      this.props = /* @__PURE__ */ Object.create(null);
      for (let [prop, value] of props)
        this.props[typeof prop == "number" ? prop : prop.id] = value;
    }
  }
  /**
  @internal
  */
  toString() {
    let mounted = MountedTree.get(this);
    if (mounted && !mounted.overlay)
      return mounted.tree.toString();
    let children = "";
    for (let ch of this.children) {
      let str = ch.toString();
      if (str) {
        if (children)
          children += ",";
        children += str;
      }
    }
    return !this.type.name ? children : (/\W/.test(this.type.name) && !this.type.isError ? JSON.stringify(this.type.name) : this.type.name) + (children.length ? "(" + children + ")" : "");
  }
  /**
  Get a [tree cursor](#common.TreeCursor) positioned at the top of
  the tree. Mode can be used to [control](#common.IterMode) which
  nodes the cursor visits.
  */
  cursor(mode = 0) {
    return new TreeCursor(this.topNode, mode);
  }
  /**
  Get a [tree cursor](#common.TreeCursor) pointing into this tree
  at the given position and side (see
  [`moveTo`](#common.TreeCursor.moveTo).
  */
  cursorAt(pos, side = 0, mode = 0) {
    let scope = CachedNode.get(this) || this.topNode;
    let cursor = new TreeCursor(scope);
    cursor.moveTo(pos, side);
    CachedNode.set(this, cursor._tree);
    return cursor;
  }
  /**
  Get a [syntax node](#common.SyntaxNode) object for the top of the
  tree.
  */
  get topNode() {
    return new TreeNode(this, 0, 0, null);
  }
  /**
  Get the [syntax node](#common.SyntaxNode) at the given position.
  If `side` is -1, this will move into nodes that end at the
  position. If 1, it'll move into nodes that start at the
  position. With 0, it'll only enter nodes that cover the position
  from both sides.
  
  Note that this will not enter
  [overlays](#common.MountedTree.overlay), and you often want
  [`resolveInner`](#common.Tree.resolveInner) instead.
  */
  resolve(pos, side = 0) {
    let node = resolveNode(CachedNode.get(this) || this.topNode, pos, side, false);
    CachedNode.set(this, node);
    return node;
  }
  /**
  Like [`resolve`](#common.Tree.resolve), but will enter
  [overlaid](#common.MountedTree.overlay) nodes, producing a syntax node
  pointing into the innermost overlaid tree at the given position
  (with parent links going through all parent structure, including
  the host trees).
  */
  resolveInner(pos, side = 0) {
    let node = resolveNode(CachedInnerNode.get(this) || this.topNode, pos, side, true);
    CachedInnerNode.set(this, node);
    return node;
  }
  /**
  In some situations, it can be useful to iterate through all
  nodes around a position, including those in overlays that don't
  directly cover the position. This method gives you an iterator
  that will produce all nodes, from small to big, around the given
  position.
  */
  resolveStack(pos, side = 0) {
    return stackIterator(this, pos, side);
  }
  /**
  Iterate over the tree and its children, calling `enter` for any
  node that touches the `from`/`to` region (if given) before
  running over such a node's children, and `leave` (if given) when
  leaving the node. When `enter` returns `false`, that node will
  not have its children iterated over (or `leave` called).
  */
  iterate(spec) {
    let { enter, leave, from = 0, to = this.length } = spec;
    let mode = spec.mode || 0, anon = (mode & IterMode.IncludeAnonymous) > 0;
    for (let c = this.cursor(mode | IterMode.IncludeAnonymous); ; ) {
      let entered = false;
      if (c.from <= to && c.to >= from && (!anon && c.type.isAnonymous || enter(c) !== false)) {
        if (c.firstChild())
          continue;
        entered = true;
      }
      for (; ; ) {
        if (entered && leave && (anon || !c.type.isAnonymous))
          leave(c);
        if (c.nextSibling())
          break;
        if (!c.parent())
          return;
        entered = true;
      }
    }
  }
  /**
  Get the value of the given [node prop](#common.NodeProp) for this
  node. Works with both per-node and per-type props.
  */
  prop(prop) {
    return !prop.perNode ? this.type.prop(prop) : this.props ? this.props[prop.id] : void 0;
  }
  /**
  Returns the node's [per-node props](#common.NodeProp.perNode) in a
  format that can be passed to the [`Tree`](#common.Tree)
  constructor.
  */
  get propValues() {
    let result = [];
    if (this.props)
      for (let id in this.props)
        result.push([+id, this.props[id]]);
    return result;
  }
  /**
  Balance the direct children of this tree, producing a copy of
  which may have children grouped into subtrees with type
  [`NodeType.none`](#common.NodeType^none).
  */
  balance(config2 = {}) {
    return this.children.length <= 8 ? this : balanceRange(NodeType.none, this.children, this.positions, 0, this.children.length, 0, this.length, (children, positions, length) => new _Tree(this.type, children, positions, length, this.propValues), config2.makeTree || ((children, positions, length) => new _Tree(NodeType.none, children, positions, length)));
  }
  /**
  Build a tree from a postfix-ordered buffer of node information,
  or a cursor over such a buffer.
  */
  static build(data) {
    return buildTree(data);
  }
};
Tree.empty = new Tree(NodeType.none, [], [], 0);
var FlatBufferCursor = class _FlatBufferCursor {
  constructor(buffer, index) {
    this.buffer = buffer;
    this.index = index;
  }
  get id() {
    return this.buffer[this.index - 4];
  }
  get start() {
    return this.buffer[this.index - 3];
  }
  get end() {
    return this.buffer[this.index - 2];
  }
  get size() {
    return this.buffer[this.index - 1];
  }
  get pos() {
    return this.index;
  }
  next() {
    this.index -= 4;
  }
  fork() {
    return new _FlatBufferCursor(this.buffer, this.index);
  }
};
var TreeBuffer = class _TreeBuffer {
  /**
  Create a tree buffer.
  */
  constructor(buffer, length, set) {
    this.buffer = buffer;
    this.length = length;
    this.set = set;
  }
  /**
  @internal
  */
  get type() {
    return NodeType.none;
  }
  /**
  @internal
  */
  toString() {
    let result = [];
    for (let index = 0; index < this.buffer.length; ) {
      result.push(this.childString(index));
      index = this.buffer[index + 3];
    }
    return result.join(",");
  }
  /**
  @internal
  */
  childString(index) {
    let id = this.buffer[index], endIndex = this.buffer[index + 3];
    let type = this.set.types[id], result = type.name;
    if (/\W/.test(result) && !type.isError)
      result = JSON.stringify(result);
    index += 4;
    if (endIndex == index)
      return result;
    let children = [];
    while (index < endIndex) {
      children.push(this.childString(index));
      index = this.buffer[index + 3];
    }
    return result + "(" + children.join(",") + ")";
  }
  /**
  @internal
  */
  findChild(startIndex, endIndex, dir, pos, side) {
    let { buffer } = this, pick = -1;
    for (let i = startIndex; i != endIndex; i = buffer[i + 3]) {
      if (checkSide(side, pos, buffer[i + 1], buffer[i + 2])) {
        pick = i;
        if (dir > 0)
          break;
      }
    }
    return pick;
  }
  /**
  @internal
  */
  slice(startI, endI, from) {
    let b = this.buffer;
    let copy = new Uint16Array(endI - startI), len = 0;
    for (let i = startI, j = 0; i < endI; ) {
      copy[j++] = b[i++];
      copy[j++] = b[i++] - from;
      let to = copy[j++] = b[i++] - from;
      copy[j++] = b[i++] - startI;
      len = Math.max(len, to);
    }
    return new _TreeBuffer(copy, len, this.set);
  }
};
function checkSide(side, pos, from, to) {
  switch (side) {
    case -2:
      return from < pos;
    case -1:
      return to >= pos && from < pos;
    case 0:
      return from < pos && to > pos;
    case 1:
      return from <= pos && to > pos;
    case 2:
      return to > pos;
    case 4:
      return true;
  }
}
function resolveNode(node, pos, side, overlays) {
  var _a;
  while (node.from == node.to || (side < 1 ? node.from >= pos : node.from > pos) || (side > -1 ? node.to <= pos : node.to < pos)) {
    let parent = !overlays && node instanceof TreeNode && node.index < 0 ? null : node.parent;
    if (!parent)
      return node;
    node = parent;
  }
  let mode = overlays ? 0 : IterMode.IgnoreOverlays;
  if (overlays)
    for (let scan = node, parent = scan.parent; parent; scan = parent, parent = scan.parent) {
      if (scan instanceof TreeNode && scan.index < 0 && ((_a = parent.enter(pos, side, mode)) === null || _a === void 0 ? void 0 : _a.from) != scan.from)
        node = parent;
    }
  for (; ; ) {
    let inner = node.enter(pos, side, mode);
    if (!inner)
      return node;
    node = inner;
  }
}
var BaseNode = class {
  cursor(mode = 0) {
    return new TreeCursor(this, mode);
  }
  getChild(type, before = null, after = null) {
    let r = getChildren(this, type, before, after);
    return r.length ? r[0] : null;
  }
  getChildren(type, before = null, after = null) {
    return getChildren(this, type, before, after);
  }
  resolve(pos, side = 0) {
    return resolveNode(this, pos, side, false);
  }
  resolveInner(pos, side = 0) {
    return resolveNode(this, pos, side, true);
  }
  matchContext(context) {
    return matchNodeContext(this.parent, context);
  }
  enterUnfinishedNodesBefore(pos) {
    let scan = this.childBefore(pos), node = this;
    while (scan) {
      let last = scan.lastChild;
      if (!last || last.to != scan.to)
        break;
      if (last.type.isError && last.from == last.to) {
        node = scan;
        scan = last.prevSibling;
      } else {
        scan = last;
      }
    }
    return node;
  }
  get node() {
    return this;
  }
  get next() {
    return this.parent;
  }
};
var TreeNode = class _TreeNode extends BaseNode {
  constructor(_tree, from, index, _parent) {
    super();
    this._tree = _tree;
    this.from = from;
    this.index = index;
    this._parent = _parent;
  }
  get type() {
    return this._tree.type;
  }
  get name() {
    return this._tree.type.name;
  }
  get to() {
    return this.from + this._tree.length;
  }
  nextChild(i, dir, pos, side, mode = 0) {
    for (let parent = this; ; ) {
      for (let { children, positions } = parent._tree, e = dir > 0 ? children.length : -1; i != e; i += dir) {
        let next = children[i], start = positions[i] + parent.from;
        if (!checkSide(side, pos, start, start + next.length))
          continue;
        if (next instanceof TreeBuffer) {
          if (mode & IterMode.ExcludeBuffers)
            continue;
          let index = next.findChild(0, next.buffer.length, dir, pos - start, side);
          if (index > -1)
            return new BufferNode(new BufferContext(parent, next, i, start), null, index);
        } else if (mode & IterMode.IncludeAnonymous || (!next.type.isAnonymous || hasChild(next))) {
          let mounted;
          if (!(mode & IterMode.IgnoreMounts) && (mounted = MountedTree.get(next)) && !mounted.overlay)
            return new _TreeNode(mounted.tree, start, i, parent);
          let inner = new _TreeNode(next, start, i, parent);
          return mode & IterMode.IncludeAnonymous || !inner.type.isAnonymous ? inner : inner.nextChild(dir < 0 ? next.children.length - 1 : 0, dir, pos, side);
        }
      }
      if (mode & IterMode.IncludeAnonymous || !parent.type.isAnonymous)
        return null;
      if (parent.index >= 0)
        i = parent.index + dir;
      else
        i = dir < 0 ? -1 : parent._parent._tree.children.length;
      parent = parent._parent;
      if (!parent)
        return null;
    }
  }
  get firstChild() {
    return this.nextChild(
      0,
      1,
      0,
      4
      /* Side.DontCare */
    );
  }
  get lastChild() {
    return this.nextChild(
      this._tree.children.length - 1,
      -1,
      0,
      4
      /* Side.DontCare */
    );
  }
  childAfter(pos) {
    return this.nextChild(
      0,
      1,
      pos,
      2
      /* Side.After */
    );
  }
  childBefore(pos) {
    return this.nextChild(
      this._tree.children.length - 1,
      -1,
      pos,
      -2
      /* Side.Before */
    );
  }
  enter(pos, side, mode = 0) {
    let mounted;
    if (!(mode & IterMode.IgnoreOverlays) && (mounted = MountedTree.get(this._tree)) && mounted.overlay) {
      let rPos = pos - this.from;
      for (let { from, to } of mounted.overlay) {
        if ((side > 0 ? from <= rPos : from < rPos) && (side < 0 ? to >= rPos : to > rPos))
          return new _TreeNode(mounted.tree, mounted.overlay[0].from + this.from, -1, this);
      }
    }
    return this.nextChild(0, 1, pos, side, mode);
  }
  nextSignificantParent() {
    let val = this;
    while (val.type.isAnonymous && val._parent)
      val = val._parent;
    return val;
  }
  get parent() {
    return this._parent ? this._parent.nextSignificantParent() : null;
  }
  get nextSibling() {
    return this._parent && this.index >= 0 ? this._parent.nextChild(
      this.index + 1,
      1,
      0,
      4
      /* Side.DontCare */
    ) : null;
  }
  get prevSibling() {
    return this._parent && this.index >= 0 ? this._parent.nextChild(
      this.index - 1,
      -1,
      0,
      4
      /* Side.DontCare */
    ) : null;
  }
  get tree() {
    return this._tree;
  }
  toTree() {
    return this._tree;
  }
  /**
  @internal
  */
  toString() {
    return this._tree.toString();
  }
};
function getChildren(node, type, before, after) {
  let cur2 = node.cursor(), result = [];
  if (!cur2.firstChild())
    return result;
  if (before != null)
    for (let found = false; !found; ) {
      found = cur2.type.is(before);
      if (!cur2.nextSibling())
        return result;
    }
  for (; ; ) {
    if (after != null && cur2.type.is(after))
      return result;
    if (cur2.type.is(type))
      result.push(cur2.node);
    if (!cur2.nextSibling())
      return after == null ? result : [];
  }
}
function matchNodeContext(node, context, i = context.length - 1) {
  for (let p = node; i >= 0; p = p.parent) {
    if (!p)
      return false;
    if (!p.type.isAnonymous) {
      if (context[i] && context[i] != p.name)
        return false;
      i--;
    }
  }
  return true;
}
var BufferContext = class {
  constructor(parent, buffer, index, start) {
    this.parent = parent;
    this.buffer = buffer;
    this.index = index;
    this.start = start;
  }
};
var BufferNode = class _BufferNode extends BaseNode {
  get name() {
    return this.type.name;
  }
  get from() {
    return this.context.start + this.context.buffer.buffer[this.index + 1];
  }
  get to() {
    return this.context.start + this.context.buffer.buffer[this.index + 2];
  }
  constructor(context, _parent, index) {
    super();
    this.context = context;
    this._parent = _parent;
    this.index = index;
    this.type = context.buffer.set.types[context.buffer.buffer[index]];
  }
  child(dir, pos, side) {
    let { buffer } = this.context;
    let index = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], dir, pos - this.context.start, side);
    return index < 0 ? null : new _BufferNode(this.context, this, index);
  }
  get firstChild() {
    return this.child(
      1,
      0,
      4
      /* Side.DontCare */
    );
  }
  get lastChild() {
    return this.child(
      -1,
      0,
      4
      /* Side.DontCare */
    );
  }
  childAfter(pos) {
    return this.child(
      1,
      pos,
      2
      /* Side.After */
    );
  }
  childBefore(pos) {
    return this.child(
      -1,
      pos,
      -2
      /* Side.Before */
    );
  }
  enter(pos, side, mode = 0) {
    if (mode & IterMode.ExcludeBuffers)
      return null;
    let { buffer } = this.context;
    let index = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], side > 0 ? 1 : -1, pos - this.context.start, side);
    return index < 0 ? null : new _BufferNode(this.context, this, index);
  }
  get parent() {
    return this._parent || this.context.parent.nextSignificantParent();
  }
  externalSibling(dir) {
    return this._parent ? null : this.context.parent.nextChild(
      this.context.index + dir,
      dir,
      0,
      4
      /* Side.DontCare */
    );
  }
  get nextSibling() {
    let { buffer } = this.context;
    let after = buffer.buffer[this.index + 3];
    if (after < (this._parent ? buffer.buffer[this._parent.index + 3] : buffer.buffer.length))
      return new _BufferNode(this.context, this._parent, after);
    return this.externalSibling(1);
  }
  get prevSibling() {
    let { buffer } = this.context;
    let parentStart = this._parent ? this._parent.index + 4 : 0;
    if (this.index == parentStart)
      return this.externalSibling(-1);
    return new _BufferNode(this.context, this._parent, buffer.findChild(
      parentStart,
      this.index,
      -1,
      0,
      4
      /* Side.DontCare */
    ));
  }
  get tree() {
    return null;
  }
  toTree() {
    let children = [], positions = [];
    let { buffer } = this.context;
    let startI = this.index + 4, endI = buffer.buffer[this.index + 3];
    if (endI > startI) {
      let from = buffer.buffer[this.index + 1];
      children.push(buffer.slice(startI, endI, from));
      positions.push(0);
    }
    return new Tree(this.type, children, positions, this.to - this.from);
  }
  /**
  @internal
  */
  toString() {
    return this.context.buffer.childString(this.index);
  }
};
function iterStack(heads) {
  if (!heads.length)
    return null;
  let pick = 0, picked = heads[0];
  for (let i = 1; i < heads.length; i++) {
    let node = heads[i];
    if (node.from > picked.from || node.to < picked.to) {
      picked = node;
      pick = i;
    }
  }
  let next = picked instanceof TreeNode && picked.index < 0 ? null : picked.parent;
  let newHeads = heads.slice();
  if (next)
    newHeads[pick] = next;
  else
    newHeads.splice(pick, 1);
  return new StackIterator(newHeads, picked);
}
var StackIterator = class {
  constructor(heads, node) {
    this.heads = heads;
    this.node = node;
  }
  get next() {
    return iterStack(this.heads);
  }
};
function stackIterator(tree, pos, side) {
  let inner = tree.resolveInner(pos, side), layers = null;
  for (let scan = inner instanceof TreeNode ? inner : inner.context.parent; scan; scan = scan.parent) {
    if (scan.index < 0) {
      let parent = scan.parent;
      (layers || (layers = [inner])).push(parent.resolve(pos, side));
      scan = parent;
    } else {
      let mount = MountedTree.get(scan.tree);
      if (mount && mount.overlay && mount.overlay[0].from <= pos && mount.overlay[mount.overlay.length - 1].to >= pos) {
        let root = new TreeNode(mount.tree, mount.overlay[0].from + scan.from, -1, scan);
        (layers || (layers = [inner])).push(resolveNode(root, pos, side, false));
      }
    }
  }
  return layers ? iterStack(layers) : inner;
}
var TreeCursor = class {
  /**
  Shorthand for `.type.name`.
  */
  get name() {
    return this.type.name;
  }
  /**
  @internal
  */
  constructor(node, mode = 0) {
    this.mode = mode;
    this.buffer = null;
    this.stack = [];
    this.index = 0;
    this.bufferNode = null;
    if (node instanceof TreeNode) {
      this.yieldNode(node);
    } else {
      this._tree = node.context.parent;
      this.buffer = node.context;
      for (let n = node._parent; n; n = n._parent)
        this.stack.unshift(n.index);
      this.bufferNode = node;
      this.yieldBuf(node.index);
    }
  }
  yieldNode(node) {
    if (!node)
      return false;
    this._tree = node;
    this.type = node.type;
    this.from = node.from;
    this.to = node.to;
    return true;
  }
  yieldBuf(index, type) {
    this.index = index;
    let { start, buffer } = this.buffer;
    this.type = type || buffer.set.types[buffer.buffer[index]];
    this.from = start + buffer.buffer[index + 1];
    this.to = start + buffer.buffer[index + 2];
    return true;
  }
  /**
  @internal
  */
  yield(node) {
    if (!node)
      return false;
    if (node instanceof TreeNode) {
      this.buffer = null;
      return this.yieldNode(node);
    }
    this.buffer = node.context;
    return this.yieldBuf(node.index, node.type);
  }
  /**
  @internal
  */
  toString() {
    return this.buffer ? this.buffer.buffer.childString(this.index) : this._tree.toString();
  }
  /**
  @internal
  */
  enterChild(dir, pos, side) {
    if (!this.buffer)
      return this.yield(this._tree.nextChild(dir < 0 ? this._tree._tree.children.length - 1 : 0, dir, pos, side, this.mode));
    let { buffer } = this.buffer;
    let index = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], dir, pos - this.buffer.start, side);
    if (index < 0)
      return false;
    this.stack.push(this.index);
    return this.yieldBuf(index);
  }
  /**
  Move the cursor to this node's first child. When this returns
  false, the node has no child, and the cursor has not been moved.
  */
  firstChild() {
    return this.enterChild(
      1,
      0,
      4
      /* Side.DontCare */
    );
  }
  /**
  Move the cursor to this node's last child.
  */
  lastChild() {
    return this.enterChild(
      -1,
      0,
      4
      /* Side.DontCare */
    );
  }
  /**
  Move the cursor to the first child that ends after `pos`.
  */
  childAfter(pos) {
    return this.enterChild(
      1,
      pos,
      2
      /* Side.After */
    );
  }
  /**
  Move to the last child that starts before `pos`.
  */
  childBefore(pos) {
    return this.enterChild(
      -1,
      pos,
      -2
      /* Side.Before */
    );
  }
  /**
  Move the cursor to the child around `pos`. If side is -1 the
  child may end at that position, when 1 it may start there. This
  will also enter [overlaid](#common.MountedTree.overlay)
  [mounted](#common.NodeProp^mounted) trees unless `overlays` is
  set to false.
  */
  enter(pos, side, mode = this.mode) {
    if (!this.buffer)
      return this.yield(this._tree.enter(pos, side, mode));
    return mode & IterMode.ExcludeBuffers ? false : this.enterChild(1, pos, side);
  }
  /**
  Move to the node's parent node, if this isn't the top node.
  */
  parent() {
    if (!this.buffer)
      return this.yieldNode(this.mode & IterMode.IncludeAnonymous ? this._tree._parent : this._tree.parent);
    if (this.stack.length)
      return this.yieldBuf(this.stack.pop());
    let parent = this.mode & IterMode.IncludeAnonymous ? this.buffer.parent : this.buffer.parent.nextSignificantParent();
    this.buffer = null;
    return this.yieldNode(parent);
  }
  /**
  @internal
  */
  sibling(dir) {
    if (!this.buffer)
      return !this._tree._parent ? false : this.yield(this._tree.index < 0 ? null : this._tree._parent.nextChild(this._tree.index + dir, dir, 0, 4, this.mode));
    let { buffer } = this.buffer, d = this.stack.length - 1;
    if (dir < 0) {
      let parentStart = d < 0 ? 0 : this.stack[d] + 4;
      if (this.index != parentStart)
        return this.yieldBuf(buffer.findChild(
          parentStart,
          this.index,
          -1,
          0,
          4
          /* Side.DontCare */
        ));
    } else {
      let after = buffer.buffer[this.index + 3];
      if (after < (d < 0 ? buffer.buffer.length : buffer.buffer[this.stack[d] + 3]))
        return this.yieldBuf(after);
    }
    return d < 0 ? this.yield(this.buffer.parent.nextChild(this.buffer.index + dir, dir, 0, 4, this.mode)) : false;
  }
  /**
  Move to this node's next sibling, if any.
  */
  nextSibling() {
    return this.sibling(1);
  }
  /**
  Move to this node's previous sibling, if any.
  */
  prevSibling() {
    return this.sibling(-1);
  }
  atLastNode(dir) {
    let index, parent, { buffer } = this;
    if (buffer) {
      if (dir > 0) {
        if (this.index < buffer.buffer.buffer.length)
          return false;
      } else {
        for (let i = 0; i < this.index; i++)
          if (buffer.buffer.buffer[i + 3] < this.index)
            return false;
      }
      ({ index, parent } = buffer);
    } else {
      ({ index, _parent: parent } = this._tree);
    }
    for (; parent; { index, _parent: parent } = parent) {
      if (index > -1)
        for (let i = index + dir, e = dir < 0 ? -1 : parent._tree.children.length; i != e; i += dir) {
          let child = parent._tree.children[i];
          if (this.mode & IterMode.IncludeAnonymous || child instanceof TreeBuffer || !child.type.isAnonymous || hasChild(child))
            return false;
        }
    }
    return true;
  }
  move(dir, enter) {
    if (enter && this.enterChild(
      dir,
      0,
      4
      /* Side.DontCare */
    ))
      return true;
    for (; ; ) {
      if (this.sibling(dir))
        return true;
      if (this.atLastNode(dir) || !this.parent())
        return false;
    }
  }
  /**
  Move to the next node in a
  [pre-order](https://en.wikipedia.org/wiki/Tree_traversal#Pre-order,_NLR)
  traversal, going from a node to its first child or, if the
  current node is empty or `enter` is false, its next sibling or
  the next sibling of the first parent node that has one.
  */
  next(enter = true) {
    return this.move(1, enter);
  }
  /**
  Move to the next node in a last-to-first pre-order traversal. A
  node is followed by its last child or, if it has none, its
  previous sibling or the previous sibling of the first parent
  node that has one.
  */
  prev(enter = true) {
    return this.move(-1, enter);
  }
  /**
  Move the cursor to the innermost node that covers `pos`. If
  `side` is -1, it will enter nodes that end at `pos`. If it is 1,
  it will enter nodes that start at `pos`.
  */
  moveTo(pos, side = 0) {
    while (this.from == this.to || (side < 1 ? this.from >= pos : this.from > pos) || (side > -1 ? this.to <= pos : this.to < pos))
      if (!this.parent())
        break;
    while (this.enterChild(1, pos, side)) {
    }
    return this;
  }
  /**
  Get a [syntax node](#common.SyntaxNode) at the cursor's current
  position.
  */
  get node() {
    if (!this.buffer)
      return this._tree;
    let cache = this.bufferNode, result = null, depth = 0;
    if (cache && cache.context == this.buffer) {
      scan: for (let index = this.index, d = this.stack.length; d >= 0; ) {
        for (let c = cache; c; c = c._parent)
          if (c.index == index) {
            if (index == this.index)
              return c;
            result = c;
            depth = d + 1;
            break scan;
          }
        index = this.stack[--d];
      }
    }
    for (let i = depth; i < this.stack.length; i++)
      result = new BufferNode(this.buffer, result, this.stack[i]);
    return this.bufferNode = new BufferNode(this.buffer, result, this.index);
  }
  /**
  Get the [tree](#common.Tree) that represents the current node, if
  any. Will return null when the node is in a [tree
  buffer](#common.TreeBuffer).
  */
  get tree() {
    return this.buffer ? null : this._tree._tree;
  }
  /**
  Iterate over the current node and all its descendants, calling
  `enter` when entering a node and `leave`, if given, when leaving
  one. When `enter` returns `false`, any children of that node are
  skipped, and `leave` isn't called for it.
  */
  iterate(enter, leave) {
    for (let depth = 0; ; ) {
      let mustLeave = false;
      if (this.type.isAnonymous || enter(this) !== false) {
        if (this.firstChild()) {
          depth++;
          continue;
        }
        if (!this.type.isAnonymous)
          mustLeave = true;
      }
      for (; ; ) {
        if (mustLeave && leave)
          leave(this);
        mustLeave = this.type.isAnonymous;
        if (!depth)
          return;
        if (this.nextSibling())
          break;
        this.parent();
        depth--;
        mustLeave = true;
      }
    }
  }
  /**
  Test whether the current node matches a given context—a sequence
  of direct parent node names. Empty strings in the context array
  are treated as wildcards.
  */
  matchContext(context) {
    if (!this.buffer)
      return matchNodeContext(this.node.parent, context);
    let { buffer } = this.buffer, { types } = buffer.set;
    for (let i = context.length - 1, d = this.stack.length - 1; i >= 0; d--) {
      if (d < 0)
        return matchNodeContext(this._tree, context, i);
      let type = types[buffer.buffer[this.stack[d]]];
      if (!type.isAnonymous) {
        if (context[i] && context[i] != type.name)
          return false;
        i--;
      }
    }
    return true;
  }
};
function hasChild(tree) {
  return tree.children.some((ch) => ch instanceof TreeBuffer || !ch.type.isAnonymous || hasChild(ch));
}
function buildTree(data) {
  var _a;
  let { buffer, nodeSet, maxBufferLength = DefaultBufferLength, reused = [], minRepeatType = nodeSet.types.length } = data;
  let cursor = Array.isArray(buffer) ? new FlatBufferCursor(buffer, buffer.length) : buffer;
  let types = nodeSet.types;
  let contextHash = 0, lookAhead = 0;
  function takeNode(parentStart, minPos, children2, positions2, inRepeat, depth) {
    let { id, start, end, size } = cursor;
    let lookAheadAtStart = lookAhead, contextAtStart = contextHash;
    while (size < 0) {
      cursor.next();
      if (size == -1) {
        let node2 = reused[id];
        children2.push(node2);
        positions2.push(start - parentStart);
        return;
      } else if (size == -3) {
        contextHash = id;
        return;
      } else if (size == -4) {
        lookAhead = id;
        return;
      } else {
        throw new RangeError(`Unrecognized record size: ${size}`);
      }
    }
    let type = types[id], node, buffer2;
    let startPos = start - parentStart;
    if (end - start <= maxBufferLength && (buffer2 = findBufferSize(cursor.pos - minPos, inRepeat))) {
      let data2 = new Uint16Array(buffer2.size - buffer2.skip);
      let endPos = cursor.pos - buffer2.size, index = data2.length;
      while (cursor.pos > endPos)
        index = copyToBuffer(buffer2.start, data2, index);
      node = new TreeBuffer(data2, end - buffer2.start, nodeSet);
      startPos = buffer2.start - parentStart;
    } else {
      let endPos = cursor.pos - size;
      cursor.next();
      let localChildren = [], localPositions = [];
      let localInRepeat = id >= minRepeatType ? id : -1;
      let lastGroup = 0, lastEnd = end;
      while (cursor.pos > endPos) {
        if (localInRepeat >= 0 && cursor.id == localInRepeat && cursor.size >= 0) {
          if (cursor.end <= lastEnd - maxBufferLength) {
            makeRepeatLeaf(localChildren, localPositions, start, lastGroup, cursor.end, lastEnd, localInRepeat, lookAheadAtStart, contextAtStart);
            lastGroup = localChildren.length;
            lastEnd = cursor.end;
          }
          cursor.next();
        } else if (depth > 2500) {
          takeFlatNode(start, endPos, localChildren, localPositions);
        } else {
          takeNode(start, endPos, localChildren, localPositions, localInRepeat, depth + 1);
        }
      }
      if (localInRepeat >= 0 && lastGroup > 0 && lastGroup < localChildren.length)
        makeRepeatLeaf(localChildren, localPositions, start, lastGroup, start, lastEnd, localInRepeat, lookAheadAtStart, contextAtStart);
      localChildren.reverse();
      localPositions.reverse();
      if (localInRepeat > -1 && lastGroup > 0) {
        let make = makeBalanced(type, contextAtStart);
        node = balanceRange(type, localChildren, localPositions, 0, localChildren.length, 0, end - start, make, make);
      } else {
        node = makeTree(type, localChildren, localPositions, end - start, lookAheadAtStart - end, contextAtStart);
      }
    }
    children2.push(node);
    positions2.push(startPos);
  }
  function takeFlatNode(parentStart, minPos, children2, positions2) {
    let nodes = [];
    let nodeCount = 0, stopAt = -1;
    while (cursor.pos > minPos) {
      let { id, start, end, size } = cursor;
      if (size > 4) {
        cursor.next();
      } else if (stopAt > -1 && start < stopAt) {
        break;
      } else {
        if (stopAt < 0)
          stopAt = end - maxBufferLength;
        nodes.push(id, start, end);
        nodeCount++;
        cursor.next();
      }
    }
    if (nodeCount) {
      let buffer2 = new Uint16Array(nodeCount * 4);
      let start = nodes[nodes.length - 2];
      for (let i = nodes.length - 3, j = 0; i >= 0; i -= 3) {
        buffer2[j++] = nodes[i];
        buffer2[j++] = nodes[i + 1] - start;
        buffer2[j++] = nodes[i + 2] - start;
        buffer2[j++] = j;
      }
      children2.push(new TreeBuffer(buffer2, nodes[2] - start, nodeSet));
      positions2.push(start - parentStart);
    }
  }
  function makeBalanced(type, contextHash2) {
    return (children2, positions2, length2) => {
      let lookAhead2 = 0, lastI = children2.length - 1, last, lookAheadProp;
      if (lastI >= 0 && (last = children2[lastI]) instanceof Tree) {
        if (!lastI && last.type == type && last.length == length2)
          return last;
        if (lookAheadProp = last.prop(NodeProp.lookAhead))
          lookAhead2 = positions2[lastI] + last.length + lookAheadProp;
      }
      return makeTree(type, children2, positions2, length2, lookAhead2, contextHash2);
    };
  }
  function makeRepeatLeaf(children2, positions2, base, i, from, to, type, lookAhead2, contextHash2) {
    let localChildren = [], localPositions = [];
    while (children2.length > i) {
      localChildren.push(children2.pop());
      localPositions.push(positions2.pop() + base - from);
    }
    children2.push(makeTree(nodeSet.types[type], localChildren, localPositions, to - from, lookAhead2 - to, contextHash2));
    positions2.push(from - base);
  }
  function makeTree(type, children2, positions2, length2, lookAhead2, contextHash2, props) {
    if (contextHash2) {
      let pair = [NodeProp.contextHash, contextHash2];
      props = props ? [pair].concat(props) : [pair];
    }
    if (lookAhead2 > 25) {
      let pair = [NodeProp.lookAhead, lookAhead2];
      props = props ? [pair].concat(props) : [pair];
    }
    return new Tree(type, children2, positions2, length2, props);
  }
  function findBufferSize(maxSize, inRepeat) {
    let fork = cursor.fork();
    let size = 0, start = 0, skip = 0, minStart = fork.end - maxBufferLength;
    let result = { size: 0, start: 0, skip: 0 };
    scan: for (let minPos = fork.pos - maxSize; fork.pos > minPos; ) {
      let nodeSize2 = fork.size;
      if (fork.id == inRepeat && nodeSize2 >= 0) {
        result.size = size;
        result.start = start;
        result.skip = skip;
        skip += 4;
        size += 4;
        fork.next();
        continue;
      }
      let startPos = fork.pos - nodeSize2;
      if (nodeSize2 < 0 || startPos < minPos || fork.start < minStart)
        break;
      let localSkipped = fork.id >= minRepeatType ? 4 : 0;
      let nodeStart2 = fork.start;
      fork.next();
      while (fork.pos > startPos) {
        if (fork.size < 0) {
          if (fork.size == -3)
            localSkipped += 4;
          else
            break scan;
        } else if (fork.id >= minRepeatType) {
          localSkipped += 4;
        }
        fork.next();
      }
      start = nodeStart2;
      size += nodeSize2;
      skip += localSkipped;
    }
    if (inRepeat < 0 || size == maxSize) {
      result.size = size;
      result.start = start;
      result.skip = skip;
    }
    return result.size > 4 ? result : void 0;
  }
  function copyToBuffer(bufferStart, buffer2, index) {
    let { id, start, end, size } = cursor;
    cursor.next();
    if (size >= 0 && id < minRepeatType) {
      let startIndex = index;
      if (size > 4) {
        let endPos = cursor.pos - (size - 4);
        while (cursor.pos > endPos)
          index = copyToBuffer(bufferStart, buffer2, index);
      }
      buffer2[--index] = startIndex;
      buffer2[--index] = end - bufferStart;
      buffer2[--index] = start - bufferStart;
      buffer2[--index] = id;
    } else if (size == -3) {
      contextHash = id;
    } else if (size == -4) {
      lookAhead = id;
    }
    return index;
  }
  let children = [], positions = [];
  while (cursor.pos > 0)
    takeNode(data.start || 0, data.bufferStart || 0, children, positions, -1, 0);
  let length = (_a = data.length) !== null && _a !== void 0 ? _a : children.length ? positions[0] + children[0].length : 0;
  return new Tree(types[data.topID], children.reverse(), positions.reverse(), length);
}
var nodeSizeCache = /* @__PURE__ */ new WeakMap();
function nodeSize(balanceType, node) {
  if (!balanceType.isAnonymous || node instanceof TreeBuffer || node.type != balanceType)
    return 1;
  let size = nodeSizeCache.get(node);
  if (size == null) {
    size = 1;
    for (let child of node.children) {
      if (child.type != balanceType || !(child instanceof Tree)) {
        size = 1;
        break;
      }
      size += nodeSize(balanceType, child);
    }
    nodeSizeCache.set(node, size);
  }
  return size;
}
function balanceRange(balanceType, children, positions, from, to, start, length, mkTop, mkTree) {
  let total = 0;
  for (let i = from; i < to; i++)
    total += nodeSize(balanceType, children[i]);
  let maxChild = Math.ceil(
    total * 1.5 / 8
    /* Balance.BranchFactor */
  );
  let localChildren = [], localPositions = [];
  function divide(children2, positions2, from2, to2, offset) {
    for (let i = from2; i < to2; ) {
      let groupFrom = i, groupStart = positions2[i], groupSize = nodeSize(balanceType, children2[i]);
      i++;
      for (; i < to2; i++) {
        let nextSize = nodeSize(balanceType, children2[i]);
        if (groupSize + nextSize >= maxChild)
          break;
        groupSize += nextSize;
      }
      if (i == groupFrom + 1) {
        if (groupSize > maxChild) {
          let only = children2[groupFrom];
          divide(only.children, only.positions, 0, only.children.length, positions2[groupFrom] + offset);
          continue;
        }
        localChildren.push(children2[groupFrom]);
      } else {
        let length2 = positions2[i - 1] + children2[i - 1].length - groupStart;
        localChildren.push(balanceRange(balanceType, children2, positions2, groupFrom, i, groupStart, length2, null, mkTree));
      }
      localPositions.push(groupStart + offset - start);
    }
  }
  divide(children, positions, from, to, 0);
  return (mkTop || mkTree)(localChildren, localPositions, length);
}
var stoppedInner = new NodeProp({ perNode: true });

// node_modules/@lezer/highlight/dist/index.js
var nextTagID = 0;
var Tag = class _Tag {
  /**
  @internal
  */
  constructor(name2, set, base, modified) {
    this.name = name2;
    this.set = set;
    this.base = base;
    this.modified = modified;
    this.id = nextTagID++;
  }
  toString() {
    let { name: name2 } = this;
    for (let mod of this.modified)
      if (mod.name)
        name2 = `${mod.name}(${name2})`;
    return name2;
  }
  static define(nameOrParent, parent) {
    let name2 = typeof nameOrParent == "string" ? nameOrParent : "?";
    if (nameOrParent instanceof _Tag)
      parent = nameOrParent;
    if (parent === null || parent === void 0 ? void 0 : parent.base)
      throw new Error("Can not derive from a modified tag");
    let tag = new _Tag(name2, [], null, []);
    tag.set.push(tag);
    if (parent)
      for (let t2 of parent.set)
        tag.set.push(t2);
    return tag;
  }
  /**
  Define a tag _modifier_, which is a function that, given a tag,
  will return a tag that is a subtag of the original. Applying the
  same modifier to a twice tag will return the same value (`m1(t1)
  == m1(t1)`) and applying multiple modifiers will, regardless or
  order, produce the same tag (`m1(m2(t1)) == m2(m1(t1))`).
  
  When multiple modifiers are applied to a given base tag, each
  smaller set of modifiers is registered as a parent, so that for
  example `m1(m2(m3(t1)))` is a subtype of `m1(m2(t1))`,
  `m1(m3(t1)`, and so on.
  */
  static defineModifier(name2) {
    let mod = new Modifier(name2);
    return (tag) => {
      if (tag.modified.indexOf(mod) > -1)
        return tag;
      return Modifier.get(tag.base || tag, tag.modified.concat(mod).sort((a, b) => a.id - b.id));
    };
  }
};
var nextModifierID = 0;
var Modifier = class _Modifier {
  constructor(name2) {
    this.name = name2;
    this.instances = [];
    this.id = nextModifierID++;
  }
  static get(base, mods) {
    if (!mods.length)
      return base;
    let exists = mods[0].instances.find((t2) => t2.base == base && sameArray2(mods, t2.modified));
    if (exists)
      return exists;
    let set = [], tag = new Tag(base.name, set, base, mods);
    for (let m of mods)
      m.instances.push(tag);
    let configs = powerSet(mods);
    for (let parent of base.set)
      if (!parent.modified.length)
        for (let config2 of configs)
          set.push(_Modifier.get(parent, config2));
    return tag;
  }
};
function sameArray2(a, b) {
  return a.length == b.length && a.every((x, i) => x == b[i]);
}
function powerSet(array) {
  let sets = [[]];
  for (let i = 0; i < array.length; i++) {
    for (let j = 0, e = sets.length; j < e; j++) {
      sets.push(sets[j].concat(array[i]));
    }
  }
  return sets.sort((a, b) => b.length - a.length);
}
function styleTags(spec) {
  let byName = /* @__PURE__ */ Object.create(null);
  for (let prop in spec) {
    let tags2 = spec[prop];
    if (!Array.isArray(tags2))
      tags2 = [tags2];
    for (let part of prop.split(" "))
      if (part) {
        let pieces = [], mode = 2, rest = part;
        for (let pos = 0; ; ) {
          if (rest == "..." && pos > 0 && pos + 3 == part.length) {
            mode = 1;
            break;
          }
          let m = /^"(?:[^"\\]|\\.)*?"|[^\/!]+/.exec(rest);
          if (!m)
            throw new RangeError("Invalid path: " + part);
          pieces.push(m[0] == "*" ? "" : m[0][0] == '"' ? JSON.parse(m[0]) : m[0]);
          pos += m[0].length;
          if (pos == part.length)
            break;
          let next = part[pos++];
          if (pos == part.length && next == "!") {
            mode = 0;
            break;
          }
          if (next != "/")
            throw new RangeError("Invalid path: " + part);
          rest = part.slice(pos);
        }
        let last = pieces.length - 1, inner = pieces[last];
        if (!inner)
          throw new RangeError("Invalid path: " + part);
        let rule = new Rule(tags2, mode, last > 0 ? pieces.slice(0, last) : null);
        byName[inner] = rule.sort(byName[inner]);
      }
  }
  return ruleNodeProp.add(byName);
}
var ruleNodeProp = new NodeProp();
var Rule = class {
  constructor(tags2, mode, context, next) {
    this.tags = tags2;
    this.mode = mode;
    this.context = context;
    this.next = next;
  }
  get opaque() {
    return this.mode == 0;
  }
  get inherit() {
    return this.mode == 1;
  }
  sort(other) {
    if (!other || other.depth < this.depth) {
      this.next = other;
      return this;
    }
    other.next = this.sort(other.next);
    return other;
  }
  get depth() {
    return this.context ? this.context.length : 0;
  }
};
Rule.empty = new Rule([], 2, null);
function tagHighlighter(tags2, options) {
  let map = /* @__PURE__ */ Object.create(null);
  for (let style of tags2) {
    if (!Array.isArray(style.tag))
      map[style.tag.id] = style.class;
    else
      for (let tag of style.tag)
        map[tag.id] = style.class;
  }
  let { scope, all = null } = options || {};
  return {
    style: (tags3) => {
      let cls = all;
      for (let tag of tags3) {
        for (let sub of tag.set) {
          let tagClass = map[sub.id];
          if (tagClass) {
            cls = cls ? cls + " " + tagClass : tagClass;
            break;
          }
        }
      }
      return cls;
    },
    scope
  };
}
function highlightTags(highlighters, tags2) {
  let result = null;
  for (let highlighter of highlighters) {
    let value = highlighter.style(tags2);
    if (value)
      result = result ? result + " " + value : value;
  }
  return result;
}
function highlightTree(tree, highlighter, putStyle, from = 0, to = tree.length) {
  let builder = new HighlightBuilder(from, Array.isArray(highlighter) ? highlighter : [highlighter], putStyle);
  builder.highlightRange(tree.cursor(), from, to, "", builder.highlighters);
  builder.flush(to);
}
var HighlightBuilder = class {
  constructor(at, highlighters, span) {
    this.at = at;
    this.highlighters = highlighters;
    this.span = span;
    this.class = "";
  }
  startSpan(at, cls) {
    if (cls != this.class) {
      this.flush(at);
      if (at > this.at)
        this.at = at;
      this.class = cls;
    }
  }
  flush(to) {
    if (to > this.at && this.class)
      this.span(this.at, to, this.class);
  }
  highlightRange(cursor, from, to, inheritedClass, highlighters) {
    let { type, from: start, to: end } = cursor;
    if (start >= to || end <= from)
      return;
    if (type.isTop)
      highlighters = this.highlighters.filter((h) => !h.scope || h.scope(type));
    let cls = inheritedClass;
    let rule = getStyleTags(cursor) || Rule.empty;
    let tagCls = highlightTags(highlighters, rule.tags);
    if (tagCls) {
      if (cls)
        cls += " ";
      cls += tagCls;
      if (rule.mode == 1)
        inheritedClass += (inheritedClass ? " " : "") + tagCls;
    }
    this.startSpan(Math.max(from, start), cls);
    if (rule.opaque)
      return;
    let mounted = cursor.tree && cursor.tree.prop(NodeProp.mounted);
    if (mounted && mounted.overlay) {
      let inner = cursor.node.enter(mounted.overlay[0].from + start, 1);
      let innerHighlighters = this.highlighters.filter((h) => !h.scope || h.scope(mounted.tree.type));
      let hasChild2 = cursor.firstChild();
      for (let i = 0, pos = start; ; i++) {
        let next = i < mounted.overlay.length ? mounted.overlay[i] : null;
        let nextPos = next ? next.from + start : end;
        let rangeFrom2 = Math.max(from, pos), rangeTo2 = Math.min(to, nextPos);
        if (rangeFrom2 < rangeTo2 && hasChild2) {
          while (cursor.from < rangeTo2) {
            this.highlightRange(cursor, rangeFrom2, rangeTo2, inheritedClass, highlighters);
            this.startSpan(Math.min(rangeTo2, cursor.to), cls);
            if (cursor.to >= nextPos || !cursor.nextSibling())
              break;
          }
        }
        if (!next || nextPos > to)
          break;
        pos = next.to + start;
        if (pos > from) {
          this.highlightRange(inner.cursor(), Math.max(from, next.from + start), Math.min(to, pos), "", innerHighlighters);
          this.startSpan(Math.min(to, pos), cls);
        }
      }
      if (hasChild2)
        cursor.parent();
    } else if (cursor.firstChild()) {
      if (mounted)
        inheritedClass = "";
      do {
        if (cursor.to <= from)
          continue;
        if (cursor.from >= to)
          break;
        this.highlightRange(cursor, from, to, inheritedClass, highlighters);
        this.startSpan(Math.min(to, cursor.to), cls);
      } while (cursor.nextSibling());
      cursor.parent();
    }
  }
};
function getStyleTags(node) {
  let rule = node.type.prop(ruleNodeProp);
  while (rule && rule.context && !node.matchContext(rule.context))
    rule = rule.next;
  return rule || null;
}
var t = Tag.define;
var comment = t();
var name = t();
var typeName = t(name);
var propertyName = t(name);
var literal = t();
var string = t(literal);
var number = t(literal);
var content = t();
var heading = t(content);
var keyword = t();
var operator = t();
var punctuation = t();
var bracket = t(punctuation);
var meta = t();
var tags = {
  /**
  A comment.
  */
  comment,
  /**
  A line [comment](#highlight.tags.comment).
  */
  lineComment: t(comment),
  /**
  A block [comment](#highlight.tags.comment).
  */
  blockComment: t(comment),
  /**
  A documentation [comment](#highlight.tags.comment).
  */
  docComment: t(comment),
  /**
  Any kind of identifier.
  */
  name,
  /**
  The [name](#highlight.tags.name) of a variable.
  */
  variableName: t(name),
  /**
  A type [name](#highlight.tags.name).
  */
  typeName,
  /**
  A tag name (subtag of [`typeName`](#highlight.tags.typeName)).
  */
  tagName: t(typeName),
  /**
  A property or field [name](#highlight.tags.name).
  */
  propertyName,
  /**
  An attribute name (subtag of [`propertyName`](#highlight.tags.propertyName)).
  */
  attributeName: t(propertyName),
  /**
  The [name](#highlight.tags.name) of a class.
  */
  className: t(name),
  /**
  A label [name](#highlight.tags.name).
  */
  labelName: t(name),
  /**
  A namespace [name](#highlight.tags.name).
  */
  namespace: t(name),
  /**
  The [name](#highlight.tags.name) of a macro.
  */
  macroName: t(name),
  /**
  A literal value.
  */
  literal,
  /**
  A string [literal](#highlight.tags.literal).
  */
  string,
  /**
  A documentation [string](#highlight.tags.string).
  */
  docString: t(string),
  /**
  A character literal (subtag of [string](#highlight.tags.string)).
  */
  character: t(string),
  /**
  An attribute value (subtag of [string](#highlight.tags.string)).
  */
  attributeValue: t(string),
  /**
  A number [literal](#highlight.tags.literal).
  */
  number,
  /**
  An integer [number](#highlight.tags.number) literal.
  */
  integer: t(number),
  /**
  A floating-point [number](#highlight.tags.number) literal.
  */
  float: t(number),
  /**
  A boolean [literal](#highlight.tags.literal).
  */
  bool: t(literal),
  /**
  Regular expression [literal](#highlight.tags.literal).
  */
  regexp: t(literal),
  /**
  An escape [literal](#highlight.tags.literal), for example a
  backslash escape in a string.
  */
  escape: t(literal),
  /**
  A color [literal](#highlight.tags.literal).
  */
  color: t(literal),
  /**
  A URL [literal](#highlight.tags.literal).
  */
  url: t(literal),
  /**
  A language keyword.
  */
  keyword,
  /**
  The [keyword](#highlight.tags.keyword) for the self or this
  object.
  */
  self: t(keyword),
  /**
  The [keyword](#highlight.tags.keyword) for null.
  */
  null: t(keyword),
  /**
  A [keyword](#highlight.tags.keyword) denoting some atomic value.
  */
  atom: t(keyword),
  /**
  A [keyword](#highlight.tags.keyword) that represents a unit.
  */
  unit: t(keyword),
  /**
  A modifier [keyword](#highlight.tags.keyword).
  */
  modifier: t(keyword),
  /**
  A [keyword](#highlight.tags.keyword) that acts as an operator.
  */
  operatorKeyword: t(keyword),
  /**
  A control-flow related [keyword](#highlight.tags.keyword).
  */
  controlKeyword: t(keyword),
  /**
  A [keyword](#highlight.tags.keyword) that defines something.
  */
  definitionKeyword: t(keyword),
  /**
  A [keyword](#highlight.tags.keyword) related to defining or
  interfacing with modules.
  */
  moduleKeyword: t(keyword),
  /**
  An operator.
  */
  operator,
  /**
  An [operator](#highlight.tags.operator) that dereferences something.
  */
  derefOperator: t(operator),
  /**
  Arithmetic-related [operator](#highlight.tags.operator).
  */
  arithmeticOperator: t(operator),
  /**
  Logical [operator](#highlight.tags.operator).
  */
  logicOperator: t(operator),
  /**
  Bit [operator](#highlight.tags.operator).
  */
  bitwiseOperator: t(operator),
  /**
  Comparison [operator](#highlight.tags.operator).
  */
  compareOperator: t(operator),
  /**
  [Operator](#highlight.tags.operator) that updates its operand.
  */
  updateOperator: t(operator),
  /**
  [Operator](#highlight.tags.operator) that defines something.
  */
  definitionOperator: t(operator),
  /**
  Type-related [operator](#highlight.tags.operator).
  */
  typeOperator: t(operator),
  /**
  Control-flow [operator](#highlight.tags.operator).
  */
  controlOperator: t(operator),
  /**
  Program or markup punctuation.
  */
  punctuation,
  /**
  [Punctuation](#highlight.tags.punctuation) that separates
  things.
  */
  separator: t(punctuation),
  /**
  Bracket-style [punctuation](#highlight.tags.punctuation).
  */
  bracket,
  /**
  Angle [brackets](#highlight.tags.bracket) (usually `<` and `>`
  tokens).
  */
  angleBracket: t(bracket),
  /**
  Square [brackets](#highlight.tags.bracket) (usually `[` and `]`
  tokens).
  */
  squareBracket: t(bracket),
  /**
  Parentheses (usually `(` and `)` tokens). Subtag of
  [bracket](#highlight.tags.bracket).
  */
  paren: t(bracket),
  /**
  Braces (usually `{` and `}` tokens). Subtag of
  [bracket](#highlight.tags.bracket).
  */
  brace: t(bracket),
  /**
  Content, for example plain text in XML or markup documents.
  */
  content,
  /**
  [Content](#highlight.tags.content) that represents a heading.
  */
  heading,
  /**
  A level 1 [heading](#highlight.tags.heading).
  */
  heading1: t(heading),
  /**
  A level 2 [heading](#highlight.tags.heading).
  */
  heading2: t(heading),
  /**
  A level 3 [heading](#highlight.tags.heading).
  */
  heading3: t(heading),
  /**
  A level 4 [heading](#highlight.tags.heading).
  */
  heading4: t(heading),
  /**
  A level 5 [heading](#highlight.tags.heading).
  */
  heading5: t(heading),
  /**
  A level 6 [heading](#highlight.tags.heading).
  */
  heading6: t(heading),
  /**
  A prose [content](#highlight.tags.content) separator (such as a horizontal rule).
  */
  contentSeparator: t(content),
  /**
  [Content](#highlight.tags.content) that represents a list.
  */
  list: t(content),
  /**
  [Content](#highlight.tags.content) that represents a quote.
  */
  quote: t(content),
  /**
  [Content](#highlight.tags.content) that is emphasized.
  */
  emphasis: t(content),
  /**
  [Content](#highlight.tags.content) that is styled strong.
  */
  strong: t(content),
  /**
  [Content](#highlight.tags.content) that is part of a link.
  */
  link: t(content),
  /**
  [Content](#highlight.tags.content) that is styled as code or
  monospace.
  */
  monospace: t(content),
  /**
  [Content](#highlight.tags.content) that has a strike-through
  style.
  */
  strikethrough: t(content),
  /**
  Inserted text in a change-tracking format.
  */
  inserted: t(),
  /**
  Deleted text.
  */
  deleted: t(),
  /**
  Changed text.
  */
  changed: t(),
  /**
  An invalid or unsyntactic element.
  */
  invalid: t(),
  /**
  Metadata or meta-instruction.
  */
  meta,
  /**
  [Metadata](#highlight.tags.meta) that applies to the entire
  document.
  */
  documentMeta: t(meta),
  /**
  [Metadata](#highlight.tags.meta) that annotates or adds
  attributes to a given syntactic element.
  */
  annotation: t(meta),
  /**
  Processing instruction or preprocessor directive. Subtag of
  [meta](#highlight.tags.meta).
  */
  processingInstruction: t(meta),
  /**
  [Modifier](#highlight.Tag^defineModifier) that indicates that a
  given element is being defined. Expected to be used with the
  various [name](#highlight.tags.name) tags.
  */
  definition: Tag.defineModifier("definition"),
  /**
  [Modifier](#highlight.Tag^defineModifier) that indicates that
  something is constant. Mostly expected to be used with
  [variable names](#highlight.tags.variableName).
  */
  constant: Tag.defineModifier("constant"),
  /**
  [Modifier](#highlight.Tag^defineModifier) used to indicate that
  a [variable](#highlight.tags.variableName) or [property
  name](#highlight.tags.propertyName) is being called or defined
  as a function.
  */
  function: Tag.defineModifier("function"),
  /**
  [Modifier](#highlight.Tag^defineModifier) that can be applied to
  [names](#highlight.tags.name) to indicate that they belong to
  the language's standard environment.
  */
  standard: Tag.defineModifier("standard"),
  /**
  [Modifier](#highlight.Tag^defineModifier) that indicates a given
  [names](#highlight.tags.name) is local to some scope.
  */
  local: Tag.defineModifier("local"),
  /**
  A generic variant [modifier](#highlight.Tag^defineModifier) that
  can be used to tag language-specific alternative variants of
  some common tag. It is recommended for themes to define special
  forms of at least the [string](#highlight.tags.string) and
  [variable name](#highlight.tags.variableName) tags, since those
  come up a lot.
  */
  special: Tag.defineModifier("special")
};
for (let name2 in tags) {
  let val = tags[name2];
  if (val instanceof Tag)
    val.name = name2;
}
var classHighlighter = tagHighlighter([
  { tag: tags.link, class: "tok-link" },
  { tag: tags.heading, class: "tok-heading" },
  { tag: tags.emphasis, class: "tok-emphasis" },
  { tag: tags.strong, class: "tok-strong" },
  { tag: tags.keyword, class: "tok-keyword" },
  { tag: tags.atom, class: "tok-atom" },
  { tag: tags.bool, class: "tok-bool" },
  { tag: tags.url, class: "tok-url" },
  { tag: tags.labelName, class: "tok-labelName" },
  { tag: tags.inserted, class: "tok-inserted" },
  { tag: tags.deleted, class: "tok-deleted" },
  { tag: tags.literal, class: "tok-literal" },
  { tag: tags.string, class: "tok-string" },
  { tag: tags.number, class: "tok-number" },
  { tag: [tags.regexp, tags.escape, tags.special(tags.string)], class: "tok-string2" },
  { tag: tags.variableName, class: "tok-variableName" },
  { tag: tags.local(tags.variableName), class: "tok-variableName tok-local" },
  { tag: tags.definition(tags.variableName), class: "tok-variableName tok-definition" },
  { tag: tags.special(tags.variableName), class: "tok-variableName2" },
  { tag: tags.definition(tags.propertyName), class: "tok-propertyName tok-definition" },
  { tag: tags.typeName, class: "tok-typeName" },
  { tag: tags.namespace, class: "tok-namespace" },
  { tag: tags.className, class: "tok-className" },
  { tag: tags.macroName, class: "tok-macroName" },
  { tag: tags.propertyName, class: "tok-propertyName" },
  { tag: tags.operator, class: "tok-operator" },
  { tag: tags.comment, class: "tok-comment" },
  { tag: tags.meta, class: "tok-meta" },
  { tag: tags.invalid, class: "tok-invalid" },
  { tag: tags.punctuation, class: "tok-punctuation" }
]);

// src/codemirror/style-highlight.ts
import { HighlightStyle, syntaxHighlighting } from "@codemirror/language";
var highlightStyle = HighlightStyle.define([
  { tag: tags.strong, color: "#007F69", "font-weight": "bold" },
  { tag: tags.variableName, color: "#0000AA" },
  { tag: tags.operator, color: "#660096" },
  { tag: tags.literal, color: "#963700" },
  { tag: tags.lineComment, color: "#5A5A5A" },
  { tag: tags.bool, color: "#660096" },
  { tag: tags.paren, color: "#333333" }
]);
var highlight = syntaxHighlighting(highlightStyle);

// src/codemirror/extension-update.ts
import { EditorView as EditorView2 } from "@codemirror/view";
var updateExtension = function(callback) {
  return EditorView2.updateListener.of(callback);
};

// src/lang/classes/structures.ts
var AgentContexts = class {
  /** Parse an agent-context string. */
  constructor(Input) {
    this.Observer = true;
    this.Turtle = true;
    this.Patch = true;
    this.Link = true;
    if (!Input) return;
    if (Input == "?") {
      this.Observer = false;
      return;
    }
    if (Input[0] != "O") this.Observer = false;
    if (Input[1] != "T") this.Turtle = false;
    if (Input[2] != "P") this.Patch = false;
    if (Input[3] != "L") this.Link = false;
  }
};
var Breed = class {
  /** Build a breed. */
  constructor(Singular, Plural, Variables, BreedType2) {
    this.Singular = Singular;
    this.Plural = Plural;
    this.Variables = Variables;
    this.BreedType = BreedType2;
  }
};
var Procedure = class {
  constructor() {
    /** Name: The name of the procedure. */
    this.Name = "";
    /** Arguments: The arguments of the procedure. */
    this.Arguments = [];
    /** Variables: Local variables defined within the procedure. */
    this.Variables = [];
    /** AnonymousProcedures: Anonymous procedures defined for the procedure. */
    this.AnonymousProcedures = [];
    /** PositionStart: The starting position of the procedure in the document. */
    this.PositionStart = 0;
    /** PositionEnd: The end position of the procedure in the document. */
    this.PositionEnd = 0;
    /** IsCommand: Is the procedure a command (to) instead of a reporter (to-report)? */
    this.IsCommand = false;
    /** IsCommand: Is the procedure anonymous? */
    this.IsAnonymous = false;
    /** Context: The possible contexts for the procedure. */
    this.Context = new AgentContexts();
    /** CodeBlocks: Code blocks within the procedure. */
    this.CodeBlocks = [];
  }
};
var CodeBlock = class {
  constructor() {
    /** PositionStart: The position at the start of the code block. */
    this.PositionStart = 0;
    /** PositionEnd: The position at the end of the code block. */
    this.PositionEnd = 0;
    /** Context: The possible contexts for the code block */
    this.Context = new AgentContexts();
    /** CodeBlocks: Code blocks within the code block. */
    this.CodeBlocks = [];
    /** Variables: Local variables defined within the code block. */
    this.Variables = [];
    /** Arguments: The arguments accessible within the code block. */
    this.Arguments = [];
    /** AnonymousProcedures: Anonymous procedures defined within the code block. */
    this.AnonymousProcedures = [];
    /** Primitive: the primitive that created the codeblock. */
    this.Primitive = "";
    /** Breed: the breed in the primitive that created the codeblock (if present). */
    this.Breed = null;
    /** InheritParentContext: whether context needs to match parent context. */
    this.InheritParentContext = false;
  }
};
var LocalVariable = class {
  /** Build a local variable. */
  constructor(Name, Type, CreationPos) {
    this.Name = Name;
    this.Type = Type;
    this.CreationPos = CreationPos;
  }
};
var ContextError = class {
  /** Constructor: Build a context error. */
  constructor(From, To2, PriorContext, ConflictingContext, Primitive2) {
    this.From = From;
    this.To = To2;
    this.PriorContext = PriorContext;
    this.ConflictingContext = ConflictingContext;
    this.Primitive = Primitive2;
  }
};

// src/utils/context-utils.ts
var combineContexts = function(c1, c2) {
  let final = new AgentContexts();
  if (!c1.Observer || !c2.Observer) {
    final.Observer = false;
  }
  if (!c1.Turtle || !c2.Turtle) {
    final.Turtle = false;
  }
  if (!c1.Patch || !c2.Patch) {
    final.Patch = false;
  }
  if (!c1.Link || !c2.Link) {
    final.Link = false;
  }
  return final;
};
var noContext = function(context) {
  return !context.Observer && !context.Turtle && !context.Patch && !context.Link;
};

// src/lang/primitives/dataset.ts
var Dataset = [{ "Extension": "", "Name": "link-shapes", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [], "ReturnType": { "Types": [4], "CanRepeat": false, "Optional": false }, "Precedence": 10, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "standard-deviation", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [4], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [3], "CanRepeat": false, "Optional": false }, "Precedence": 10, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "se", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [1], "CanRepeat": true, "Optional": false }], "ReturnType": { "Types": [4], "CanRepeat": false, "Optional": false }, "Precedence": 10, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "DefaultOption": 2, "MinimumOption": 0, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "rgb", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [3], "CanRepeat": false, "Optional": false }, { "Types": [3], "CanRepeat": false, "Optional": false }, { "Types": [3], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [4], "CanRepeat": false, "Optional": false }, "Precedence": 10, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "replace-item", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [3], "CanRepeat": false, "Optional": false }, { "Types": [2, 4], "CanRepeat": false, "Optional": false }, { "Types": [1], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [2, 4], "CanRepeat": false, "Optional": false }, "Precedence": 10, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "file-read-characters", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [3], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [2], "CanRepeat": false, "Optional": false }, "Precedence": 10, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "but-last", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [2, 4], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [2, 4], "CanRepeat": false, "Optional": false }, "Precedence": 10, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "__block", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [13], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [2], "CanRepeat": false, "Optional": false }, "Precedence": 10, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "modes", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [4], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [4], "CanRepeat": false, "Optional": false }, "Precedence": 10, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "random-pxcor", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [], "ReturnType": { "Types": [3], "CanRepeat": false, "Optional": false }, "Precedence": 10, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "range", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [3], "CanRepeat": true, "Optional": false }], "ReturnType": { "Types": [4], "CanRepeat": false, "Optional": false }, "Precedence": 10, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "DefaultOption": 1, "MinimumOption": 1, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "link-length", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [], "ReturnType": { "Types": [3], "CanRepeat": false, "Optional": false }, "Precedence": 10, "AgentContext": { "Observer": false, "Turtle": false, "Patch": false, "Link": true }, "BlockContext": { "Observer": false, "Turtle": false, "Patch": false, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "hubnet-exit-message?", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [], "ReturnType": { "Types": [5], "CanRepeat": false, "Optional": false }, "Precedence": 10, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "ln", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [3], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [3], "CanRepeat": false, "Optional": false }, "Precedence": 10, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "max", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [4], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [3], "CanRepeat": false, "Optional": false }, "Precedence": 10, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "bl", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [2, 4], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [2, 4], "CanRepeat": false, "Optional": false }, "Precedence": 10, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "towardsxy", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [3], "CanRepeat": false, "Optional": false }, { "Types": [3], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [3], "CanRepeat": false, "Optional": false }, "Precedence": 10, "AgentContext": { "Observer": false, "Turtle": true, "Patch": true, "Link": false }, "BlockContext": { "Observer": false, "Turtle": true, "Patch": true, "Link": false }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "list", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [1], "CanRepeat": true, "Optional": false }], "ReturnType": { "Types": [4], "CanRepeat": false, "Optional": false }, "Precedence": 10, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "DefaultOption": 2, "MinimumOption": 0, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "exp", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [3], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [3], "CanRepeat": false, "Optional": false }, "Precedence": 10, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "__check-syntax", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [2], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [2], "CanRepeat": false, "Optional": false }, "Precedence": 10, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "shade-of?", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [3], "CanRepeat": false, "Optional": false }, { "Types": [3], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [5], "CanRepeat": false, "Optional": false }, "Precedence": 10, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "patch", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [3], "CanRepeat": false, "Optional": false }, { "Types": [3], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [10], "CanRepeat": false, "Optional": false }, "Precedence": 10, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "with-max", "LeftArgumentType": { "Types": [7], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [14], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [7], "CanRepeat": false, "Optional": false }, "Precedence": 12, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": false, "Turtle": true, "Patch": true, "Link": true }, "IntroducesContext": true, "CanBeConcise": true, "InheritParentContext": false }, { "Extension": "", "Name": "is-turtle-set?", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [1], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [5], "CanRepeat": false, "Optional": false }, "Precedence": 10, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "__apply-result", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [15], "CanRepeat": false, "Optional": false }, { "Types": [4], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [1], "CanRepeat": false, "Optional": false }, "Precedence": 10, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "in-link-from", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [6], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [6], "CanRepeat": false, "Optional": false }, "Precedence": 10, "AgentContext": { "Observer": false, "Turtle": true, "Patch": false, "Link": false }, "BlockContext": { "Observer": false, "Turtle": true, "Patch": false, "Link": false }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "hsb", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [3], "CanRepeat": false, "Optional": false }, { "Types": [3], "CanRepeat": false, "Optional": false }, { "Types": [3], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [4], "CanRepeat": false, "Optional": false }, "Precedence": 10, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "netlogo-version", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [], "ReturnType": { "Types": [2], "CanRepeat": false, "Optional": false }, "Precedence": 10, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "random-normal", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [3], "CanRepeat": false, "Optional": false }, { "Types": [3], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [3], "CanRepeat": false, "Optional": false }, "Precedence": 10, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "towards", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [9, 10], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [3], "CanRepeat": false, "Optional": false }, "Precedence": 10, "AgentContext": { "Observer": false, "Turtle": true, "Patch": true, "Link": false }, "BlockContext": { "Observer": false, "Turtle": true, "Patch": true, "Link": false }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "atan", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [3], "CanRepeat": false, "Optional": false }, { "Types": [3], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [3], "CanRepeat": false, "Optional": false }, "Precedence": 10, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "mean", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [4], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [3], "CanRepeat": false, "Optional": false }, "Precedence": 10, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "__random-state", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [], "ReturnType": { "Types": [2], "CanRepeat": false, "Optional": false }, "Precedence": 10, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "patch-here", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [], "ReturnType": { "Types": [10], "CanRepeat": false, "Optional": false }, "Precedence": 10, "AgentContext": { "Observer": false, "Turtle": true, "Patch": false, "Link": false }, "BlockContext": { "Observer": false, "Turtle": true, "Patch": false, "Link": false }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "random", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [3], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [3], "CanRepeat": false, "Optional": false }, "Precedence": 10, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "+", "LeftArgumentType": { "Types": [3], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [3], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [3], "CanRepeat": false, "Optional": false }, "Precedence": 7, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "first", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [2, 4], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [1], "CanRepeat": false, "Optional": false }, "Precedence": 10, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "out-link-to", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [6], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [6], "CanRepeat": false, "Optional": false }, "Precedence": 10, "AgentContext": { "Observer": false, "Turtle": true, "Patch": false, "Link": false }, "BlockContext": { "Observer": false, "Turtle": true, "Patch": false, "Link": false }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "file-read-line", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [], "ReturnType": { "Types": [2], "CanRepeat": false, "Optional": false }, "Precedence": 10, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "substring", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [2], "CanRepeat": false, "Optional": false }, { "Types": [3], "CanRepeat": false, "Optional": false }, { "Types": [3], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [2], "CanRepeat": false, "Optional": false }, "Precedence": 10, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "plot-name", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [], "ReturnType": { "Types": [2], "CanRepeat": false, "Optional": false }, "Precedence": 10, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "remove-duplicates", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [4], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [4], "CanRepeat": false, "Optional": false }, "Precedence": 10, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "precision", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [3], "CanRepeat": false, "Optional": false }, { "Types": [3], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [3], "CanRepeat": false, "Optional": false }, "Precedence": 10, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "turtles", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [], "ReturnType": { "Types": [7], "CanRepeat": false, "Optional": false }, "Precedence": 10, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "is-agentset?", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [1], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [5], "CanRepeat": false, "Optional": false }, "Precedence": 10, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "no-turtles", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [], "ReturnType": { "Types": [7], "CanRepeat": false, "Optional": false }, "Precedence": 10, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "patch-set", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [4, 7, 10], "CanRepeat": true, "Optional": false }], "ReturnType": { "Types": [7], "CanRepeat": false, "Optional": false }, "Precedence": 10, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "DefaultOption": 1, "MinimumOption": 0, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "is-directed-link?", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [1], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [5], "CanRepeat": false, "Optional": false }, "Precedence": 10, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "at-points", "LeftArgumentType": { "Types": [7, 7], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [4], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [7], "CanRepeat": false, "Optional": false }, "Precedence": 12, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "asin", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [3], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [3], "CanRepeat": false, "Optional": false }, "Precedence": 10, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "remainder", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [3], "CanRepeat": false, "Optional": false }, { "Types": [3], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [3], "CanRepeat": false, "Optional": false }, "Precedence": 10, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "in-cone", "LeftArgumentType": { "Types": [7, 7], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [3], "CanRepeat": false, "Optional": false }, { "Types": [3], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [7, 7], "CanRepeat": false, "Optional": false }, "Precedence": 12, "AgentContext": { "Observer": false, "Turtle": true, "Patch": false, "Link": false }, "BlockContext": { "Observer": false, "Turtle": true, "Patch": false, "Link": false }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "butfirst", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [2, 4], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [2, 4], "CanRepeat": false, "Optional": false }, "Precedence": 10, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "/", "LeftArgumentType": { "Types": [3], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [3], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [3], "CanRepeat": false, "Optional": false }, "Precedence": 8, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "is-agent?", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [1], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [5], "CanRepeat": false, "Optional": false }, "Precedence": 10, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "remove", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [1], "CanRepeat": false, "Optional": false }, { "Types": [2, 4], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [2, 4], "CanRepeat": false, "Optional": false }, "Precedence": 10, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "and", "LeftArgumentType": { "Types": [5], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [5], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [5], "CanRepeat": false, "Optional": false }, "Precedence": 4, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "min", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [4], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [3], "CanRepeat": false, "Optional": false }, "Precedence": 10, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "self", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [], "ReturnType": { "Types": [6], "CanRepeat": false, "Optional": false }, "Precedence": 10, "AgentContext": { "Observer": false, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": false, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "in-link-neighbor?", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [6], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [5], "CanRepeat": false, "Optional": false }, "Precedence": 10, "AgentContext": { "Observer": false, "Turtle": true, "Patch": false, "Link": false }, "BlockContext": { "Observer": false, "Turtle": true, "Patch": false, "Link": false }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "is-link-set?", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [1], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [5], "CanRepeat": false, "Optional": false }, "Precedence": 10, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "distance", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [9, 10], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [3], "CanRepeat": false, "Optional": false }, "Precedence": 10, "AgentContext": { "Observer": false, "Turtle": true, "Patch": true, "Link": false }, "BlockContext": { "Observer": false, "Turtle": true, "Patch": true, "Link": false }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "plot-x-max", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [], "ReturnType": { "Types": [3], "CanRepeat": false, "Optional": false }, "Precedence": 10, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "sentence", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [1], "CanRepeat": true, "Optional": false }], "ReturnType": { "Types": [4], "CanRepeat": false, "Optional": false }, "Precedence": 10, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "DefaultOption": 2, "MinimumOption": 0, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "log", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [3], "CanRepeat": false, "Optional": false }, { "Types": [3], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [3], "CanRepeat": false, "Optional": false }, "Precedence": 10, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "__reference", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [16], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [4], "CanRepeat": false, "Optional": false }, "Precedence": 10, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "new-seed", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [], "ReturnType": { "Types": [3], "CanRepeat": false, "Optional": false }, "Precedence": 10, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "mod", "LeftArgumentType": { "Types": [3], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [3], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [3], "CanRepeat": false, "Optional": false }, "Precedence": 8, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "link-neighbors", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [], "ReturnType": { "Types": [7], "CanRepeat": false, "Optional": false }, "Precedence": 10, "AgentContext": { "Observer": false, "Turtle": true, "Patch": false, "Link": false }, "BlockContext": { "Observer": false, "Turtle": true, "Patch": false, "Link": false }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "min-one-of", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [7], "CanRepeat": false, "Optional": false }, { "Types": [14], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [6], "CanRepeat": false, "Optional": false }, "Precedence": 10, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": false, "Turtle": true, "Patch": true, "Link": true }, "IntroducesContext": true, "CanBeConcise": true, "InheritParentContext": false }, { "Extension": "", "Name": "^", "LeftArgumentType": { "Types": [3], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [3], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [3], "CanRepeat": false, "Optional": false }, "Precedence": 9, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "with-min", "LeftArgumentType": { "Types": [7], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [14], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [7], "CanRepeat": false, "Optional": false }, "Precedence": 12, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": false, "Turtle": true, "Patch": true, "Link": true }, "IntroducesContext": true, "CanBeConcise": true, "InheritParentContext": false }, { "Extension": "", "Name": "distancexy", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [3], "CanRepeat": false, "Optional": false }, { "Types": [3], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [3], "CanRepeat": false, "Optional": false }, "Precedence": 10, "AgentContext": { "Observer": false, "Turtle": true, "Patch": true, "Link": false }, "BlockContext": { "Observer": false, "Turtle": true, "Patch": true, "Link": false }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "sort-by", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [15], "CanRepeat": false, "Optional": false }, { "Types": [4, 7], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [4], "CanRepeat": false, "Optional": false }, "Precedence": 10, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": false, "Turtle": true, "Patch": true, "Link": true }, "IntroducesContext": true, "CanBeConcise": true, "InheritParentContext": false }, { "Extension": "", "Name": "item", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [3], "CanRepeat": false, "Optional": false }, { "Types": [2, 4], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [1], "CanRepeat": false, "Optional": false }, "Precedence": 10, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "*", "LeftArgumentType": { "Types": [3], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [3], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [3], "CanRepeat": false, "Optional": false }, "Precedence": 8, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "filter", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [15], "CanRepeat": false, "Optional": false }, { "Types": [4], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [4], "CanRepeat": false, "Optional": false }, "Precedence": 10, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "__symbol", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [16], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [2], "CanRepeat": false, "Optional": false }, "Precedence": 10, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "random-ycor", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [], "ReturnType": { "Types": [3], "CanRepeat": false, "Optional": false }, "Precedence": 10, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "variance", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [4], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [3], "CanRepeat": false, "Optional": false }, "Precedence": 10, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "in-radius", "LeftArgumentType": { "Types": [7, 7], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [3], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [7, 7], "CanRepeat": false, "Optional": false }, "Precedence": 12, "AgentContext": { "Observer": false, "Turtle": true, "Patch": true, "Link": false }, "BlockContext": { "Observer": false, "Turtle": true, "Patch": true, "Link": false }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "plot-x-min", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [], "ReturnType": { "Types": [3], "CanRepeat": false, "Optional": false }, "Precedence": 10, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "no-patches", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [], "ReturnType": { "Types": [7], "CanRepeat": false, "Optional": false }, "Precedence": 10, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "patch-right-and-ahead", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [3], "CanRepeat": false, "Optional": false }, { "Types": [3], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [10], "CanRepeat": false, "Optional": false }, "Precedence": 10, "AgentContext": { "Observer": false, "Turtle": true, "Patch": false, "Link": false }, "BlockContext": { "Observer": false, "Turtle": true, "Patch": false, "Link": false }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "random-exponential", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [3], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [3], "CanRepeat": false, "Optional": false }, "Precedence": 10, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "<=", "LeftArgumentType": { "Types": [6, 3, 2], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [6, 3, 2], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [5], "CanRepeat": false, "Optional": false }, "Precedence": 6, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "turtles-here", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [], "ReturnType": { "Types": [7], "CanRepeat": false, "Optional": false }, "Precedence": 10, "AgentContext": { "Observer": false, "Turtle": true, "Patch": true, "Link": false }, "BlockContext": { "Observer": false, "Turtle": true, "Patch": true, "Link": false }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "is-number?", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [1], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [5], "CanRepeat": false, "Optional": false }, "Precedence": 10, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "error-message", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [], "ReturnType": { "Types": [2], "CanRepeat": false, "Optional": false }, "Precedence": 10, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "not", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [5], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [5], "CanRepeat": false, "Optional": false }, "Precedence": 10, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "__dump", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [], "ReturnType": { "Types": [2], "CanRepeat": false, "Optional": false }, "Precedence": 10, "AgentContext": { "Observer": true, "Turtle": false, "Patch": false, "Link": false }, "BlockContext": { "Observer": true, "Turtle": false, "Patch": false, "Link": false }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "user-input", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [1], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [2], "CanRepeat": false, "Optional": false }, "Precedence": 10, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "patch-left-and-ahead", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [3], "CanRepeat": false, "Optional": false }, { "Types": [3], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [10], "CanRepeat": false, "Optional": false }, "Precedence": 10, "AgentContext": { "Observer": false, "Turtle": true, "Patch": false, "Link": false }, "BlockContext": { "Observer": false, "Turtle": true, "Patch": false, "Link": false }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "member?", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [1], "CanRepeat": false, "Optional": false }, { "Types": [2, 4, 7], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [5], "CanRepeat": false, "Optional": false }, "Precedence": 10, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "is-patch?", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [1], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [5], "CanRepeat": false, "Optional": false }, "Precedence": 10, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "shuffle", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [4], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [4], "CanRepeat": false, "Optional": false }, "Precedence": 10, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "mouse-xcor", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [], "ReturnType": { "Types": [3], "CanRepeat": false, "Optional": false }, "Precedence": 10, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "min-n-of", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [3], "CanRepeat": false, "Optional": false }, { "Types": [7], "CanRepeat": false, "Optional": false }, { "Types": [14], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [7], "CanRepeat": false, "Optional": false }, "Precedence": 10, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": false, "Turtle": true, "Patch": true, "Link": true }, "IntroducesContext": true, "CanBeConcise": true, "InheritParentContext": false }, { "Extension": "", "Name": "links", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [], "ReturnType": { "Types": [17], "CanRepeat": false, "Optional": false }, "Precedence": 10, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "__stack-trace", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [], "ReturnType": { "Types": [2], "CanRepeat": false, "Optional": false }, "Precedence": 10, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "__to-string", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [1], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [2], "CanRepeat": false, "Optional": false }, "Precedence": 10, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "world-height", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [], "ReturnType": { "Types": [3], "CanRepeat": false, "Optional": false }, "Precedence": 10, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "my-out-links", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [], "ReturnType": { "Types": [17], "CanRepeat": false, "Optional": false }, "Precedence": 10, "AgentContext": { "Observer": false, "Turtle": true, "Patch": false, "Link": false }, "BlockContext": { "Observer": false, "Turtle": true, "Patch": false, "Link": false }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "in-link-neighbors", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [], "ReturnType": { "Types": [7], "CanRepeat": false, "Optional": false }, "Precedence": 10, "AgentContext": { "Observer": false, "Turtle": true, "Patch": false, "Link": false }, "BlockContext": { "Observer": false, "Turtle": true, "Patch": false, "Link": false }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "one-of", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [4, 7], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [1], "CanRepeat": false, "Optional": false }, "Precedence": 10, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "random-pycor", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [], "ReturnType": { "Types": [3], "CanRepeat": false, "Optional": false }, "Precedence": 10, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "min-pycor", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [], "ReturnType": { "Types": [3], "CanRepeat": false, "Optional": false }, "Precedence": 10, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "mouse-inside?", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [], "ReturnType": { "Types": [5], "CanRepeat": false, "Optional": false }, "Precedence": 10, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "empty?", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [2, 4], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [5], "CanRepeat": false, "Optional": false }, "Precedence": 10, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "subject", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [], "ReturnType": { "Types": [6], "CanRepeat": false, "Optional": false }, "Precedence": 10, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "n-values", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [3], "CanRepeat": false, "Optional": false }, { "Types": [15], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [4], "CanRepeat": false, "Optional": false }, "Precedence": 10, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "neighbors4", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [], "ReturnType": { "Types": [7], "CanRepeat": false, "Optional": false }, "Precedence": 10, "AgentContext": { "Observer": false, "Turtle": true, "Patch": true, "Link": false }, "BlockContext": { "Observer": false, "Turtle": true, "Patch": true, "Link": false }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "is-anonymous-reporter?", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [1], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [5], "CanRepeat": false, "Optional": false }, "Precedence": 10, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "scale-color", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [3], "CanRepeat": false, "Optional": false }, { "Types": [3], "CanRepeat": false, "Optional": false }, { "Types": [3], "CanRepeat": false, "Optional": false }, { "Types": [3], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [3], "CanRepeat": false, "Optional": false }, "Precedence": 10, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "turtles-on", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [6, 7], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [7], "CanRepeat": false, "Optional": false }, "Precedence": 10, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "patch-at", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [3], "CanRepeat": false, "Optional": false }, { "Types": [3], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [10], "CanRepeat": false, "Optional": false }, "Precedence": 10, "AgentContext": { "Observer": false, "Turtle": true, "Patch": true, "Link": false }, "BlockContext": { "Observer": false, "Turtle": true, "Patch": true, "Link": false }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "mouse-down?", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [], "ReturnType": { "Types": [5], "CanRepeat": false, "Optional": false }, "Precedence": 10, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "other-end", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [], "ReturnType": { "Types": [6], "CanRepeat": false, "Optional": false }, "Precedence": 10, "AgentContext": { "Observer": false, "Turtle": true, "Patch": false, "Link": true }, "BlockContext": { "Observer": false, "Turtle": true, "Patch": false, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "ifelse-value", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [5], "CanRepeat": false, "Optional": false }, { "Types": [18], "CanRepeat": false, "Optional": false }, { "Types": [5, 18], "CanRepeat": true, "Optional": false }], "ReturnType": { "Types": [1], "CanRepeat": false, "Optional": false }, "Precedence": 3, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "DefaultOption": 3, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "round", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [3], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [3], "CanRepeat": false, "Optional": false }, "Precedence": 10, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "position", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [1], "CanRepeat": false, "Optional": false }, { "Types": [2, 4], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [3, 5], "CanRepeat": false, "Optional": false }, "Precedence": 10, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "turtles-at", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [3], "CanRepeat": false, "Optional": false }, { "Types": [3], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [7], "CanRepeat": false, "Optional": false }, "Precedence": 10, "AgentContext": { "Observer": false, "Turtle": true, "Patch": true, "Link": false }, "BlockContext": { "Observer": false, "Turtle": true, "Patch": true, "Link": false }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "sort", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [4, 7], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [4], "CanRepeat": false, "Optional": false }, "Precedence": 10, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "insert-item", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [3], "CanRepeat": false, "Optional": false }, { "Types": [2, 4], "CanRepeat": false, "Optional": false }, { "Types": [1], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [2, 4], "CanRepeat": false, "Optional": false }, "Precedence": 10, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "max-one-of", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [7], "CanRepeat": false, "Optional": false }, { "Types": [14], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [6], "CanRepeat": false, "Optional": false }, "Precedence": 10, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": false, "Turtle": true, "Patch": true, "Link": true }, "IntroducesContext": true, "CanBeConcise": true, "InheritParentContext": false }, { "Extension": "", "Name": "abs", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [3], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [3], "CanRepeat": false, "Optional": false }, "Precedence": 10, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "file-at-end?", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [], "ReturnType": { "Types": [5], "CanRepeat": false, "Optional": false }, "Precedence": 10, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "word", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [1], "CanRepeat": true, "Optional": false }], "ReturnType": { "Types": [2], "CanRepeat": false, "Optional": false }, "Precedence": 10, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "DefaultOption": 2, "MinimumOption": 0, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "mouse-ycor", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [], "ReturnType": { "Types": [3], "CanRepeat": false, "Optional": false }, "Precedence": 10, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "up-to-n-of", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [3], "CanRepeat": false, "Optional": false }, { "Types": [4, 7], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [4, 7], "CanRepeat": false, "Optional": false }, "Precedence": 10, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "ticks", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [], "ReturnType": { "Types": [3], "CanRepeat": false, "Optional": false }, "Precedence": 10, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "min-pxcor", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [], "ReturnType": { "Types": [3], "CanRepeat": false, "Optional": false }, "Precedence": 10, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "is-list?", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [1], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [5], "CanRepeat": false, "Optional": false }, "Precedence": 10, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "my-in-links", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [], "ReturnType": { "Types": [17], "CanRepeat": false, "Optional": false }, "Precedence": 10, "AgentContext": { "Observer": false, "Turtle": true, "Patch": false, "Link": false }, "BlockContext": { "Observer": false, "Turtle": true, "Patch": false, "Link": false }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "link-with", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [6], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [11], "CanRepeat": false, "Optional": false }, "Precedence": 10, "AgentContext": { "Observer": false, "Turtle": true, "Patch": false, "Link": false }, "BlockContext": { "Observer": false, "Turtle": true, "Patch": false, "Link": false }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "subtract-headings", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [3], "CanRepeat": false, "Optional": false }, { "Types": [3], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [3], "CanRepeat": false, "Optional": false }, "Precedence": 10, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "__processors", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [], "ReturnType": { "Types": [3], "CanRepeat": false, "Optional": false }, "Precedence": 10, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "shapes", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [], "ReturnType": { "Types": [4], "CanRepeat": false, "Optional": false }, "Precedence": 10, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "sin", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [3], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [3], "CanRepeat": false, "Optional": false }, "Precedence": 10, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "butlast", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [2, 4], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [2, 4], "CanRepeat": false, "Optional": false }, "Precedence": 10, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "count", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [7], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [3], "CanRepeat": false, "Optional": false }, "Precedence": 10, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "runresult", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [2, 15], "CanRepeat": false, "Optional": false }, { "Types": [1], "CanRepeat": true, "Optional": false }], "ReturnType": { "Types": [1], "CanRepeat": false, "Optional": false }, "Precedence": 10, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "DefaultOption": 1, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "timer", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [], "ReturnType": { "Types": [3], "CanRepeat": false, "Optional": false }, "Precedence": 10, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "patches", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [], "ReturnType": { "Types": [7], "CanRepeat": false, "Optional": false }, "Precedence": 10, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "__nano-time", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [], "ReturnType": { "Types": [3], "CanRepeat": false, "Optional": false }, "Precedence": 10, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "extract-hsb", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [3, 4], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [4], "CanRepeat": false, "Optional": false }, "Precedence": 10, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "run-result", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [2, 15], "CanRepeat": false, "Optional": false }, { "Types": [1], "CanRepeat": true, "Optional": false }], "ReturnType": { "Types": [1], "CanRepeat": false, "Optional": false }, "Precedence": 10, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "DefaultOption": 1, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "ceiling", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [3], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [3], "CanRepeat": false, "Optional": false }, "Precedence": 10, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "random-poisson", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [3], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [3], "CanRepeat": false, "Optional": false }, "Precedence": 10, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "plot-pen-exists?", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [2], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [5], "CanRepeat": false, "Optional": false }, "Precedence": 10, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "plot-y-min", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [], "ReturnType": { "Types": [3], "CanRepeat": false, "Optional": false }, "Precedence": 10, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": ">", "LeftArgumentType": { "Types": [6, 3, 2], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [6, 3, 2], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [5], "CanRepeat": false, "Optional": false }, "Precedence": 6, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "xor", "LeftArgumentType": { "Types": [5], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [5], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [5], "CanRepeat": false, "Optional": false }, "Precedence": 4, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "is-undirected-link?", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [1], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [5], "CanRepeat": false, "Optional": false }, "Precedence": 10, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "bf", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [2, 4], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [2, 4], "CanRepeat": false, "Optional": false }, "Precedence": 10, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "dy", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [], "ReturnType": { "Types": [3], "CanRepeat": false, "Optional": false }, "Precedence": 10, "AgentContext": { "Observer": false, "Turtle": true, "Patch": false, "Link": false }, "BlockContext": { "Observer": false, "Turtle": true, "Patch": false, "Link": false }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "autoplot?", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [], "ReturnType": { "Types": [5], "CanRepeat": false, "Optional": false }, "Precedence": 10, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "hubnet-clients-list", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [], "ReturnType": { "Types": [4], "CanRepeat": false, "Optional": false }, "Precedence": 10, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "reduce", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [15], "CanRepeat": false, "Optional": false }, { "Types": [4], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [1], "CanRepeat": false, "Optional": false }, "Precedence": 10, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "user-file", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [], "ReturnType": { "Types": [5, 2], "CanRepeat": false, "Optional": false }, "Precedence": 10, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "extract-rgb", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [3, 4], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [4], "CanRepeat": false, "Optional": false }, "Precedence": 10, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "is-link?", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [1], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [5], "CanRepeat": false, "Optional": false }, "Precedence": 10, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "user-yes-or-no?", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [1], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [5], "CanRepeat": false, "Optional": false }, "Precedence": 10, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "is-string?", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [1], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [5], "CanRepeat": false, "Optional": false }, "Precedence": 10, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "reverse", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [2, 4], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [2, 4], "CanRepeat": false, "Optional": false }, "Precedence": 10, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "plot-y-max", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [], "ReturnType": { "Types": [3], "CanRepeat": false, "Optional": false }, "Precedence": 10, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "max-n-of", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [3], "CanRepeat": false, "Optional": false }, { "Types": [7], "CanRepeat": false, "Optional": false }, { "Types": [14], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [7], "CanRepeat": false, "Optional": false }, "Precedence": 10, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": false, "Turtle": true, "Patch": true, "Link": true }, "IntroducesContext": true, "CanBeConcise": true, "InheritParentContext": false }, { "Extension": "", "Name": "hubnet-message", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [], "ReturnType": { "Types": [1], "CanRepeat": false, "Optional": false }, "Precedence": 10, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "length", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [2, 4], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [3], "CanRepeat": false, "Optional": false }, "Precedence": 10, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "behaviorspace-run-number", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [], "ReturnType": { "Types": [3], "CanRepeat": false, "Optional": false }, "Precedence": 10, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "behaviorspace-experiment-name", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [], "ReturnType": { "Types": [2], "CanRepeat": false, "Optional": false }, "Precedence": 10, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "read-from-string", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [2], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [3, 5, 2, 4, 8], "CanRepeat": false, "Optional": false }, "Precedence": 10, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "__dump-extensions", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [], "ReturnType": { "Types": [2], "CanRepeat": false, "Optional": false }, "Precedence": 10, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "netlogo-applet?", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [], "ReturnType": { "Types": [5], "CanRepeat": false, "Optional": false }, "Precedence": 10, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "tan", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [3], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [3], "CanRepeat": false, "Optional": false }, "Precedence": 10, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "other", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [7], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [7], "CanRepeat": false, "Optional": false }, "Precedence": 10, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "neighbors", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [], "ReturnType": { "Types": [7], "CanRepeat": false, "Optional": false }, "Precedence": 10, "AgentContext": { "Observer": false, "Turtle": true, "Patch": true, "Link": false }, "BlockContext": { "Observer": false, "Turtle": true, "Patch": true, "Link": false }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "approximate-hsb", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [3], "CanRepeat": false, "Optional": false }, { "Types": [3], "CanRepeat": false, "Optional": false }, { "Types": [3], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [3], "CanRepeat": false, "Optional": false }, "Precedence": 10, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "int", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [3], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [3], "CanRepeat": false, "Optional": false }, "Precedence": 10, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "hubnet-message-tag", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [], "ReturnType": { "Types": [2], "CanRepeat": false, "Optional": false }, "Precedence": 10, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "remove-item", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [3], "CanRepeat": false, "Optional": false }, { "Types": [2, 4], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [2, 4], "CanRepeat": false, "Optional": false }, "Precedence": 10, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "out-link-neighbors", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [], "ReturnType": { "Types": [7], "CanRepeat": false, "Optional": false }, "Precedence": 10, "AgentContext": { "Observer": false, "Turtle": true, "Patch": false, "Link": false }, "BlockContext": { "Observer": false, "Turtle": true, "Patch": false, "Link": false }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "both-ends", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [], "ReturnType": { "Types": [7], "CanRepeat": false, "Optional": false }, "Precedence": 10, "AgentContext": { "Observer": false, "Turtle": false, "Patch": false, "Link": true }, "BlockContext": { "Observer": false, "Turtle": false, "Patch": false, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "dx", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [], "ReturnType": { "Types": [3], "CanRepeat": false, "Optional": false }, "Precedence": 10, "AgentContext": { "Observer": false, "Turtle": true, "Patch": false, "Link": false }, "BlockContext": { "Observer": false, "Turtle": true, "Patch": false, "Link": false }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "floor", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [3], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [3], "CanRepeat": false, "Optional": false }, "Precedence": 10, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "patch-ahead", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [3], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [10], "CanRepeat": false, "Optional": false }, "Precedence": 10, "AgentContext": { "Observer": false, "Turtle": true, "Patch": false, "Link": false }, "BlockContext": { "Observer": false, "Turtle": true, "Patch": false, "Link": false }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "world-width", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [], "ReturnType": { "Types": [3], "CanRepeat": false, "Optional": false }, "Precedence": 10, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "link-neighbor?", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [6], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [5], "CanRepeat": false, "Optional": false }, "Precedence": 10, "AgentContext": { "Observer": false, "Turtle": true, "Patch": false, "Link": false }, "BlockContext": { "Observer": false, "Turtle": true, "Patch": false, "Link": false }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "max-pycor", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [], "ReturnType": { "Types": [3], "CanRepeat": false, "Optional": false }, "Precedence": 10, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "sum", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [4], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [3], "CanRepeat": false, "Optional": false }, "Precedence": 10, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "my-links", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [], "ReturnType": { "Types": [17], "CanRepeat": false, "Optional": false }, "Precedence": 10, "AgentContext": { "Observer": false, "Turtle": true, "Patch": false, "Link": false }, "BlockContext": { "Observer": false, "Turtle": true, "Patch": false, "Link": false }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "approximate-rgb", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [3], "CanRepeat": false, "Optional": false }, { "Types": [3], "CanRepeat": false, "Optional": false }, { "Types": [3], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [3], "CanRepeat": false, "Optional": false }, "Precedence": 10, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "user-new-file", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [], "ReturnType": { "Types": [5, 2], "CanRepeat": false, "Optional": false }, "Precedence": 10, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "<", "LeftArgumentType": { "Types": [6, 3, 2], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [6, 3, 2], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [5], "CanRepeat": false, "Optional": false }, "Precedence": 6, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "-", "LeftArgumentType": { "Types": [3], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [3], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [3], "CanRepeat": false, "Optional": false }, "Precedence": 7, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "file-exists?", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [2], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [5], "CanRepeat": false, "Optional": false }, "Precedence": 10, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "wrap-color", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [3], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [3], "CanRepeat": false, "Optional": false }, "Precedence": 10, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "link", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [3], "CanRepeat": false, "Optional": false }, { "Types": [3], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [11], "CanRepeat": false, "Optional": false }, "Precedence": 10, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "is-anonymous-command?", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [1], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [5], "CanRepeat": false, "Optional": false }, "Precedence": 10, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "random-float", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [3], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [3], "CanRepeat": false, "Optional": false }, "Precedence": 10, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "or", "LeftArgumentType": { "Types": [5], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [5], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [5], "CanRepeat": false, "Optional": false }, "Precedence": 4, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "netlogo-web?", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [], "ReturnType": { "Types": [5], "CanRepeat": false, "Optional": false }, "Precedence": 10, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "cos", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [3], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [3], "CanRepeat": false, "Optional": false }, "Precedence": 10, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "sort-on", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [18], "CanRepeat": false, "Optional": false }, { "Types": [7], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [4], "CanRepeat": false, "Optional": false }, "Precedence": 10, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": false, "Turtle": true, "Patch": true, "Link": true }, "IntroducesContext": true, "CanBeConcise": true, "InheritParentContext": false }, { "Extension": "", "Name": "lput", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [1], "CanRepeat": false, "Optional": false }, { "Types": [4], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [4], "CanRepeat": false, "Optional": false }, "Precedence": 10, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "out-link-neighbor?", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [6], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [5], "CanRepeat": false, "Optional": false }, "Precedence": 10, "AgentContext": { "Observer": false, "Turtle": true, "Patch": false, "Link": false }, "BlockContext": { "Observer": false, "Turtle": true, "Patch": false, "Link": false }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "median", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [4], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [3], "CanRepeat": false, "Optional": false }, "Precedence": 10, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "acos", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [3], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [3], "CanRepeat": false, "Optional": false }, "Precedence": 10, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "=", "LeftArgumentType": { "Types": [1], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [1], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [5], "CanRepeat": false, "Optional": false }, "Precedence": 5, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "all?", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [7], "CanRepeat": false, "Optional": false }, { "Types": [19], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [5], "CanRepeat": false, "Optional": false }, "Precedence": 10, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": false, "Turtle": true, "Patch": true, "Link": true }, "IntroducesContext": true, "CanBeConcise": true, "InheritParentContext": false }, { "Extension": "", "Name": "__dump-extension-prims", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [], "ReturnType": { "Types": [2], "CanRepeat": false, "Optional": false }, "Precedence": 10, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "random-gamma", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [3], "CanRepeat": false, "Optional": false }, { "Types": [3], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [3], "CanRepeat": false, "Optional": false }, "Precedence": 10, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "patch-size", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [], "ReturnType": { "Types": [3], "CanRepeat": false, "Optional": false }, "Precedence": 10, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "user-one-of", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [1], "CanRepeat": false, "Optional": false }, { "Types": [4], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [1], "CanRepeat": false, "Optional": false }, "Precedence": 10, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "any?", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [7], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [5], "CanRepeat": false, "Optional": false }, "Precedence": 10, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "turtle", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [3], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [9], "CanRepeat": false, "Optional": false }, "Precedence": 10, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "hubnet-message-source", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [], "ReturnType": { "Types": [2], "CanRepeat": false, "Optional": false }, "Precedence": 10, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "is-boolean?", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [1], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [5], "CanRepeat": false, "Optional": false }, "Precedence": 10, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "__checksum", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [], "ReturnType": { "Types": [2], "CanRepeat": false, "Optional": false }, "Precedence": 10, "AgentContext": { "Observer": true, "Turtle": false, "Patch": false, "Link": false }, "BlockContext": { "Observer": true, "Turtle": false, "Patch": false, "Link": false }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "__dump1", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [], "ReturnType": { "Types": [2], "CanRepeat": false, "Optional": false }, "Precedence": 10, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "n-of", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [3], "CanRepeat": false, "Optional": false }, { "Types": [4, 7], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [4, 7], "CanRepeat": false, "Optional": false }, "Precedence": 10, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "date-and-time", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [], "ReturnType": { "Types": [2], "CanRepeat": false, "Optional": false }, "Precedence": 10, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "can-move?", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [3], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [5], "CanRepeat": false, "Optional": false }, "Precedence": 10, "AgentContext": { "Observer": false, "Turtle": true, "Patch": false, "Link": false }, "BlockContext": { "Observer": false, "Turtle": true, "Patch": false, "Link": false }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "but-first", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [2, 4], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [2, 4], "CanRepeat": false, "Optional": false }, "Precedence": 10, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "base-colors", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [], "ReturnType": { "Types": [4], "CanRepeat": false, "Optional": false }, "Precedence": 10, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": ">=", "LeftArgumentType": { "Types": [6, 3, 2], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [6, 3, 2], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [5], "CanRepeat": false, "Optional": false }, "Precedence": 6, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "__boom", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [], "ReturnType": { "Types": [1], "CanRepeat": false, "Optional": false }, "Precedence": 10, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "link-heading", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [], "ReturnType": { "Types": [3], "CanRepeat": false, "Optional": false }, "Precedence": 10, "AgentContext": { "Observer": false, "Turtle": false, "Patch": false, "Link": true }, "BlockContext": { "Observer": false, "Turtle": false, "Patch": false, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "is-patch-set?", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [1], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [5], "CanRepeat": false, "Optional": false }, "Precedence": 10, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "is-turtle?", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [1], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [5], "CanRepeat": false, "Optional": false }, "Precedence": 10, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "sqrt", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [3], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [3], "CanRepeat": false, "Optional": false }, "Precedence": 10, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "link-set", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [4, 17, 11], "CanRepeat": true, "Optional": false }], "ReturnType": { "Types": [17], "CanRepeat": false, "Optional": false }, "Precedence": 10, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "DefaultOption": 1, "MinimumOption": 0, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "file-read", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [], "ReturnType": { "Types": [3, 5, 2, 4, 8], "CanRepeat": false, "Optional": false }, "Precedence": 10, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "user-directory", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [], "ReturnType": { "Types": [5, 2], "CanRepeat": false, "Optional": false }, "Precedence": 10, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "sublist", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [4], "CanRepeat": false, "Optional": false }, { "Types": [3], "CanRepeat": false, "Optional": false }, { "Types": [3], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [4], "CanRepeat": false, "Optional": false }, "Precedence": 10, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "max-pxcor", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [], "ReturnType": { "Types": [3], "CanRepeat": false, "Optional": false }, "Precedence": 10, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "turtle-set", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [4, 7, 9], "CanRepeat": true, "Optional": false }], "ReturnType": { "Types": [7], "CanRepeat": false, "Optional": false }, "Precedence": 10, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "DefaultOption": 1, "MinimumOption": 0, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "map", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [15], "CanRepeat": false, "Optional": false }, { "Types": [4], "CanRepeat": true, "Optional": false }], "ReturnType": { "Types": [4], "CanRepeat": false, "Optional": false }, "Precedence": 10, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "DefaultOption": 2, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "hubnet-message-waiting?", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [], "ReturnType": { "Types": [5], "CanRepeat": false, "Optional": false }, "Precedence": 10, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "!=", "LeftArgumentType": { "Types": [1], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [1], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [5], "CanRepeat": false, "Optional": false }, "Precedence": 5, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "fput", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [1], "CanRepeat": false, "Optional": false }, { "Types": [4], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [4], "CanRepeat": false, "Optional": false }, "Precedence": 10, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "no-links", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [], "ReturnType": { "Types": [17], "CanRepeat": false, "Optional": false }, "Precedence": 10, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "last", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [2, 4], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [1], "CanRepeat": false, "Optional": false }, "Precedence": 10, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "myself", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [], "ReturnType": { "Types": [6], "CanRepeat": false, "Optional": false }, "Precedence": 10, "AgentContext": { "Observer": false, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": false, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "patch-at-heading-and-distance", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [3], "CanRepeat": false, "Optional": false }, { "Types": [3], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [10], "CanRepeat": false, "Optional": false }, "Precedence": 10, "AgentContext": { "Observer": false, "Turtle": true, "Patch": true, "Link": false }, "BlockContext": { "Observer": false, "Turtle": true, "Patch": true, "Link": false }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "random-xcor", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [], "ReturnType": { "Types": [3], "CanRepeat": false, "Optional": false }, "Precedence": 10, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "with", "LeftArgumentType": { "Types": [7], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [19], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [7], "CanRepeat": false, "Optional": false }, "Precedence": 12, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": false, "Turtle": true, "Patch": true, "Link": true }, "IntroducesContext": true, "CanBeConcise": true, "InheritParentContext": false }, { "Extension": "", "Name": "of", "LeftArgumentType": { "Types": [18], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [6, 7], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [1], "CanRepeat": false, "Optional": false }, "Precedence": 11, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": false, "Turtle": true, "Patch": true, "Link": true }, "IsRightAssociative": true, "IntroducesContext": true, "CanBeConcise": true, "InheritParentContext": false }, { "Extension": "", "Name": "hubnet-enter-message?", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [], "ReturnType": { "Types": [5], "CanRepeat": false, "Optional": false }, "Precedence": 10, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "show", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [1], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "Precedence": 0, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "update-plots", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "Precedence": 0, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "clear-globals", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "Precedence": 0, "AgentContext": { "Observer": true, "Turtle": false, "Patch": false, "Link": false }, "BlockContext": { "Observer": true, "Turtle": false, "Patch": false, "Link": false }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "display", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "Precedence": 0, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "ask", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [6, 7], "CanRepeat": false, "Optional": false }, { "Types": [12], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "Precedence": 0, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": false, "Turtle": true, "Patch": true, "Link": true }, "IntroducesContext": true, "CanBeConcise": true, "InheritParentContext": false }, { "Extension": "", "Name": "plot", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [3], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "Precedence": 0, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "create-links-from", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [7], "CanRepeat": false, "Optional": false }, { "Types": [12], "CanRepeat": false, "Optional": true }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "Precedence": 0, "AgentContext": { "Observer": false, "Turtle": true, "Patch": false, "Link": false }, "BlockContext": { "Observer": false, "Turtle": false, "Patch": false, "Link": true }, "IntroducesContext": true, "CanBeConcise": true, "InheritParentContext": false }, { "Extension": "", "Name": "carefully", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [12], "CanRepeat": false, "Optional": false }, { "Types": [12], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "Precedence": 0, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "IntroducesContext": true, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "hubnet-broadcast", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [2], "CanRepeat": false, "Optional": false }, { "Types": [1], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "Precedence": 0, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "forward", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [3], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "Precedence": 0, "AgentContext": { "Observer": false, "Turtle": true, "Patch": false, "Link": false }, "BlockContext": { "Observer": false, "Turtle": true, "Patch": false, "Link": false }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "plot-pen-reset", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "Precedence": 0, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "__stdout", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [1], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "Precedence": 0, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "__linkcode", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "Precedence": 0, "AgentContext": { "Observer": false, "Turtle": false, "Patch": false, "Link": true }, "BlockContext": { "Observer": false, "Turtle": false, "Patch": false, "Link": true }, "InheritParentContext": true }, { "Extension": "", "Name": "set-plot-x-range", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [3], "CanRepeat": false, "Optional": false }, { "Types": [3], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "Precedence": 0, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "create-temporary-plot-pen", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [2], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "Precedence": 0, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "hubnet-send", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [2, 4], "CanRepeat": false, "Optional": false }, { "Types": [2], "CanRepeat": false, "Optional": false }, { "Types": [1], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "Precedence": 0, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "hubnet-broadcast-clear-output", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "Precedence": 0, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "output-print", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [1], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "Precedence": 0, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "hubnet-send-follow", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [2], "CanRepeat": false, "Optional": false }, { "Types": [6], "CanRepeat": false, "Optional": false }, { "Types": [3], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "Precedence": 0, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "rp", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "Precedence": 0, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "cro", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [3], "CanRepeat": false, "Optional": false }, { "Types": [12], "CanRepeat": false, "Optional": true }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "Precedence": 0, "AgentContext": { "Observer": true, "Turtle": false, "Patch": false, "Link": false }, "BlockContext": { "Observer": false, "Turtle": true, "Patch": false, "Link": false }, "IntroducesContext": true, "CanBeConcise": true, "InheritParentContext": false }, { "Extension": "", "Name": "file-write", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [3, 5, 2, 4, 8], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "Precedence": 0, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "ht", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "Precedence": 0, "AgentContext": { "Observer": false, "Turtle": true, "Patch": false, "Link": false }, "BlockContext": { "Observer": false, "Turtle": true, "Patch": false, "Link": false }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "ct", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "Precedence": 0, "AgentContext": { "Observer": true, "Turtle": false, "Patch": false, "Link": false }, "BlockContext": { "Observer": true, "Turtle": false, "Patch": false, "Link": false }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "set-plot-pen-color", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [3, 4], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "Precedence": 0, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "__patchcode", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "Precedence": 0, "AgentContext": { "Observer": false, "Turtle": false, "Patch": true, "Link": false }, "BlockContext": { "Observer": false, "Turtle": false, "Patch": true, "Link": false }, "InheritParentContext": true }, { "Extension": "", "Name": "error", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [1], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "Precedence": 0, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "output-show", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [1], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "Precedence": 0, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "reset-perspective", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "Precedence": 0, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "__pwd", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "Precedence": 0, "AgentContext": { "Observer": true, "Turtle": false, "Patch": false, "Link": false }, "BlockContext": { "Observer": true, "Turtle": false, "Patch": false, "Link": false }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "if", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [5], "CanRepeat": false, "Optional": false }, { "Types": [12], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "Precedence": 0, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "uphill", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [16], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "Precedence": 0, "AgentContext": { "Observer": false, "Turtle": true, "Patch": false, "Link": false }, "BlockContext": { "Observer": false, "Turtle": true, "Patch": false, "Link": false }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "plot-pen-down", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "Precedence": 0, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "set", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [1], "CanRepeat": false, "Optional": false }, { "Types": [1], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "Precedence": 0, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "set-current-plot-pen", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [2], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "Precedence": 0, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "downhill", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [16], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "Precedence": 0, "AgentContext": { "Observer": false, "Turtle": true, "Patch": false, "Link": false }, "BlockContext": { "Observer": false, "Turtle": true, "Patch": false, "Link": false }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "set-plot-y-range", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [3], "CanRepeat": false, "Optional": false }, { "Types": [3], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "Precedence": 0, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "stop", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "Precedence": 0, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "set-current-directory", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [2], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "Precedence": 0, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "__done", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "Precedence": 0, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "InheritParentContext": true }, { "Extension": "", "Name": "rt", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [3], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "Precedence": 0, "AgentContext": { "Observer": false, "Turtle": true, "Patch": false, "Link": false }, "BlockContext": { "Observer": false, "Turtle": true, "Patch": false, "Link": false }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "import-pcolors", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [2], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "Precedence": 0, "AgentContext": { "Observer": true, "Turtle": false, "Patch": false, "Link": false }, "BlockContext": { "Observer": true, "Turtle": false, "Patch": false, "Link": false }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "import-pcolors-rgb", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [2], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "Precedence": 0, "AgentContext": { "Observer": true, "Turtle": false, "Patch": false, "Link": false }, "BlockContext": { "Observer": true, "Turtle": false, "Patch": false, "Link": false }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "__turtlecode", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "Precedence": 0, "AgentContext": { "Observer": false, "Turtle": true, "Patch": false, "Link": false }, "BlockContext": { "Observer": false, "Turtle": true, "Patch": false, "Link": false }, "InheritParentContext": true }, { "Extension": "", "Name": "create-link-to", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [9], "CanRepeat": false, "Optional": false }, { "Types": [12], "CanRepeat": false, "Optional": true }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "Precedence": 0, "AgentContext": { "Observer": false, "Turtle": true, "Patch": false, "Link": false }, "BlockContext": { "Observer": false, "Turtle": false, "Patch": false, "Link": true }, "IntroducesContext": true, "CanBeConcise": true, "InheritParentContext": false }, { "Extension": "", "Name": "diffuse4", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [16], "CanRepeat": false, "Optional": false }, { "Types": [3], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "Precedence": 0, "AgentContext": { "Observer": true, "Turtle": false, "Patch": false, "Link": false }, "BlockContext": { "Observer": true, "Turtle": false, "Patch": false, "Link": false }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "set-default-shape", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [7, 17], "CanRepeat": false, "Optional": false }, { "Types": [2], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "Precedence": 0, "AgentContext": { "Observer": true, "Turtle": false, "Patch": false, "Link": false }, "BlockContext": { "Observer": true, "Turtle": false, "Patch": false, "Link": false }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "bk", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [3], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "Precedence": 0, "AgentContext": { "Observer": false, "Turtle": true, "Patch": false, "Link": false }, "BlockContext": { "Observer": false, "Turtle": true, "Patch": false, "Link": false }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "clear-patches", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "Precedence": 0, "AgentContext": { "Observer": true, "Turtle": false, "Patch": false, "Link": false }, "BlockContext": { "Observer": true, "Turtle": false, "Patch": false, "Link": false }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "tie", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "Precedence": 0, "AgentContext": { "Observer": false, "Turtle": false, "Patch": false, "Link": true }, "BlockContext": { "Observer": false, "Turtle": false, "Patch": false, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "file-open", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [2], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "Precedence": 0, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "show-link", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "Precedence": 0, "AgentContext": { "Observer": false, "Turtle": false, "Patch": false, "Link": true }, "BlockContext": { "Observer": false, "Turtle": false, "Patch": false, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "__experimentstepend", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "Precedence": 0, "AgentContext": { "Observer": true, "Turtle": false, "Patch": false, "Link": false }, "BlockContext": { "Observer": true, "Turtle": false, "Patch": false, "Link": false }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "reset-timer", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "Precedence": 0, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "__apply", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [20], "CanRepeat": false, "Optional": false }, { "Types": [4], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "Precedence": 0, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "setxy", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [3], "CanRepeat": false, "Optional": false }, { "Types": [3], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "Precedence": 0, "AgentContext": { "Observer": false, "Turtle": true, "Patch": false, "Link": false }, "BlockContext": { "Observer": false, "Turtle": true, "Patch": false, "Link": false }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "jump", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [3], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "Precedence": 0, "AgentContext": { "Observer": false, "Turtle": true, "Patch": false, "Link": false }, "BlockContext": { "Observer": false, "Turtle": true, "Patch": false, "Link": false }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "hubnet-broadcast-message", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [1], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "Precedence": 0, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "ride", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [9], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "Precedence": 0, "AgentContext": { "Observer": true, "Turtle": false, "Patch": false, "Link": false }, "BlockContext": { "Observer": true, "Turtle": false, "Patch": false, "Link": false }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "file-close-all", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "Precedence": 0, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "hubnet-send-message", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [2, 4], "CanRepeat": false, "Optional": false }, { "Types": [1], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "Precedence": 0, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "downhill4", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [16], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "Precedence": 0, "AgentContext": { "Observer": false, "Turtle": true, "Patch": false, "Link": false }, "BlockContext": { "Observer": false, "Turtle": true, "Patch": false, "Link": false }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "__stderr", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [1], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "Precedence": 0, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "hubnet-kick-client", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [2], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "Precedence": 0, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "__bench", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [3], "CanRepeat": false, "Optional": false }, { "Types": [3], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "Precedence": 0, "AgentContext": { "Observer": true, "Turtle": false, "Patch": false, "Link": false }, "BlockContext": { "Observer": true, "Turtle": false, "Patch": false, "Link": false }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "pen-up", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "Precedence": 0, "AgentContext": { "Observer": false, "Turtle": true, "Patch": false, "Link": false }, "BlockContext": { "Observer": false, "Turtle": true, "Patch": false, "Link": false }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "back", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [3], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "Precedence": 0, "AgentContext": { "Observer": false, "Turtle": true, "Patch": false, "Link": false }, "BlockContext": { "Observer": false, "Turtle": true, "Patch": false, "Link": false }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "export-interface", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [2], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "Precedence": 0, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "set-plot-pen-interval", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [3], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "Precedence": 0, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "create-turtles", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [3], "CanRepeat": false, "Optional": false }, { "Types": [12], "CanRepeat": false, "Optional": true }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "Precedence": 0, "AgentContext": { "Observer": true, "Turtle": false, "Patch": false, "Link": false }, "BlockContext": { "Observer": false, "Turtle": true, "Patch": false, "Link": false }, "IntroducesContext": true, "CanBeConcise": true, "InheritParentContext": false }, { "Extension": "", "Name": "repeat", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [3], "CanRepeat": false, "Optional": false }, { "Types": [12], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "Precedence": 0, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "__plot-pen-hide", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "Precedence": 0, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "wait", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [3], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "Precedence": 0, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "follow-me", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "Precedence": 0, "AgentContext": { "Observer": false, "Turtle": true, "Patch": false, "Link": false }, "BlockContext": { "Observer": false, "Turtle": true, "Patch": false, "Link": false }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "ride-me", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "Precedence": 0, "AgentContext": { "Observer": false, "Turtle": true, "Patch": false, "Link": false }, "BlockContext": { "Observer": false, "Turtle": true, "Patch": false, "Link": false }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "__plot-pen-show", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "Precedence": 0, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "__set-line-thickness", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [3], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "Precedence": 0, "AgentContext": { "Observer": false, "Turtle": true, "Patch": false, "Link": false }, "BlockContext": { "Observer": false, "Turtle": true, "Patch": false, "Link": false }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "file-type", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [1], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "Precedence": 0, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "lt", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [3], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "Precedence": 0, "AgentContext": { "Observer": false, "Turtle": true, "Patch": false, "Link": false }, "BlockContext": { "Observer": false, "Turtle": true, "Patch": false, "Link": false }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "__reload-extensions", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "Precedence": 0, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "__foreverbuttonend", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "Precedence": 0, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "InheritParentContext": true }, { "Extension": "", "Name": "__ignore", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [1], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "Precedence": 0, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "import-world", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [2], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "Precedence": 0, "AgentContext": { "Observer": true, "Turtle": false, "Patch": false, "Link": false }, "BlockContext": { "Observer": true, "Turtle": false, "Patch": false, "Link": false }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "plotxy", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [3], "CanRepeat": false, "Optional": false }, { "Types": [3], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "Precedence": 0, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "show-turtle", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "Precedence": 0, "AgentContext": { "Observer": false, "Turtle": true, "Patch": false, "Link": false }, "BlockContext": { "Observer": false, "Turtle": true, "Patch": false, "Link": false }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "auto-plot-off", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "Precedence": 0, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "ca", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "Precedence": 0, "AgentContext": { "Observer": true, "Turtle": false, "Patch": false, "Link": false }, "BlockContext": { "Observer": true, "Turtle": false, "Patch": false, "Link": false }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "print", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [1], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "Precedence": 0, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "create-ordered-turtles", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [3], "CanRepeat": false, "Optional": false }, { "Types": [12], "CanRepeat": false, "Optional": true }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "Precedence": 0, "AgentContext": { "Observer": true, "Turtle": false, "Patch": false, "Link": false }, "BlockContext": { "Observer": false, "Turtle": true, "Patch": false, "Link": false }, "IntroducesContext": true, "CanBeConcise": true, "InheritParentContext": false }, { "Extension": "", "Name": "left", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [3], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "Precedence": 0, "AgentContext": { "Observer": false, "Turtle": true, "Patch": false, "Link": false }, "BlockContext": { "Observer": false, "Turtle": true, "Patch": false, "Link": false }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "st", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "Precedence": 0, "AgentContext": { "Observer": false, "Turtle": true, "Patch": false, "Link": false }, "BlockContext": { "Observer": false, "Turtle": true, "Patch": false, "Link": false }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "pu", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "Precedence": 0, "AgentContext": { "Observer": false, "Turtle": true, "Patch": false, "Link": false }, "BlockContext": { "Observer": false, "Turtle": true, "Patch": false, "Link": false }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "let", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [1], "CanRepeat": false, "Optional": false }, { "Types": [1], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "Precedence": 0, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "random-seed", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [3], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "Precedence": 0, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "watch-me", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "Precedence": 0, "AgentContext": { "Observer": false, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": false, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "hubnet-clear-overrides", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [2], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "Precedence": 0, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "clear-links", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "Precedence": 0, "AgentContext": { "Observer": true, "Turtle": false, "Patch": false, "Link": false }, "BlockContext": { "Observer": true, "Turtle": false, "Patch": false, "Link": false }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "hubnet-send-override", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [2], "CanRepeat": false, "Optional": false }, { "Types": [6, 7], "CanRepeat": false, "Optional": false }, { "Types": [2], "CanRepeat": false, "Optional": false }, { "Types": [18], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "Precedence": 0, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": false, "Turtle": true, "Patch": true, "Link": true }, "IntroducesContext": true, "CanBeConcise": true, "InheritParentContext": false }, { "Extension": "", "Name": "layout-tutte", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [7], "CanRepeat": false, "Optional": false }, { "Types": [17], "CanRepeat": false, "Optional": false }, { "Types": [3], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "Precedence": 0, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "tick-advance", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [3], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "Precedence": 0, "AgentContext": { "Observer": true, "Turtle": false, "Patch": false, "Link": false }, "BlockContext": { "Observer": true, "Turtle": false, "Patch": false, "Link": false }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "hubnet-send-watch", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [2], "CanRepeat": false, "Optional": false }, { "Types": [6], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "Precedence": 0, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "clear-output", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "Precedence": 0, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "hubnet-send-clear-output", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [2, 4], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "Precedence": 0, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "clear-all", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "Precedence": 0, "AgentContext": { "Observer": true, "Turtle": false, "Patch": false, "Link": false }, "BlockContext": { "Observer": true, "Turtle": false, "Patch": false, "Link": false }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "hubnet-reset", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "Precedence": 0, "AgentContext": { "Observer": true, "Turtle": false, "Patch": false, "Link": false }, "BlockContext": { "Observer": true, "Turtle": false, "Patch": false, "Link": false }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "export-plot", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [2], "CanRepeat": false, "Optional": false }, { "Types": [2], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "Precedence": 0, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "resize-world", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [3], "CanRepeat": false, "Optional": false }, { "Types": [3], "CanRepeat": false, "Optional": false }, { "Types": [3], "CanRepeat": false, "Optional": false }, { "Types": [3], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "Precedence": 0, "AgentContext": { "Observer": true, "Turtle": false, "Patch": false, "Link": false }, "BlockContext": { "Observer": true, "Turtle": false, "Patch": false, "Link": false }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "clear-plot", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "Precedence": 0, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "hubnet-fetch-message", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "Precedence": 0, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "diffuse", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [16], "CanRepeat": false, "Optional": false }, { "Types": [3], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "Precedence": 0, "AgentContext": { "Observer": true, "Turtle": false, "Patch": false, "Link": false }, "BlockContext": { "Observer": true, "Turtle": false, "Patch": false, "Link": false }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "while", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [19], "CanRepeat": false, "Optional": false }, { "Types": [12], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "Precedence": 0, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "user-message", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [1], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "Precedence": 0, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "fd", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [3], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "Precedence": 0, "AgentContext": { "Observer": false, "Turtle": true, "Patch": false, "Link": false }, "BlockContext": { "Observer": false, "Turtle": true, "Patch": false, "Link": false }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "loop", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [12], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "Precedence": 0, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "__export-drawing", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [2], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "Precedence": 0, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "tick", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "Precedence": 0, "AgentContext": { "Observer": true, "Turtle": false, "Patch": false, "Link": false }, "BlockContext": { "Observer": true, "Turtle": false, "Patch": false, "Link": false }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "__let", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [1], "CanRepeat": false, "Optional": false }, { "Types": [1], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "Precedence": 0, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "hubnet-reset-perspective", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [2], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "Precedence": 0, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "export-world", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [2], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "Precedence": 0, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "reset-ticks", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "Precedence": 0, "AgentContext": { "Observer": true, "Turtle": false, "Patch": false, "Link": false }, "BlockContext": { "Observer": true, "Turtle": false, "Patch": false, "Link": false }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "no-display", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "Precedence": 0, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "beep", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "Precedence": 0, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "stop-inspecting", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [6], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "Precedence": 0, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "follow", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [9], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "Precedence": 0, "AgentContext": { "Observer": true, "Turtle": false, "Patch": false, "Link": false }, "BlockContext": { "Observer": true, "Turtle": false, "Patch": false, "Link": false }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "pen-erase", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "Precedence": 0, "AgentContext": { "Observer": false, "Turtle": true, "Patch": false, "Link": false }, "BlockContext": { "Observer": false, "Turtle": true, "Patch": false, "Link": false }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "output-type", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [1], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "Precedence": 0, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "set-histogram-num-bars", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [3], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "Precedence": 0, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "type", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [1], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "Precedence": 0, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "__mkdir", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [2], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "Precedence": 0, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "set-patch-size", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [3], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "Precedence": 0, "AgentContext": { "Observer": true, "Turtle": false, "Patch": false, "Link": false }, "BlockContext": { "Observer": true, "Turtle": false, "Patch": false, "Link": false }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "file-print", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [1], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "Precedence": 0, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "create-link-with", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [9], "CanRepeat": false, "Optional": false }, { "Types": [12], "CanRepeat": false, "Optional": true }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "Precedence": 0, "AgentContext": { "Observer": false, "Turtle": true, "Patch": false, "Link": false }, "BlockContext": { "Observer": false, "Turtle": false, "Patch": false, "Link": true }, "IntroducesContext": true, "CanBeConcise": true, "InheritParentContext": false }, { "Extension": "", "Name": "hide-turtle", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "Precedence": 0, "AgentContext": { "Observer": false, "Turtle": true, "Patch": false, "Link": false }, "BlockContext": { "Observer": false, "Turtle": true, "Patch": false, "Link": false }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "inspect", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [6], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "Precedence": 0, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "every", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [3], "CanRepeat": false, "Optional": false }, { "Types": [12], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "Precedence": 0, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "output-write", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [3, 5, 2, 4, 8], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "Precedence": 0, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "cp", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "Precedence": 0, "AgentContext": { "Observer": true, "Turtle": false, "Patch": false, "Link": false }, "BlockContext": { "Observer": true, "Turtle": false, "Patch": false, "Link": false }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "right", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [3], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "Precedence": 0, "AgentContext": { "Observer": false, "Turtle": true, "Patch": false, "Link": false }, "BlockContext": { "Observer": false, "Turtle": true, "Patch": false, "Link": false }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "clear-drawing", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "Precedence": 0, "AgentContext": { "Observer": true, "Turtle": false, "Patch": false, "Link": false }, "BlockContext": { "Observer": true, "Turtle": false, "Patch": false, "Link": false }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "run", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [2, 20], "CanRepeat": false, "Optional": false }, { "Types": [1], "CanRepeat": true, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "Precedence": 0, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "DefaultOption": 1, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "plot-pen-up", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "Precedence": 0, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "report", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [1], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "Precedence": 0, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "clear-all-plots", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "Precedence": 0, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "file-close", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "Precedence": 0, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "create-links-with", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [7], "CanRepeat": false, "Optional": false }, { "Types": [12], "CanRepeat": false, "Optional": true }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "Precedence": 0, "AgentContext": { "Observer": false, "Turtle": true, "Patch": false, "Link": false }, "BlockContext": { "Observer": false, "Turtle": false, "Patch": false, "Link": true }, "IntroducesContext": true, "CanBeConcise": true, "InheritParentContext": false }, { "Extension": "", "Name": "auto-plot-on", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "Precedence": 0, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "pendown", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "Precedence": 0, "AgentContext": { "Observer": false, "Turtle": true, "Patch": false, "Link": false }, "BlockContext": { "Observer": false, "Turtle": true, "Patch": false, "Link": false }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "hubnet-kick-all-clients", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "Precedence": 0, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "without-interruption", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [12], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "Precedence": 0, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "IntroducesContext": true, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "import-drawing", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [2], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "Precedence": 0, "AgentContext": { "Observer": true, "Turtle": false, "Patch": false, "Link": false }, "BlockContext": { "Observer": true, "Turtle": false, "Patch": false, "Link": false }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "home", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "Precedence": 0, "AgentContext": { "Observer": false, "Turtle": true, "Patch": false, "Link": false }, "BlockContext": { "Observer": false, "Turtle": true, "Patch": false, "Link": false }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "__observercode", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "Precedence": 0, "AgentContext": { "Observer": true, "Turtle": false, "Patch": false, "Link": false }, "BlockContext": { "Observer": true, "Turtle": false, "Patch": false, "Link": false }, "InheritParentContext": true }, { "Extension": "", "Name": "layout-radial", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [7], "CanRepeat": false, "Optional": false }, { "Types": [17], "CanRepeat": false, "Optional": false }, { "Types": [9], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "Precedence": 0, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "penup", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "Precedence": 0, "AgentContext": { "Observer": false, "Turtle": true, "Patch": false, "Link": false }, "BlockContext": { "Observer": false, "Turtle": true, "Patch": false, "Link": false }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "write", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [3, 5, 2, 4, 8], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "Precedence": 0, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "face", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [9, 10], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "Precedence": 0, "AgentContext": { "Observer": false, "Turtle": true, "Patch": false, "Link": false }, "BlockContext": { "Observer": false, "Turtle": true, "Patch": false, "Link": false }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "ifelse", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [5], "CanRepeat": false, "Optional": false }, { "Types": [5, 12], "CanRepeat": true, "Optional": false }, { "Types": [12], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "Precedence": 0, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "DefaultOption": 3, "MinimumOption": 2, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "pd", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "Precedence": 0, "AgentContext": { "Observer": false, "Turtle": true, "Patch": false, "Link": false }, "BlockContext": { "Observer": false, "Turtle": true, "Patch": false, "Link": false }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "file-delete", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [2], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "Precedence": 0, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "create-link-from", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [9], "CanRepeat": false, "Optional": false }, { "Types": [12], "CanRepeat": false, "Optional": true }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "Precedence": 0, "AgentContext": { "Observer": false, "Turtle": true, "Patch": false, "Link": false }, "BlockContext": { "Observer": false, "Turtle": false, "Patch": false, "Link": true }, "IntroducesContext": true, "CanBeConcise": true, "InheritParentContext": false }, { "Extension": "", "Name": "watch", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [6], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "Precedence": 0, "AgentContext": { "Observer": true, "Turtle": false, "Patch": false, "Link": false }, "BlockContext": { "Observer": true, "Turtle": false, "Patch": false, "Link": false }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "layout-circle", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [4, 7], "CanRepeat": false, "Optional": false }, { "Types": [3], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "Precedence": 0, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "ask-concurrent", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [7], "CanRepeat": false, "Optional": false }, { "Types": [12], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "Precedence": 0, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": false, "Turtle": true, "Patch": true, "Link": true }, "IntroducesContext": true, "CanBeConcise": true, "InheritParentContext": false }, { "Extension": "", "Name": "hide-link", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "Precedence": 0, "AgentContext": { "Observer": false, "Turtle": false, "Patch": false, "Link": true }, "BlockContext": { "Observer": false, "Turtle": false, "Patch": false, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "create-links-to", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [7], "CanRepeat": false, "Optional": false }, { "Types": [12], "CanRepeat": false, "Optional": true }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "Precedence": 0, "AgentContext": { "Observer": false, "Turtle": true, "Patch": false, "Link": false }, "BlockContext": { "Observer": false, "Turtle": false, "Patch": false, "Link": true }, "IntroducesContext": true, "CanBeConcise": true, "InheritParentContext": false }, { "Extension": "", "Name": "setup-plots", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "Precedence": 0, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "facexy", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [3], "CanRepeat": false, "Optional": false }, { "Types": [3], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "Precedence": 0, "AgentContext": { "Observer": false, "Turtle": true, "Patch": false, "Link": false }, "BlockContext": { "Observer": false, "Turtle": true, "Patch": false, "Link": false }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "stop-inspecting-dead-agents", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "Precedence": 0, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "clear-turtles", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "Precedence": 0, "AgentContext": { "Observer": true, "Turtle": false, "Patch": false, "Link": false }, "BlockContext": { "Observer": true, "Turtle": false, "Patch": false, "Link": false }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "__thunk-did-finish", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "Precedence": 0, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "histogram", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [4], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "Precedence": 0, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "stamp-erase", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "Precedence": 0, "AgentContext": { "Observer": false, "Turtle": true, "Patch": false, "Link": true }, "BlockContext": { "Observer": false, "Turtle": true, "Patch": false, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "layout-spring", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [7], "CanRepeat": false, "Optional": false }, { "Types": [17], "CanRepeat": false, "Optional": false }, { "Types": [3], "CanRepeat": false, "Optional": false }, { "Types": [3], "CanRepeat": false, "Optional": false }, { "Types": [3], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "Precedence": 0, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "stamp", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "Precedence": 0, "AgentContext": { "Observer": false, "Turtle": true, "Patch": false, "Link": true }, "BlockContext": { "Observer": false, "Turtle": true, "Patch": false, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "file-flush", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "Precedence": 0, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "crt", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [3], "CanRepeat": false, "Optional": false }, { "Types": [12], "CanRepeat": false, "Optional": true }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "Precedence": 0, "AgentContext": { "Observer": true, "Turtle": false, "Patch": false, "Link": false }, "BlockContext": { "Observer": false, "Turtle": true, "Patch": false, "Link": false }, "IntroducesContext": true, "CanBeConcise": true, "InheritParentContext": false }, { "Extension": "", "Name": "die", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "Precedence": 0, "AgentContext": { "Observer": false, "Turtle": true, "Patch": false, "Link": true }, "BlockContext": { "Observer": false, "Turtle": true, "Patch": false, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "foreach", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [4], "CanRepeat": true, "Optional": false }, { "Types": [20], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "Precedence": 0, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "DefaultOption": 2, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "with-local-randomness", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [12], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "Precedence": 0, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "IntroducesContext": true, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "set-current-plot", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [2], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "Precedence": 0, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "pe", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "Precedence": 0, "AgentContext": { "Observer": false, "Turtle": true, "Patch": false, "Link": false }, "BlockContext": { "Observer": false, "Turtle": true, "Patch": false, "Link": false }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "export-view", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [2], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "Precedence": 0, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "cd", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "Precedence": 0, "AgentContext": { "Observer": true, "Turtle": false, "Patch": false, "Link": false }, "BlockContext": { "Observer": true, "Turtle": false, "Patch": false, "Link": false }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "move-to", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [9, 10], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "Precedence": 0, "AgentContext": { "Observer": false, "Turtle": true, "Patch": false, "Link": false }, "BlockContext": { "Observer": false, "Turtle": true, "Patch": false, "Link": false }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "if-else", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [5], "CanRepeat": false, "Optional": false }, { "Types": [5, 12], "CanRepeat": true, "Optional": false }, { "Types": [12], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "Precedence": 0, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "DefaultOption": 3, "MinimumOption": 2, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "set-plot-pen-mode", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [3], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "Precedence": 0, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "uphill4", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [16], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "Precedence": 0, "AgentContext": { "Observer": false, "Turtle": true, "Patch": false, "Link": false }, "BlockContext": { "Observer": false, "Turtle": true, "Patch": false, "Link": false }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "__change-topology", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [5], "CanRepeat": false, "Optional": false }, { "Types": [5], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "Precedence": 0, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "pen-down", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "Precedence": 0, "AgentContext": { "Observer": false, "Turtle": true, "Patch": false, "Link": false }, "BlockContext": { "Observer": false, "Turtle": true, "Patch": false, "Link": false }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "clear-ticks", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "Precedence": 0, "AgentContext": { "Observer": true, "Turtle": false, "Patch": false, "Link": false }, "BlockContext": { "Observer": true, "Turtle": false, "Patch": false, "Link": false }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "file-show", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [1], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "Precedence": 0, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "untie", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "Precedence": 0, "AgentContext": { "Observer": false, "Turtle": false, "Patch": false, "Link": true }, "BlockContext": { "Observer": false, "Turtle": false, "Patch": false, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "export-all-plots", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [2], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "Precedence": 0, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "hubnet-clear-override", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [2], "CanRepeat": false, "Optional": false }, { "Types": [6, 7], "CanRepeat": false, "Optional": false }, { "Types": [2], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "Precedence": 0, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": false, "Turtle": true, "Patch": true, "Link": true }, "IntroducesContext": true, "CanBeConcise": true, "InheritParentContext": false }, { "Extension": "", "Name": "sprout", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [3], "CanRepeat": false, "Optional": false }, { "Types": [12], "CanRepeat": false, "Optional": true }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "Precedence": 0, "AgentContext": { "Observer": false, "Turtle": false, "Patch": true, "Link": false }, "BlockContext": { "Observer": false, "Turtle": true, "Patch": false, "Link": false }, "IntroducesContext": true, "CanBeConcise": true, "InheritParentContext": false }, { "Extension": "", "Name": "export-output", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [2], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "Precedence": 0, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "BlockContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "CanBeConcise": true, "InheritParentContext": true }, { "Extension": "", "Name": "hatch", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [3], "CanRepeat": false, "Optional": false }, { "Types": [12], "CanRepeat": false, "Optional": true }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "Precedence": 0, "AgentContext": { "Observer": false, "Turtle": true, "Patch": false, "Link": false }, "BlockContext": { "Observer": false, "Turtle": true, "Patch": false, "Link": false }, "IntroducesContext": true, "CanBeConcise": true, "InheritParentContext": false }, { "Extension": "array", "Name": "from-list", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [4], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [1], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "array", "Name": "to-list", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [1], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [4], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "array", "Name": "is-array?", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [1], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [5], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "array", "Name": "length", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [1], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [3], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "array", "Name": "item", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [1], "CanRepeat": false, "Optional": false }, { "Types": [3], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [1], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "array", "Name": "set", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [1], "CanRepeat": false, "Optional": false }, { "Types": [3], "CanRepeat": false, "Optional": false }, { "Types": [1], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "bitmap", "Name": "average-color", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [1], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [4], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "bitmap", "Name": "channel", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [1], "CanRepeat": false, "Optional": false }, { "Types": [3], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [1], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "bitmap", "Name": "copy-to", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [1], "CanRepeat": false, "Optional": false }, { "Types": [1], "CanRepeat": false, "Optional": false }, { "Types": [3], "CanRepeat": true, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0, "DefaultOption": 2 }, { "Extension": "bitmap", "Name": "copy-to-drawing", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [1], "CanRepeat": false, "Optional": false }, { "Types": [3], "CanRepeat": false, "Optional": false }, { "Types": [3], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "bitmap", "Name": "copy-to-pcolors", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [1], "CanRepeat": false, "Optional": false }, { "Types": [5], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "bitmap", "Name": "copy-to-shape", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [1], "CanRepeat": false, "Optional": false }, { "Types": [2], "CanRepeat": false, "Optional": false }, { "Types": [5], "CanRepeat": true, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0, "DefaultOption": 2 }, { "Extension": "bitmap", "Name": "create", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [3], "CanRepeat": false, "Optional": false }, { "Types": [3], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [1], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "bitmap", "Name": "difference-rgb", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [1], "CanRepeat": false, "Optional": false }, { "Types": [1], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [1], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "bitmap", "Name": "export", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [1], "CanRepeat": false, "Optional": false }, { "Types": [2], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "bitmap", "Name": "from-base64", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [2], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [1], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "bitmap", "Name": "to-base64", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [1], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [2], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "bitmap", "Name": "from-view", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [], "ReturnType": { "Types": [1], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "bitmap", "Name": "to-grayscale", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [1], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [1], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "bitmap", "Name": "height", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [1], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [3], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "bitmap", "Name": "import", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [2], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [1], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "bitmap", "Name": "scaled", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [1], "CanRepeat": false, "Optional": false }, { "Types": [3], "CanRepeat": false, "Optional": false }, { "Types": [3], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [1], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "bitmap", "Name": "width", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [1], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [3], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "bitmap", "Name": "set-pixel", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [1], "CanRepeat": false, "Optional": false }, { "Types": [3], "CanRepeat": false, "Optional": false }, { "Types": [3], "CanRepeat": false, "Optional": false }, { "Types": [4], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "bitmap", "Name": "get-pixel", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [1], "CanRepeat": false, "Optional": false }, { "Types": [3], "CanRepeat": false, "Optional": false }, { "Types": [3], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [4], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "codap", "Name": "init", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [20], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "codap", "Name": "call", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [1], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "csv", "Name": "from-string", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [2], "CanRepeat": true, "Optional": false }], "ReturnType": { "Types": [4], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0, "DefaultOption": 1 }, { "Extension": "csv", "Name": "from-row", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [2], "CanRepeat": true, "Optional": false }], "ReturnType": { "Types": [4], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0, "DefaultOption": 1 }, { "Extension": "csv", "Name": "from-file", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [2], "CanRepeat": false, "Optional": false }, { "Types": [2], "CanRepeat": true, "Optional": false }], "ReturnType": { "Types": [4], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0, "DefaultOption": 1 }, { "Extension": "csv", "Name": "to-string", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [4], "CanRepeat": false, "Optional": false }, { "Types": [2], "CanRepeat": true, "Optional": false }], "ReturnType": { "Types": [2], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0, "DefaultOption": 1 }, { "Extension": "csv", "Name": "to-row", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [4], "CanRepeat": false, "Optional": false }, { "Types": [2], "CanRepeat": true, "Optional": false }], "ReturnType": { "Types": [2], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0, "DefaultOption": 1 }, { "Extension": "csv", "Name": "to-file", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [2], "CanRepeat": false, "Optional": false }, { "Types": [4], "CanRepeat": false, "Optional": false }, { "Types": [2], "CanRepeat": true, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0, "DefaultOption": 2 }, { "Extension": "dialog", "Name": "user-input", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [2], "CanRepeat": false, "Optional": false }, { "Types": [2, 20], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "dialog", "Name": "user-message", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [2], "CanRepeat": false, "Optional": false }, { "Types": [2, 20], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "dialog", "Name": "user-one-of", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [2], "CanRepeat": false, "Optional": false }, { "Types": [4], "CanRepeat": false, "Optional": false }, { "Types": [2, 20], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "dialog", "Name": "user-yes-or-no?", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [2], "CanRepeat": false, "Optional": false }, { "Types": [2, 20], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "encode", "Name": "base64-to-bytes", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [2], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [4], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "encode", "Name": "bytes-to-base64", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [4], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [2], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "encode", "Name": "bytes-to-string", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [4], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [2], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "encode", "Name": "string-to-bytes", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [2], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [4], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "export-the", "Name": "model", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [], "ReturnType": { "Types": [2], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "export-the", "Name": "output", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [], "ReturnType": { "Types": [2], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "export-the", "Name": "plot", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [2], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [2], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "export-the", "Name": "view", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [], "ReturnType": { "Types": [2], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "export-the", "Name": "world", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [], "ReturnType": { "Types": [2], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "fetch", "Name": "file", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [2], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [2], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "fetch", "Name": "file-async", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [2], "CanRepeat": false, "Optional": false }, { "Types": [20], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "fetch", "Name": "url", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [2], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [2], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "fetch", "Name": "url-async", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [2], "CanRepeat": false, "Optional": false }, { "Types": [20], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "fetch", "Name": "user-file", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [], "ReturnType": { "Types": [2], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "fetch", "Name": "user-file-async", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [20], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "fp", "Name": "take", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [3], "CanRepeat": false, "Optional": false }, { "Types": [4], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [4], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "fp", "Name": "drop", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [3], "CanRepeat": false, "Optional": false }, { "Types": [4], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [4], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "fp", "Name": "scan", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [15], "CanRepeat": false, "Optional": false }, { "Types": [4], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [4], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "fp", "Name": "compose", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [15], "CanRepeat": false, "Optional": false }, { "Types": [15], "CanRepeat": false, "Optional": false }, { "Types": [15], "CanRepeat": true, "Optional": false }], "ReturnType": { "Types": [15], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0, "DefaultOption": 2 }, { "Extension": "fp", "Name": "pipe", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [15], "CanRepeat": false, "Optional": false }, { "Types": [15], "CanRepeat": false, "Optional": false }, { "Types": [15], "CanRepeat": true, "Optional": false }], "ReturnType": { "Types": [15], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0, "DefaultOption": 2 }, { "Extension": "fp", "Name": "curry", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [15], "CanRepeat": false, "Optional": false }, { "Types": [1], "CanRepeat": true, "Optional": false }], "ReturnType": { "Types": [15], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0, "DefaultOption": 2 }, { "Extension": "fp", "Name": "find-indices", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [15], "CanRepeat": false, "Optional": false }, { "Types": [4], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [4], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "fp", "Name": "find", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [15], "CanRepeat": false, "Optional": false }, { "Types": [4], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [1], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "fp", "Name": "zip", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [4], "CanRepeat": false, "Optional": false }, { "Types": [4], "CanRepeat": true, "Optional": false }], "ReturnType": { "Types": [4], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0, "DefaultOption": 2 }, { "Extension": "fp", "Name": "unzip", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [4], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [4], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "fp", "Name": "flatten", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [4], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [4], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "fp", "Name": "iterate", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [15], "CanRepeat": false, "Optional": false }, { "Types": [1], "CanRepeat": false, "Optional": false }, { "Types": [3], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [4], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "fp", "Name": "iterate-last", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [15], "CanRepeat": false, "Optional": false }, { "Types": [1], "CanRepeat": false, "Optional": false }, { "Types": [3], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [1], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "http-req", "Name": "get", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [2], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [4], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "http-req", "Name": "post", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [2], "CanRepeat": false, "Optional": false }, { "Types": [2], "CanRepeat": false, "Optional": false }, { "Types": [2], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [4], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "import-a", "Name": "drawing", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [2], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "import-a", "Name": "pcolors", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [2], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "import-a", "Name": "pcolors-rgb", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [2], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "import-a", "Name": "world", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [2], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "logging", "Name": "all-logs", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [], "ReturnType": { "Types": [4], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "logging", "Name": "clear-logs", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "logging", "Name": "log-globals", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [2], "CanRepeat": true, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "logging", "Name": "log-message", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [2], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "matrix", "Name": "is-matrix?", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [1], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [5], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "matrix", "Name": "regress", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [1], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [4], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "matrix", "Name": "forecast-continuous-growth", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [4], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [4], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "matrix", "Name": "forecast-compound-growth", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [4], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [4], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "matrix", "Name": "forecast-linear-growth", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [4], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [4], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "matrix", "Name": "make-constant", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [3], "CanRepeat": false, "Optional": false }, { "Types": [3], "CanRepeat": false, "Optional": false }, { "Types": [3], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [1], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "matrix", "Name": "dimensions", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [1], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [4], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "matrix", "Name": "det", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [1], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [3], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "matrix", "Name": "rank", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [1], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [3], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "matrix", "Name": "trace", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [1], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [3], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "matrix", "Name": "make-identity", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [3], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [1], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "matrix", "Name": "from-row-list", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [4], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [1], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "matrix", "Name": "from-column-list", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [4], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [1], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "matrix", "Name": "to-row-list", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [1], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [4], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "matrix", "Name": "to-column-list", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [1], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [4], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "matrix", "Name": "copy", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [1], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [1], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "matrix", "Name": "pretty-print-text", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [1], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [2], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "matrix", "Name": "solve", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [1], "CanRepeat": false, "Optional": false }, { "Types": [1], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [1], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "matrix", "Name": "get", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [1], "CanRepeat": false, "Optional": false }, { "Types": [3], "CanRepeat": false, "Optional": false }, { "Types": [3], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [3], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "matrix", "Name": "get-row", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [1], "CanRepeat": false, "Optional": false }, { "Types": [3], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [3], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "matrix", "Name": "get-column", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [1], "CanRepeat": false, "Optional": false }, { "Types": [3], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [3], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "matrix", "Name": "set", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [1], "CanRepeat": false, "Optional": false }, { "Types": [3], "CanRepeat": false, "Optional": false }, { "Types": [3], "CanRepeat": false, "Optional": false }, { "Types": [3], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "matrix", "Name": "set-row", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [1], "CanRepeat": false, "Optional": false }, { "Types": [3], "CanRepeat": false, "Optional": false }, { "Types": [4], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "matrix", "Name": "set-column", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [1], "CanRepeat": false, "Optional": false }, { "Types": [3], "CanRepeat": false, "Optional": false }, { "Types": [4], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "matrix", "Name": "swap-rows", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [1], "CanRepeat": false, "Optional": false }, { "Types": [3], "CanRepeat": false, "Optional": false }, { "Types": [3], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "matrix", "Name": "swap-columns", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [1], "CanRepeat": false, "Optional": false }, { "Types": [3], "CanRepeat": false, "Optional": false }, { "Types": [3], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "matrix", "Name": "set-and-report", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [1], "CanRepeat": false, "Optional": false }, { "Types": [3], "CanRepeat": false, "Optional": false }, { "Types": [3], "CanRepeat": false, "Optional": false }, { "Types": [3], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [1], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "matrix", "Name": "submatrix", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [1], "CanRepeat": false, "Optional": false }, { "Types": [3], "CanRepeat": false, "Optional": false }, { "Types": [3], "CanRepeat": false, "Optional": false }, { "Types": [3], "CanRepeat": false, "Optional": false }, { "Types": [3], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [1], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "matrix", "Name": "map", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [15], "CanRepeat": false, "Optional": false }, { "Types": [1], "CanRepeat": true, "Optional": false }], "ReturnType": { "Types": [1], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "matrix", "Name": "times-scalar", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [1], "CanRepeat": false, "Optional": false }, { "Types": [3], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [1], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "matrix", "Name": "times", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [1], "CanRepeat": false, "Optional": false }, { "Types": [1], "CanRepeat": true, "Optional": false }], "ReturnType": { "Types": [1], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "matrix", "Name": "*", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [1], "CanRepeat": false, "Optional": false }, { "Types": [1], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [1], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "matrix", "Name": "times-element-wise", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [1], "CanRepeat": false, "Optional": false }, { "Types": [1], "CanRepeat": true, "Optional": false }], "ReturnType": { "Types": [1], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "matrix", "Name": "plus-scalar", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [1], "CanRepeat": false, "Optional": false }, { "Types": [3], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [1], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "matrix", "Name": "plus", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [1], "CanRepeat": false, "Optional": false }, { "Types": [1], "CanRepeat": true, "Optional": false }], "ReturnType": { "Types": [1], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "matrix", "Name": "+", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [1], "CanRepeat": false, "Optional": false }, { "Types": [1], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [1], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "matrix", "Name": "minus", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [1], "CanRepeat": false, "Optional": false }, { "Types": [1], "CanRepeat": true, "Optional": false }], "ReturnType": { "Types": [1], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "matrix", "Name": "-", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [1], "CanRepeat": false, "Optional": false }, { "Types": [1], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [1], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "matrix", "Name": "inverse", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [1], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [1], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "matrix", "Name": "transpose", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [1], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [1], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "matrix", "Name": "real-eigenvalues", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [1], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [4], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "matrix", "Name": "imaginary-eigenvalues", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [1], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [4], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "matrix", "Name": "eigenvectors", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [1], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [1], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "mini-csv", "Name": "from-string", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [2], "CanRepeat": true, "Optional": false }], "ReturnType": { "Types": [4], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0, "DefaultOption": 1 }, { "Extension": "mini-csv", "Name": "from-row", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [2], "CanRepeat": true, "Optional": false }], "ReturnType": { "Types": [4], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0, "DefaultOption": 1 }, { "Extension": "mini-csv", "Name": "to-string", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [4], "CanRepeat": false, "Optional": false }, { "Types": [2], "CanRepeat": true, "Optional": false }], "ReturnType": { "Types": [2], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0, "DefaultOption": 1 }, { "Extension": "mini-csv", "Name": "to-row", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [4], "CanRepeat": false, "Optional": false }, { "Types": [2], "CanRepeat": true, "Optional": false }], "ReturnType": { "Types": [2], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0, "DefaultOption": 1 }, { "Extension": "mini-csv", "Name": "__t-context-reporter", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [], "ReturnType": { "Types": [3], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": false, "Turtle": true, "Patch": false, "Link": false }, "Precedence": 0 }, { "Extension": "mini-csv", "Name": "__o-context-command", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": false, "Patch": false, "Link": false }, "Precedence": 0 }, { "Extension": "nettango", "Name": "activate", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [3], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "nettango", "Name": "show", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [3], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "nettango", "Name": "hide", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [3], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "nettango", "Name": "recompile", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "nettango", "Name": "show-blocks", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [1], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "nettango", "Name": "show-blocks-except", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [1], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "nettango", "Name": "hide-blocks", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [1], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "nettango", "Name": "hide-blocks-except", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [1], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "nettango", "Name": "highlight-blocks", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [1], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "nettango", "Name": "highlight-blocks-except", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [1], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "nettango", "Name": "switch-program", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [3], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "nlmap", "Name": "from-list", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [4], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [1], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "nlmap", "Name": "to-list", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [1], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [4], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "nlmap", "Name": "is-map?", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [1], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [5], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "nlmap", "Name": "get", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [1], "CanRepeat": false, "Optional": false }, { "Types": [2], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [1], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "nlmap", "Name": "remove", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [1], "CanRepeat": false, "Optional": false }, { "Types": [2], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [1], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "nlmap", "Name": "add", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [1], "CanRepeat": false, "Optional": false }, { "Types": [2], "CanRepeat": false, "Optional": false }, { "Types": [1], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [1], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "nlmap", "Name": "to-json", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [1], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [2], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "nlmap", "Name": "to-urlenc", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [1], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [2], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "nlmap", "Name": "from-json", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [2], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [1], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "nt", "Name": "get", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [2], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [1], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "nt", "Name": "set", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [2], "CanRepeat": false, "Optional": false }, { "Types": [1], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "palette", "Name": "alpha-of", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [4, 3], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [3], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "palette", "Name": "transparency-of", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [4, 3], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [3], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "palette", "Name": "with-alpha", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [4, 3], "CanRepeat": false, "Optional": false }, { "Types": [3], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [4], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "palette", "Name": "alpha", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [], "ReturnType": { "Types": [3], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "palette", "Name": "transparency", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [], "ReturnType": { "Types": [3], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "palette", "Name": "set-alpha", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [3], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "palette", "Name": "set-transparency", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [3], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "palette", "Name": "with-transparency", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [4, 3], "CanRepeat": false, "Optional": false }, { "Types": [3], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [4], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "palette", "Name": "hue-of", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [4, 3], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [3], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "palette", "Name": "saturation-of", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [4, 3], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [3], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "palette", "Name": "brightness-of", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [4, 3], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [3], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "palette", "Name": "with-hue", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [4, 3], "CanRepeat": false, "Optional": false }, { "Types": [3], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [4], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "palette", "Name": "with-saturation", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [4, 3], "CanRepeat": false, "Optional": false }, { "Types": [3], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [4], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "palette", "Name": "with-brightness", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [4, 3], "CanRepeat": false, "Optional": false }, { "Types": [3], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [4], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "palette", "Name": "hue", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [], "ReturnType": { "Types": [3], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "palette", "Name": "saturation", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [], "ReturnType": { "Types": [3], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "palette", "Name": "brightness", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [], "ReturnType": { "Types": [3], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "palette", "Name": "set-hue", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [3], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "palette", "Name": "set-saturation", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [3], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "palette", "Name": "set-brightness", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [3], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "palette", "Name": "r-of", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [4, 3], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [3], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "palette", "Name": "g-of", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [4, 3], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [3], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "palette", "Name": "b-of", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [4, 3], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [3], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "palette", "Name": "with-r", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [4, 3], "CanRepeat": false, "Optional": false }, { "Types": [3], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [4], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "palette", "Name": "with-g", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [4, 3], "CanRepeat": false, "Optional": false }, { "Types": [3], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [4], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "palette", "Name": "with-b", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [4, 3], "CanRepeat": false, "Optional": false }, { "Types": [3], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [4], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "palette", "Name": "r", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [], "ReturnType": { "Types": [3], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "palette", "Name": "g", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [], "ReturnType": { "Types": [3], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "palette", "Name": "b", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [], "ReturnType": { "Types": [3], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "palette", "Name": "set-r", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [3], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "palette", "Name": "set-g", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [3], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "palette", "Name": "set-b", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [3], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "palette", "Name": "scale-gradient-hsb", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [4], "CanRepeat": false, "Optional": false }, { "Types": [3], "CanRepeat": false, "Optional": false }, { "Types": [3], "CanRepeat": false, "Optional": false }, { "Types": [3], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [4], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "palette", "Name": "scale-gradient", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [4], "CanRepeat": false, "Optional": false }, { "Types": [3], "CanRepeat": false, "Optional": false }, { "Types": [3], "CanRepeat": false, "Optional": false }, { "Types": [3], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [4], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "palette", "Name": "scale-scheme", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [2], "CanRepeat": false, "Optional": false }, { "Types": [2], "CanRepeat": false, "Optional": false }, { "Types": [3], "CanRepeat": false, "Optional": false }, { "Types": [3], "CanRepeat": false, "Optional": false }, { "Types": [3], "CanRepeat": false, "Optional": false }, { "Types": [3], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [4], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "palette", "Name": "scheme-colors", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [2], "CanRepeat": false, "Optional": false }, { "Types": [2], "CanRepeat": false, "Optional": false }, { "Types": [3], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [4], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "phys", "Name": "update", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [3], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": false, "Patch": false, "Link": false }, "Precedence": 0 }, { "Extension": "phys", "Name": "raycast", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [3], "CanRepeat": false, "Optional": false }, { "Types": [3], "CanRepeat": false, "Optional": false }, { "Types": [3], "CanRepeat": false, "Optional": false }, { "Types": [3], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [7], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "phys", "Name": "raycast-all", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [3], "CanRepeat": false, "Optional": false }, { "Types": [3], "CanRepeat": false, "Optional": false }, { "Types": [3], "CanRepeat": false, "Optional": false }, { "Types": [3], "CanRepeat": false, "Optional": false }, { "Types": [2, 20], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "phys", "Name": "pointcast", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [3], "CanRepeat": false, "Optional": false }, { "Types": [3], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [7], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "phys", "Name": "query", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [3], "CanRepeat": false, "Optional": false }, { "Types": [3], "CanRepeat": false, "Optional": false }, { "Types": [3], "CanRepeat": false, "Optional": false }, { "Types": [3], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [7], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "phys", "Name": "turtles-around", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [3], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [7], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": false, "Turtle": true, "Patch": true, "Link": false }, "Precedence": 0 }, { "Extension": "phys", "Name": "turtles-here", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [], "ReturnType": { "Types": [7], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": false, "Turtle": true, "Patch": true, "Link": false }, "Precedence": 0 }, { "Extension": "phys", "Name": "can-move?", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [3], "CanRepeat": true, "Optional": false }], "ReturnType": { "Types": [5], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": false, "Turtle": true, "Patch": false, "Link": false }, "Precedence": 0 }, { "Extension": "phys", "Name": "contacts", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [], "ReturnType": { "Types": [7], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": false, "Turtle": true, "Patch": true, "Link": false }, "Precedence": 0 }, { "Extension": "phys", "Name": "all-contacts", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [2, 20], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": false, "Turtle": true, "Patch": true, "Link": false }, "Precedence": 0 }, { "Extension": "phys", "Name": "contact-end", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [2, 20], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "phys", "Name": "contact-begin", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [2, 20], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "phys", "Name": "contact-end", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [2, 20], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "phys", "Name": "filter-contact", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [2, 20], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "phys", "Name": "show-vector", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [3, 4], "CanRepeat": false, "Optional": false }, { "Types": [3], "CanRepeat": false, "Optional": false }, { "Types": [3], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": false, "Turtle": true, "Patch": true, "Link": false }, "Precedence": 0 }, { "Extension": "phys", "Name": "show-orthogonal", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [3, 4], "CanRepeat": false, "Optional": false }, { "Types": [3], "CanRepeat": false, "Optional": false }, { "Types": [3], "CanRepeat": false, "Optional": false }, { "Types": [5], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": false, "Turtle": true, "Patch": true, "Link": false }, "Precedence": 0 }, { "Extension": "phys", "Name": "hide-vectors", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": false, "Turtle": true, "Patch": true, "Link": false }, "Precedence": 0 }, { "Extension": "phys", "Name": "clear-vectors", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "phys", "Name": "get-type", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [], "ReturnType": { "Types": [3], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": false, "Turtle": true, "Patch": true, "Link": false }, "Precedence": 0 }, { "Extension": "phys", "Name": "set-type", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [3], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": false, "Turtle": true, "Patch": false, "Link": false }, "Precedence": 0 }, { "Extension": "phys", "Name": "get-group", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [], "ReturnType": { "Types": [3], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": false, "Turtle": true, "Patch": true, "Link": false }, "Precedence": 0 }, { "Extension": "phys", "Name": "set-group", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [3], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": false, "Turtle": true, "Patch": true, "Link": false }, "Precedence": 0 }, { "Extension": "phys", "Name": "get-gravity", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [], "ReturnType": { "Types": [3], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "phys", "Name": "set-gravity", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [3], "CanRepeat": false, "Optional": false }, { "Types": [3], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "phys", "Name": "is-physical?", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [], "ReturnType": { "Types": [5], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": false, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "phys", "Name": "set-physical", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [5], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": false, "Turtle": true, "Patch": true, "Link": false }, "Precedence": 0 }, { "Extension": "phys", "Name": "get-friction", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [], "ReturnType": { "Types": [3], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": false, "Turtle": true, "Patch": true, "Link": false }, "Precedence": 0 }, { "Extension": "phys", "Name": "set-friction", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [3], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": false, "Turtle": true, "Patch": true, "Link": false }, "Precedence": 0 }, { "Extension": "phys", "Name": "get-restitution", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [], "ReturnType": { "Types": [3], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": false, "Turtle": true, "Patch": true, "Link": false }, "Precedence": 0 }, { "Extension": "phys", "Name": "set-restitution", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [3], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": false, "Turtle": true, "Patch": true, "Link": false }, "Precedence": 0 }, { "Extension": "phys", "Name": "get-mass", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [], "ReturnType": { "Types": [3], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": false, "Turtle": true, "Patch": false, "Link": false }, "Precedence": 0 }, { "Extension": "phys", "Name": "set-mass", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [3], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": false, "Turtle": true, "Patch": false, "Link": false }, "Precedence": 0 }, { "Extension": "phys", "Name": "get-density", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [], "ReturnType": { "Types": [3], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": false, "Turtle": true, "Patch": false, "Link": false }, "Precedence": 0 }, { "Extension": "phys", "Name": "set-density", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [3], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": false, "Turtle": true, "Patch": false, "Link": false }, "Precedence": 0 }, { "Extension": "phys", "Name": "get-origin", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [], "ReturnType": { "Types": [4], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": false, "Turtle": true, "Patch": false, "Link": false }, "Precedence": 0 }, { "Extension": "phys", "Name": "set-origin", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [3], "CanRepeat": false, "Optional": false }, { "Types": [3], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": false, "Turtle": true, "Patch": false, "Link": false }, "Precedence": 0 }, { "Extension": "phys", "Name": "get-v", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [], "ReturnType": { "Types": [4], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": false, "Turtle": true, "Patch": false, "Link": false }, "Precedence": 0 }, { "Extension": "phys", "Name": "get-vx", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [], "ReturnType": { "Types": [3], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": false, "Turtle": true, "Patch": false, "Link": false }, "Precedence": 0 }, { "Extension": "phys", "Name": "get-vy", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [], "ReturnType": { "Types": [3], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": false, "Turtle": true, "Patch": false, "Link": false }, "Precedence": 0 }, { "Extension": "phys", "Name": "get-a", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [], "ReturnType": { "Types": [4], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": false, "Turtle": true, "Patch": false, "Link": false }, "Precedence": 0 }, { "Extension": "phys", "Name": "set-v", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [3], "CanRepeat": false, "Optional": false }, { "Types": [3], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": false, "Turtle": true, "Patch": false, "Link": false }, "Precedence": 0 }, { "Extension": "phys", "Name": "get-angular-v", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [], "ReturnType": { "Types": [3], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": false, "Turtle": true, "Patch": false, "Link": false }, "Precedence": 0 }, { "Extension": "phys", "Name": "set-angular-v", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [3], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": false, "Turtle": true, "Patch": false, "Link": false }, "Precedence": 0 }, { "Extension": "phys", "Name": "get-angular-a", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [], "ReturnType": { "Types": [3], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": false, "Turtle": true, "Patch": false, "Link": false }, "Precedence": 0 }, { "Extension": "phys", "Name": "get-linear-damping", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [], "ReturnType": { "Types": [3], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": false, "Turtle": true, "Patch": false, "Link": false }, "Precedence": 0 }, { "Extension": "phys", "Name": "set-linear-damping", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [3], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": false, "Turtle": true, "Patch": false, "Link": false }, "Precedence": 0 }, { "Extension": "phys", "Name": "get-angular-damping", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [], "ReturnType": { "Types": [3], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": false, "Turtle": true, "Patch": false, "Link": false }, "Precedence": 0 }, { "Extension": "phys", "Name": "set-angular-damping", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [3], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": false, "Turtle": true, "Patch": false, "Link": false }, "Precedence": 0 }, { "Extension": "phys", "Name": "push", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [3], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": false, "Turtle": true, "Patch": false, "Link": false }, "Precedence": 0 }, { "Extension": "phys", "Name": "apply-force", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [3], "CanRepeat": false, "Optional": false }, { "Types": [3], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": false, "Turtle": true, "Patch": false, "Link": false }, "Precedence": 0 }, { "Extension": "phys", "Name": "apply-torque", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [3], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": false, "Turtle": true, "Patch": false, "Link": false }, "Precedence": 0 }, { "Extension": "phys", "Name": "make-circle", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [5], "CanRepeat": false, "Optional": false }, { "Types": [3], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": false, "Turtle": true, "Patch": false, "Link": false }, "Precedence": 0 }, { "Extension": "phys", "Name": "make-box", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [5], "CanRepeat": false, "Optional": false }, { "Types": [3], "CanRepeat": false, "Optional": false }, { "Types": [3], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": false, "Turtle": true, "Patch": false, "Link": false }, "Precedence": 0 }, { "Extension": "phys", "Name": "make-polygon", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [5], "CanRepeat": false, "Optional": false }, { "Types": [4], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": false, "Turtle": true, "Patch": false, "Link": false }, "Precedence": 0 }, { "Extension": "phys", "Name": "make-edges", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [5], "CanRepeat": false, "Optional": false }, { "Types": [4], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": false, "Turtle": true, "Patch": false, "Link": false }, "Precedence": 0 }, { "Extension": "phys", "Name": "add-circle", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [5], "CanRepeat": false, "Optional": false }, { "Types": [3], "CanRepeat": false, "Optional": false }, { "Types": [3], "CanRepeat": false, "Optional": false }, { "Types": [3], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": false, "Turtle": true, "Patch": false, "Link": false }, "Precedence": 0 }, { "Extension": "phys", "Name": "add-box", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [5], "CanRepeat": false, "Optional": false }, { "Types": [3], "CanRepeat": false, "Optional": false }, { "Types": [3], "CanRepeat": false, "Optional": false }, { "Types": [3], "CanRepeat": false, "Optional": false }, { "Types": [3], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": false, "Turtle": true, "Patch": false, "Link": false }, "Precedence": 0 }, { "Extension": "phys", "Name": "add-polygon", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [5], "CanRepeat": false, "Optional": false }, { "Types": [4], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": false, "Turtle": true, "Patch": false, "Link": false }, "Precedence": 0 }, { "Extension": "phys", "Name": "add-edges", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [5], "CanRepeat": false, "Optional": false }, { "Types": [4], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": false, "Turtle": true, "Patch": false, "Link": false }, "Precedence": 0 }, { "Extension": "phys", "Name": "detach-joint", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": false, "Turtle": false, "Patch": false, "Link": true }, "Precedence": 0 }, { "Extension": "phys", "Name": "distance-joint", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": false, "Turtle": false, "Patch": false, "Link": true }, "Precedence": 0 }, { "Extension": "phys", "Name": "distance-joint-anchored", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [3], "CanRepeat": false, "Optional": false }, { "Types": [3], "CanRepeat": false, "Optional": false }, { "Types": [3], "CanRepeat": false, "Optional": false }, { "Types": [3], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": false, "Turtle": false, "Patch": false, "Link": true }, "Precedence": 0 }, { "Extension": "phys", "Name": "mouse-joint", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": false, "Turtle": false, "Patch": false, "Link": true }, "Precedence": 0 }, { "Extension": "phys", "Name": "get-length", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [], "ReturnType": { "Types": [3], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": false, "Turtle": false, "Patch": false, "Link": true }, "Precedence": 0 }, { "Extension": "phys", "Name": "set-length", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [3], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": false, "Turtle": false, "Patch": false, "Link": true }, "Precedence": 0 }, { "Extension": "phys", "Name": "set-lengths", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [3], "CanRepeat": false, "Optional": false }, { "Types": [3], "CanRepeat": false, "Optional": false }, { "Types": [3], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": false, "Turtle": false, "Patch": false, "Link": true }, "Precedence": 0 }, { "Extension": "phys", "Name": "set-linear-stiffness", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [3], "CanRepeat": false, "Optional": false }, { "Types": [3], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": false, "Turtle": false, "Patch": false, "Link": true }, "Precedence": 0 }, { "Extension": "phys", "Name": "set-damping", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [3], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": false, "Turtle": false, "Patch": false, "Link": true }, "Precedence": 0 }, { "Extension": "phys", "Name": "get-damping", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [], "ReturnType": { "Types": [3], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": false, "Turtle": false, "Patch": false, "Link": true }, "Precedence": 0 }, { "Extension": "phys", "Name": "set-stiffness", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [3], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": false, "Turtle": false, "Patch": false, "Link": true }, "Precedence": 0 }, { "Extension": "phys", "Name": "get-stiffness", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [], "ReturnType": { "Types": [3], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": false, "Turtle": false, "Patch": false, "Link": true }, "Precedence": 0 }, { "Extension": "phys", "Name": "set-max-force", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [3], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": false, "Turtle": false, "Patch": false, "Link": true }, "Precedence": 0 }, { "Extension": "phys", "Name": "get-max-force", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [], "ReturnType": { "Types": [3], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": false, "Turtle": false, "Patch": false, "Link": true }, "Precedence": 0 }, { "Extension": "phys", "Name": "set-max-torque", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [3], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": false, "Turtle": false, "Patch": false, "Link": true }, "Precedence": 0 }, { "Extension": "phys", "Name": "get-max-torque", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [], "ReturnType": { "Types": [3], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": false, "Turtle": false, "Patch": false, "Link": true }, "Precedence": 0 }, { "Extension": "phys", "Name": "get-force", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [], "ReturnType": { "Types": [4], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": false, "Turtle": false, "Patch": false, "Link": true }, "Precedence": 0 }, { "Extension": "phys", "Name": "get-torque", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [], "ReturnType": { "Types": [3], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": false, "Turtle": false, "Patch": false, "Link": true }, "Precedence": 0 }, { "Extension": "plot", "Name": "show", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [2], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "plot", "Name": "hide", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [2], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "plot", "Name": "activate", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [2], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "plot", "Name": "move", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [2], "CanRepeat": false, "Optional": false }, { "Types": [3], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "plot", "Name": "set-title", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [2], "CanRepeat": false, "Optional": false }, { "Types": [2], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "plot", "Name": "bind", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [2], "CanRepeat": false, "Optional": false }, { "Types": [2], "CanRepeat": false, "Optional": false }, { "Types": [5], "CanRepeat": false, "Optional": false }, { "Types": [2, 20], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "plot", "Name": "unbind", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [2], "CanRepeat": false, "Optional": false }, { "Types": [2], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "send-to", "Name": "file", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [2], "CanRepeat": false, "Optional": false }, { "Types": [2], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "sensor", "Name": "clear", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "sensor", "Name": "bind-gesture", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [2], "CanRepeat": false, "Optional": false }, { "Types": [2, 20], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "sensor", "Name": "unbind-gesture", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [2], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "sensor", "Name": "touches", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [], "ReturnType": { "Types": [4], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "sensor", "Name": "touch-size", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [], "ReturnType": { "Types": [3], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "sensor", "Name": "touch", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [3], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [4], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "sensor", "Name": "open", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [2], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "sensor", "Name": "close", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [2], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "sensor", "Name": "on-change", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [2], "CanRepeat": false, "Optional": false }, { "Types": [2, 20], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "sensor", "Name": "read-number", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [2], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [3], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "sensor", "Name": "read-vector", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [2], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [4], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "sensor", "Name": "is-available?", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [2], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [5], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "sensor", "Name": "set-warning", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [5], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "sound", "Name": "drums", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [], "ReturnType": { "Types": [4], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "sound", "Name": "instruments", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [], "ReturnType": { "Types": [4], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "sound", "Name": "play-drum", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [2], "CanRepeat": false, "Optional": false }, { "Types": [3], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "sound", "Name": "play-note", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [2], "CanRepeat": false, "Optional": false }, { "Types": [3], "CanRepeat": false, "Optional": false }, { "Types": [3], "CanRepeat": false, "Optional": false }, { "Types": [3], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "sound", "Name": "play-note-later", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [3], "CanRepeat": false, "Optional": false }, { "Types": [2], "CanRepeat": false, "Optional": false }, { "Types": [3], "CanRepeat": false, "Optional": false }, { "Types": [3], "CanRepeat": false, "Optional": false }, { "Types": [3], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "sound", "Name": "start-note", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [2], "CanRepeat": false, "Optional": false }, { "Types": [3], "CanRepeat": false, "Optional": false }, { "Types": [3], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "sound", "Name": "stop-note", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [2], "CanRepeat": false, "Optional": false }, { "Types": [3], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "sound", "Name": "stop-instrument", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [2], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "sound", "Name": "stop-music", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "store", "Name": "list-stores", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [20], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "store", "Name": "switch-store", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [2], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "store", "Name": "delete-store", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [2], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "store", "Name": "put", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [2], "CanRepeat": false, "Optional": false }, { "Types": [2], "CanRepeat": false, "Optional": false }, { "Types": [12], "CanRepeat": false, "Optional": true }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "store", "Name": "get", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [2], "CanRepeat": false, "Optional": false }, { "Types": [20], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "store", "Name": "get-keys", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [20], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "store", "Name": "has-key", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [2], "CanRepeat": false, "Optional": false }, { "Types": [20], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "store", "Name": "remove", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [2], "CanRepeat": false, "Optional": false }, { "Types": [12], "CanRepeat": false, "Optional": true }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "store", "Name": "clear", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [12], "CanRepeat": false, "Optional": true }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "string", "Name": "explode", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [2], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [4], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "string", "Name": "from-file", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [2], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [2], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "string", "Name": "from-list", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [4], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [2], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "string", "Name": "hash-code", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [2], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [3], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "string", "Name": "md5", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [2], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [2], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "string", "Name": "message-digest-5", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [2], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [2], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "string", "Name": "rex-match?", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [2], "CanRepeat": false, "Optional": false }, { "Types": [2], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [5], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "string", "Name": "rex-replace-first", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [2], "CanRepeat": false, "Optional": false }, { "Types": [2], "CanRepeat": false, "Optional": false }, { "Types": [2], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [2], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "string", "Name": "rex-replace-all", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [2], "CanRepeat": false, "Optional": false }, { "Types": [2], "CanRepeat": false, "Optional": false }, { "Types": [2], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [2], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "string", "Name": "rex-split", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [2], "CanRepeat": false, "Optional": false }, { "Types": [2], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [4], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "string", "Name": "starts-with?", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [2], "CanRepeat": false, "Optional": false }, { "Types": [2], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [5], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "string", "Name": "ends-with?", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [2], "CanRepeat": false, "Optional": false }, { "Types": [2], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [5], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "string", "Name": "trim", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [2], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [2], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "string", "Name": "upper-case", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [2], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [2], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "string", "Name": "lower-case", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [2], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [2], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "string", "Name": "split-on", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [2], "CanRepeat": false, "Optional": false }, { "Types": [2], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [4], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "table", "Name": "is-table?", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [1], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [5], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "table", "Name": "clear", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [1], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "table", "Name": "counts", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [4], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [1], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "table", "Name": "group-agents", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [7], "CanRepeat": false, "Optional": false }, { "Types": [15], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [1], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "table", "Name": "group-items", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [4], "CanRepeat": false, "Optional": false }, { "Types": [15], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [1], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "table", "Name": "from-list", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [4], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [1], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "table", "Name": "get", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [1], "CanRepeat": false, "Optional": false }, { "Types": [1], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [1], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "table", "Name": "get-or-default", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [4], "CanRepeat": false, "Optional": false }, { "Types": [1], "CanRepeat": false, "Optional": false }, { "Types": [1], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [1], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "table", "Name": "has-key?", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [1], "CanRepeat": false, "Optional": false }, { "Types": [1], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [5], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "table", "Name": "keys", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [1], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [4], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "table", "Name": "length", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [1], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [3], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "table", "Name": "make", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [], "ReturnType": { "Types": [1], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "table", "Name": "put", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [1], "CanRepeat": false, "Optional": false }, { "Types": [1], "CanRepeat": false, "Optional": false }, { "Types": [1], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "table", "Name": "remove", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [1], "CanRepeat": false, "Optional": false }, { "Types": [1], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "table", "Name": "to-list", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [1], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [4], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "table", "Name": "values", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [1], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [4], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "table", "Name": "to-json", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [1], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [2], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "table", "Name": "from-json", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [2], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [1], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "tune", "Name": "drums", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [], "ReturnType": { "Types": [4], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "tune", "Name": "instruments", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [], "ReturnType": { "Types": [4], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "tune", "Name": "use", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [2, 3], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "tune", "Name": "tempo", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [3], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "tune", "Name": "note", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [3], "CanRepeat": true, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "tune", "Name": "rest", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [3], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "tune", "Name": "loop", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "tune", "Name": "once", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "tune", "Name": "loop-then", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [2, 20], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "tune", "Name": "once-then", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [2, 20], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "tune", "Name": "who", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [], "ReturnType": { "Types": [3], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "tune", "Name": "volume", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [3], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "tune", "Name": "moveto", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [3], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "tune", "Name": "rewind", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [3], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "tune", "Name": "forward", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [3], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "tune", "Name": "play-at", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [3], "CanRepeat": false, "Optional": false }, { "Types": [3], "CanRepeat": true, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "tune", "Name": "play-here", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": false, "Turtle": true, "Patch": true, "Link": false }, "Precedence": 0 }, { "Extension": "tune", "Name": "clear", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "tune", "Name": "stop", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [3], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "tutorial", "Name": "show-dialog", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [2], "CanRepeat": false, "Optional": false }, { "Types": [5], "CanRepeat": true, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "tutorial", "Name": "minimize-dialog", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [2], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "tutorial", "Name": "hide-dialog", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [2], "CanRepeat": true, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "tutorial", "Name": "back-dialog", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "tutorial", "Name": "submit-input", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [5], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "tutorial", "Name": "set", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [2], "CanRepeat": false, "Optional": false }, { "Types": [1], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "tutorial", "Name": "get", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [2], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [1], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "tutorial", "Name": "activate", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [2], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "tutorial", "Name": "deactivate", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [2], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "tutorial", "Name": "get-activated", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [], "ReturnType": { "Types": [5], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "tutorial", "Name": "is-activated?", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [2], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [5], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "tutorial", "Name": "go", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [2], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "tutorial", "Name": "forward", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "tutorial", "Name": "back", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "tutorial", "Name": "survey", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [2], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "tutorial", "Name": "in-tutorial?", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [], "ReturnType": { "Types": [5], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "widget", "Name": "toast", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [2], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "widget", "Name": "show", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [2], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "widget", "Name": "hide", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [2], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "widget", "Name": "move", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [2], "CanRepeat": false, "Optional": false }, { "Types": [3], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "widget", "Name": "set-title", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [2], "CanRepeat": false, "Optional": false }, { "Types": [2], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "widget", "Name": "bind", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [2], "CanRepeat": false, "Optional": false }, { "Types": [2], "CanRepeat": false, "Optional": false }, { "Types": [5], "CanRepeat": false, "Optional": false }, { "Types": [2, 20], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "widget", "Name": "unbind", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [2], "CanRepeat": false, "Optional": false }, { "Types": [2], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "widget", "Name": "set-group", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [2], "CanRepeat": false, "Optional": false }, { "Types": [2], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "widget", "Name": "show-group", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [2], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "widget", "Name": "hide-group", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [2], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "widget", "Name": "move-group", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [2], "CanRepeat": false, "Optional": false }, { "Types": [3], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "widget", "Name": "rename-group", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [2], "CanRepeat": false, "Optional": false }, { "Types": [2], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "widget", "Name": "show-joystick", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "widget", "Name": "hide-joystick", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "widget", "Name": "bind-joystick", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [2], "CanRepeat": false, "Optional": false }, { "Types": [2], "CanRepeat": false, "Optional": false }, { "Types": [2], "CanRepeat": false, "Optional": false }, { "Types": [2], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "widget", "Name": "joystick-x", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [], "ReturnType": { "Types": [3], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "widget", "Name": "joystick-y", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [], "ReturnType": { "Types": [3], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "workspace", "Name": "pause", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "workspace", "Name": "play", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "workspace", "Name": "show", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [2], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "workspace", "Name": "hide", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [2], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "workspace", "Name": "set-speed", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [3], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "workspace", "Name": "get-speed", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [], "ReturnType": { "Types": [3], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "workspace", "Name": "get-platform", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [], "ReturnType": { "Types": [2], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "workspace", "Name": "id", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [], "ReturnType": { "Types": [2], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "workspace", "Name": "recompile", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "workspace", "Name": "trigger", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [2], "CanRepeat": false, "Optional": false }, { "Types": [1], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "workspace", "Name": "bind", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [2, 3], "CanRepeat": false, "Optional": false }, { "Types": [2], "CanRepeat": false, "Optional": false }, { "Types": [5], "CanRepeat": false, "Optional": false }, { "Types": [2, 20], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "workspace", "Name": "unbind", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [2, 3], "CanRepeat": false, "Optional": false }, { "Types": [2], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "workspace", "Name": "unbind-all", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "workspace", "Name": "clear-commands", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "workspace", "Name": "execute-command", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [2], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "xr", "Name": "is-supported?", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [], "ReturnType": { "Types": [5], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "xr", "Name": "is-on?", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [], "ReturnType": { "Types": [5], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "xr", "Name": "start", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "xr", "Name": "stop", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "xr", "Name": "get-gravity", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [], "ReturnType": { "Types": [4], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "xr", "Name": "get-scale", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [], "ReturnType": { "Types": [3], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "xr", "Name": "set-scale", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [3], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "xr", "Name": "xcor", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [], "ReturnType": { "Types": [3], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "xr", "Name": "ycor", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [], "ReturnType": { "Types": [3], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "xr", "Name": "zcor", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [], "ReturnType": { "Types": [3], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "xr", "Name": "dx", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [], "ReturnType": { "Types": [3], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "xr", "Name": "dy", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [], "ReturnType": { "Types": [3], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "xr", "Name": "heading", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [], "ReturnType": { "Types": [3], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "xr", "Name": "colorize-wireframes", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [4, 3], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "xr", "Name": "show-wireframes", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "xr", "Name": "hide-wireframes", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "xr", "Name": "colorize-wireframe", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [2], "CanRepeat": false, "Optional": false }, { "Types": [4, 3], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "xr", "Name": "show-wireframe", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [2], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "xr", "Name": "hide-wireframe", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [2], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "xr", "Name": "room-scan", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [2, 20], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": false, "Patch": false, "Link": false }, "Precedence": 0 }, { "Extension": "xr", "Name": "is-room-scan-supported?", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [3], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [5], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "xr", "Name": "scans", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [], "ReturnType": { "Types": [4], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "xr", "Name": "current-scan", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [], "ReturnType": { "Types": [2], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "xr", "Name": "use-scan", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [2], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": false, "Patch": false, "Link": false }, "Precedence": 0 }, { "Extension": "xr", "Name": "resize-world", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [3], "CanRepeat": true, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": false, "Patch": false, "Link": false }, "Precedence": 0 }, { "Extension": "xr", "Name": "get-dimensions", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [], "ReturnType": { "Types": [4], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "xr", "Name": "iterate-as-patches", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [2, 20], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "xr", "Name": "iterate-as-turtles", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [2, 20], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [0], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }, { "Extension": "xr", "Name": "inside-scan?", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [], "ReturnType": { "Types": [5], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": false, "Turtle": true, "Patch": true, "Link": false }, "Precedence": 0 }, { "Extension": "xr", "Name": "color-of", "LeftArgumentType": { "Types": [0], "CanRepeat": false, "Optional": false }, "RightArgumentTypes": [{ "Types": [2], "CanRepeat": false, "Optional": false }, { "Types": [2], "CanRepeat": false, "Optional": false }], "ReturnType": { "Types": [3], "CanRepeat": false, "Optional": false }, "AgentContext": { "Observer": true, "Turtle": true, "Patch": true, "Link": true }, "Precedence": 0 }];

// src/lang/primitives/primitives.ts
var Primitives = class _Primitives {
  constructor() {
    /** Metadata: The dictionary for metadata. */
    this.Metadata = /* @__PURE__ */ new Map();
    /** Extensions: The dictionary for extensions. */
    this.Extensions = /* @__PURE__ */ new Map();
    /** ExtensionNames: The list for known extensions. */
    this.ExtensionNames = [];
  }
  /** Register: Register a primitive information. */
  Register(Extension2, Source) {
    var FullName = Extension2 == "" ? Source.Name : `${Extension2}:${Source.Name}`;
    if (!this.Metadata.has(FullName)) {
      if (this.ExtensionNames.indexOf(Extension2) == -1) {
        this.ExtensionNames.push(Extension2);
        this.Extensions.set(Extension2, []);
      }
      this.Extensions.get(Extension2).push(Source);
      this.Metadata.set(FullName, Source);
    }
  }
  /** BuildInstance: Build a primitive manager instance. */
  static BuildInstance() {
    var Result = new _Primitives();
    Dataset.forEach((Primitive2) => {
      Result.Register(Primitive2.Extension, Primitive2);
    });
    return Result;
  }
  /** GetPrimitive: Get a primitive from an extension. */
  GetPrimitive(Extension2, Name) {
    var FullName = Extension2 == "" ? Name : `${Extension2}:${Name}`;
    return this.Metadata.get(FullName) ?? null;
  }
  /** HasNPrimitive: Is there a named primitive. */
  HasPrimitive(Extension2, Name) {
    var FullName = Extension2 == "" ? Name : `${Extension2}:${Name}`;
    return this.Metadata.has(FullName);
  }
  /** GetNamedPrimitive: Get a named primitive. */
  GetNamedPrimitive(FullName) {
    return this.Metadata.get(FullName) ?? null;
  }
  /** HasNamedPrimitive: Is there a named primitive. */
  HasNamedPrimitive(FullName) {
    return this.Metadata.has(FullName);
  }
  /** IsReporter: Is the primitive a reporter. */
  IsReporter(Source) {
    return Source.ReturnType.Types[0] != 0 /* Unit */;
  }
  /** GetExtensions: Get the names of extensions. */
  GetExtensions() {
    return this.ExtensionNames;
  }
  /** GetCompletions: Get a proper completion list for primitives. */
  GetCompletions(Extensions) {
    var Results = [];
    for (var Primitive2 of this.Metadata.values()) {
      if (Primitive2.Extension == "" || Extensions.indexOf(Primitive2.Extension) != -1) {
        var Name = Primitive2.Name;
        if (Primitive2.Extension != "") Name = `${Primitive2.Extension}:${Name}`;
        Results.push({
          label: Name,
          type: this.IsReporter(Primitive2) ? "Reporter" : "Command"
        });
      }
    }
    return Results;
  }
};
var PrimitiveManager = Primitives.BuildInstance();
try {
  window.PrimitiveManager = Primitives;
} catch (error) {
}

// src/utils/debug-utils.ts
var Global = typeof globalThis === "undefined" ? window : globalThis;
var Log = Global.GalapagosSilent ? () => {
} : console.log;
if (!String.prototype.trimStart)
  String.prototype.trimStart = function() {
    return this.replace(
      new RegExp(
        "^" + /[\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF]+/.source,
        "g"
      ),
      ""
    );
  };
if (!String.prototype.trimEnd)
  String.prototype.trimEnd = function() {
    return this.replace(
      new RegExp(
        /[\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF]+/.source + "$",
        "g"
      ),
      ""
    );
  };

// src/lang/utils/cursors.ts
import { syntaxTree as syntaxTree2 } from "@codemirror/language";
function GetCursorUntilMode(State) {
  const Cursor = syntaxTree2(State).cursor();
  if (!Cursor.firstChild()) return null;
  while (Cursor.node.name == "LineComment") Cursor.nextSibling();
  return Cursor;
}
function GetCursorInsideMode(State) {
  const Cursor = GetCursorUntilMode(State);
  if (!(Cursor == null ? void 0 : Cursor.firstChild())) return null;
  return Cursor;
}

// src/lang/utils/code.ts
var getNodeContext = function(State, Node) {
  let curr_node = Node;
  while (curr_node) {
    if (curr_node.name == "Procedure" || curr_node.name == "Extensions" || curr_node.name == "Globals" || curr_node.name == "Breed" || curr_node.name == "BreedsOwn")
      return State.sliceDoc(curr_node.from, curr_node.to);
    curr_node = curr_node.parent;
  }
  return State.sliceDoc(Node.from, Node.to);
};
var getCodeName = function(State, Node) {
  return State.sliceDoc(Node.from, Node.to).trim().toLowerCase();
};
var getParentProcedure = function(State, Node) {
  let curr_node = Node;
  while (curr_node.parent) {
    curr_node = curr_node.parent;
    if (curr_node.name == "Procedure") {
      var children = curr_node.getChildren("ProcedureName");
      if (children.length > 0) return getCodeName(State, children[0]);
    }
  }
  return void 0;
};

// src/lang/classes/contexts.ts
var PreprocessContext = class {
  constructor() {
    /** PluralBreeds: Breeds in the model. */
    this.PluralBreeds = /* @__PURE__ */ new Map();
    /** SingularBreeds: Singular breeds in the model. */
    this.SingularBreeds = /* @__PURE__ */ new Map();
    /** SingularToPlurals: Singular-to-plural mappings in the model. */
    this.SingularToPlurals = /* @__PURE__ */ new Map();
    /** PluralToSingulars: Plural-to-singular mappings in the model. */
    this.PluralToSingulars = /* @__PURE__ */ new Map();
    /** SpecialReporters: Reporter-to-plural mappings in the model. */
    this.SpecialReporters = /* @__PURE__ */ new Map();
    /** BreedTypes: Breed types in the model. */
    this.BreedTypes = /* @__PURE__ */ new Map();
    /** BreedVars: Breed variables in the model. */
    this.BreedVars = /* @__PURE__ */ new Map();
    /** BreedVarToPlurals: Breed variable-plural mappings in the model. */
    this.BreedVarToPlurals = /* @__PURE__ */ new Map();
    /** Commands: Commands in the model with number of arguments. */
    this.Commands = /* @__PURE__ */ new Map();
    /** Reporters: Reporters in the model with number of arguments. */
    this.Reporters = /* @__PURE__ */ new Map();
    /** CommandsOrigin: Commands in the model with editor ID. */
    this.CommandsOrigin = /* @__PURE__ */ new Map();
    /** ReportersOrigin: Reporters in the model with editor ID. */
    this.ReportersOrigin = /* @__PURE__ */ new Map();
  }
  /** Clear: Clear the context. */
  Clear() {
    this.PluralBreeds.clear();
    this.SingularBreeds.clear();
    this.BreedTypes.clear();
    this.BreedVars.clear();
    this.BreedVarToPlurals.clear();
    this.Commands.clear();
    this.Reporters.clear();
    this.CommandsOrigin.clear();
    this.ReportersOrigin.clear();
    this.SpecialReporters.clear();
    return this;
  }
  /** GetBreedContext: Get the context for a breed. */
  GetBreedContext(Name, IsVariable) {
    var Type = this.BreedTypes.get(Name);
    if (typeof Type === "undefined") return new AgentContexts("O---");
    if (Type == 3 /* DirectedLink */ || Type == 2 /* UndirectedLink */) {
      return new AgentContexts("---L");
    } else if (Type == 1 /* Patch */) {
      if (IsVariable) {
        return new AgentContexts("-TP-");
      } else {
        return new AgentContexts("--P-");
      }
    } else {
      return new AgentContexts("-T--");
    }
  }
  GetSuperType(Name) {
    var Type = this.BreedTypes.get(Name);
    if (Type == 1 /* Patch */) return "patches";
    else if (Type == 0 /* Turtle */) return "turtles";
    else if (Type == 3 /* DirectedLink */ || Type == 2 /* UndirectedLink */) return "links";
    return null;
  }
  /** GetBreedVariableContexts: Get the context for a breed variable. */
  GetBreedVariableContexts(Name) {
    if (this.BreedVarToPlurals.has(Name)) {
      let breeds = this.BreedVarToPlurals.get(Name);
      if (breeds && breeds.length > 0) {
        let context = new AgentContexts();
        for (let b of breeds) {
          context = combineContexts(context, this.GetBreedContext(b, true));
        }
        return context;
      }
    }
  }
  /** GetReporterBreed: Get the breed for a reporter. */
  GetReporterBreed(Name) {
    if (this.SpecialReporters.size == 0) {
      for (let [Plural, Type] of this.BreedTypes) {
        switch (Type) {
          case 0 /* Turtle */:
            this.SpecialReporters.set(Plural, Plural);
            this.SpecialReporters.set(Plural + "-at", Plural);
            this.SpecialReporters.set(Plural + "-here", Plural);
            this.SpecialReporters.set(Plural + "-on", Plural);
            break;
          case 1 /* Patch */:
            this.SpecialReporters.set("patch-at", Plural);
            this.SpecialReporters.set("patch-here", Plural);
            this.SpecialReporters.set("patch-ahead", Plural);
            this.SpecialReporters.set("patch-at-heading-and-distance", Plural);
            this.SpecialReporters.set("patch-left-and-ahead", Plural);
            this.SpecialReporters.set("patch-right-and-ahead", Plural);
            this.SpecialReporters.set("neighbors", Plural);
            this.SpecialReporters.set("neighbors4", Plural);
            break;
          case 2 /* UndirectedLink */:
          case 3 /* DirectedLink */:
            var Singular = this.PluralToSingulars.get(Plural);
            this.SpecialReporters.set("link-at", Plural);
            this.SpecialReporters.set("out-" + Singular + "-to", Plural);
            this.SpecialReporters.set("in-" + Singular + "-from", Plural);
            this.SpecialReporters.set("my-" + Plural, Plural);
            this.SpecialReporters.set("my-in-" + Plural, Plural);
            this.SpecialReporters.set("my-out-" + Plural, Plural);
            this.SpecialReporters.set(Singular + "-with", Plural);
            this.SpecialReporters.set("out-" + Singular + "-neighbors", "turtles");
            this.SpecialReporters.set("in-" + Singular + "-neighbors", "turtles");
            this.SpecialReporters.set(Singular + "-neighbors", "turtles");
            break;
        }
      }
      return this.SpecialReporters.get(Name);
    }
  }
};
var LintContext = class {
  constructor() {
    /** Extensions: Extensions in the code. */
    this.Extensions = /* @__PURE__ */ new Map();
    /** Globals: Globals in the code. */
    this.Globals = /* @__PURE__ */ new Map();
    /** WidgetGlobals: Globals from the widgets. */
    this.WidgetGlobals = /* @__PURE__ */ new Map();
    /** Breeds: Breeds in the code. */
    this.Breeds = /* @__PURE__ */ new Map();
    /** Procedures: Procedures in the code. */
    this.Procedures = /* @__PURE__ */ new Map();
  }
  /** Clear: Clear the context. */
  Clear() {
    this.Extensions.clear();
    this.Globals.clear();
    this.WidgetGlobals.clear();
    this.Breeds.clear();
    this.Procedures.clear();
    return this;
  }
  /** GetDefined: Get defined names. */
  GetDefined() {
    var defined = [];
    defined.push(...this.Globals.keys());
    defined.push(...this.WidgetGlobals.keys());
    defined.push(...this.Procedures.keys());
    defined.push(...this.GetBreedNames());
    defined.push(...this.GetBreedVariables());
    return defined;
  }
  /** GetBreedNames: Get names related to breeds. */
  GetBreedNames() {
    var breedNames = [];
    for (let breed of this.Breeds.values()) {
      breedNames.push(breed.Singular);
      breedNames.push(breed.Plural);
    }
    return breedNames;
  }
  /** GetPluralBreedNames: Get plural names related to breeds. */
  GetPluralBreedNames() {
    var breedNames = [];
    for (let breed of this.Breeds.values()) breedNames.push(breed.Plural);
    return breedNames;
  }
  /** GetBreedVariables: Get variable names related to breeds. */
  GetBreedVariables() {
    var variables = [];
    for (let breed of this.Breeds.values()) variables = variables.concat(breed.Variables);
    return variables;
  }
  /** GetBreeds: Get list of breeds. */
  GetBreeds() {
    var breedList = [];
    for (let breed of this.Breeds.values()) {
      breedList.push(breed);
    }
    return breedList;
  }
  /** GetBreedFromVariable: Find the breed which defines a certain variable. */
  GetBreedFromVariable(varName) {
    for (let breed of this.Breeds.values()) {
      if (breed.Variables.includes(varName)) return breed.Plural;
    }
    return null;
  }
  checkCodeBlocks(varName, blocks, proc_name, from, to) {
    for (let b of blocks) {
      if (b.PositionEnd < from || b.PositionStart > to) continue;
      for (let localVar of b.Variables) {
        if (localVar.Name == varName && localVar.CreationPos <= to) return proc_name;
      }
      let other = this.checkCodeBlocks(varName, b.CodeBlocks, proc_name, from, to);
      if (other != null) {
        return other;
      }
      let anon = this.checkAnonProc(varName, b.AnonymousProcedures, proc_name, from, to);
      if (anon != null) {
        return anon;
      }
    }
    return null;
  }
  checkAnonProc(varName, anon, proc_name, from, to) {
    for (let anonProc of anon) {
      if (anonProc.PositionEnd < from || anonProc.PositionStart > to) continue;
      if (anonProc.Arguments.includes(varName)) return "{anonymous}," + proc_name;
      for (let localVar of anonProc.Variables) {
        if (localVar.Name == varName && localVar.CreationPos <= to) return "{anonymous}," + proc_name;
      }
    }
    return null;
  }
  /** GetProcedureFromVariable: Find the procedure that defines a certain variable. */
  GetProcedureFromVariable(varName, from, to) {
    for (let proc of this.Procedures.values()) {
      if (proc.PositionEnd < from || proc.PositionStart > to) continue;
      if (proc.Arguments.includes(varName)) return proc.Name;
      for (let localVar of proc.Variables) {
        if (localVar.Name == varName && localVar.CreationPos <= to) return proc.Name;
      }
      let anon = this.checkAnonProc(varName, proc.AnonymousProcedures, proc.Name, from, to);
      if (anon != null) {
        return anon;
      }
      let other = this.checkCodeBlocks(varName, proc.CodeBlocks, proc.Name, from, to);
      if (other != null) {
        return other;
      }
    }
    return null;
  }
};

// src/codemirror/extension-state-netlogo.ts
import { syntaxTree as syntaxTree3 } from "@codemirror/language";

// src/lang/lang.terms.js
var ReporterLeft1Args = 1;
var ReporterLeft2Args = 2;
var ReporterLeft1ArgsOpt = 3;
var GlobalStr = 4;
var ExtensionStr = 5;
var BreedStr = 6;
var Own = 7;
var Set2 = 8;
var Let = 9;
var To = 10;
var End = 11;
var Identifier = 12;
var Command = 13;
var Reporter = 14;
var TurtleVar = 15;
var PatchVar = 16;
var LinkVar = 17;
var Constant = 18;
var SpecialReporter = 20;
var SpecialCommand = 21;
var BreedToken = 22;
var AndOr = 23;
var APCommand = 24;
var APReporterFlip = 25;
var APReporterVar = 26;
var APReporter = 27;
var UnsupportedPrim = 28;
var SpecialCommandCreateTurtle = 29;
var SpecialCommandCreateLink = 30;
var SpecialReporter1ArgsBoth = 31;
var SpecialReporter0ArgsLink = 32;
var SpecialReporter1ArgsLink = 33;
var SpecialReporter2ArgsTurtle = 34;
var SpecialReporter0ArgsTurtle = 35;
var SpecialReporter1ArgsTurtle = 36;
var SpecialReporter0ArgsLinkP = 37;
var SpecialCommandCreateTurtlePossible = 38;
var Reporter0Args = 39;
var Reporter1Args = 40;
var Reporter2Args = 41;
var Reporter3Args = 42;
var Reporter4Args = 43;
var Reporter5Args = 44;
var Reporter6Args = 45;
var Reporter0ArgsVar = 46;
var Reporter1ArgsVar = 47;
var Reporter2ArgsVar = 48;
var Reporter3ArgsVar = 49;
var Reporter4ArgsVar = 50;
var Reporter5ArgsVar = 51;
var Reporter6ArgsVar = 52;
var Reporter2ArgsVar0 = 53;
var Reporter1ArgsVar0 = 54;
var SpecialReporter0Args = 55;
var SpecialReporter1Args = 56;
var SpecialReporter2Args = 57;
var SpecialReporter3Args = 58;
var SpecialReporter4Args = 59;
var SpecialReporter5Args = 60;
var SpecialReporter6Args = 61;
var Command0Args = 62;
var Command1Args = 63;
var Command2Args = 64;
var Command3Args = 65;
var Command4Args = 66;
var Command5Args = 67;
var Command6Args = 68;
var Command0ArgsVar = 69;
var Command1ArgsVar = 70;
var Command2ArgsVar = 71;
var Command3ArgsVar = 72;
var Command4ArgsVar = 73;
var Command5ArgsVar = 74;
var Command6ArgsVar = 75;
var Command3ArgsVar2 = 76;
var Command1_2ArgsOpt = 77;
var SpecialCommand0Args = 78;
var SpecialCommand1Args = 79;
var SpecialCommand2Args = 80;
var SpecialCommand3Args = 81;
var SpecialCommand4Args = 82;
var SpecialCommand5Args = 83;
var SpecialCommand6Args = 84;

// src/lang/parsers/breed.ts
var BreedStatementRules = [
  {
    Match: /^(.*?)-own$/,
    Singular: false,
    Tag: Own,
    Type: void 0,
    Position: 0,
    String: ["<breed>-own"],
    Context: new AgentContexts("O---"),
    isCommand: false
  },
  {
    Match: /^(.*?)-(at)$/,
    Singular: false,
    Tag: SpecialReporter2ArgsTurtle,
    Type: 0 /* Turtle */,
    Position: 0,
    String: ["<breed>-at"],
    Context: new AgentContexts("-TPL"),
    isCommand: false
  },
  {
    Match: /^(.*?)-(here)$/,
    Singular: false,
    Tag: SpecialReporter0ArgsTurtle,
    Type: 0 /* Turtle */,
    Position: 0,
    String: ["<breed>-here"],
    Context: new AgentContexts("-TP-"),
    isCommand: false
  },
  {
    Match: /^(.*?)-(on)$/,
    Singular: false,
    Tag: SpecialReporter1ArgsTurtle,
    Type: 0 /* Turtle */,
    Position: 0,
    String: ["<breed>-on"],
    Context: new AgentContexts("OTPL"),
    isCommand: false
  },
  {
    Match: /^(in)-(.*?)-(from)$/,
    Singular: true,
    Tag: SpecialReporter1ArgsLink,
    Type: 2 /* UndirectedLink */,
    Position: 1,
    String: ["in-<breed>-from"],
    Context: new AgentContexts("-T--"),
    isCommand: false
  },
  {
    Match: /^(out)-(.*?)-(to)$/,
    Singular: true,
    Tag: SpecialReporter1ArgsLink,
    Type: 2 /* UndirectedLink */,
    Position: 1,
    String: ["out-<breed>-to"],
    Context: new AgentContexts("-T--"),
    isCommand: false
  },
  {
    Match: /^(out|in)-(.*?)-(neighbor\?)$/,
    Singular: true,
    Tag: SpecialReporter1ArgsLink,
    Type: 2 /* UndirectedLink */,
    Position: 1,
    String: ["out-<breed>-neighbor?", "in-<breed>-neighbor?"],
    Context: new AgentContexts("-T--"),
    isCommand: false
  },
  {
    Match: /^(out|in)-(.*?)-(neighbors)$/,
    Singular: true,
    Tag: SpecialReporter0ArgsLink,
    Type: 2 /* UndirectedLink */,
    Position: 1,
    String: ["out-<breed>-neighbors", "in-<breed>-neighbors"],
    Context: new AgentContexts("-T--"),
    isCommand: false
  },
  {
    Match: /^(my-in|my-out|my)-(.*?)$/,
    Singular: false,
    Tag: SpecialReporter0ArgsLinkP,
    Type: 2 /* UndirectedLink */,
    Position: 1,
    String: ["my-out-<breed>", "my-in-<breed>", "my-<breed>"],
    Context: new AgentContexts("-T--"),
    isCommand: false
  },
  {
    Match: /^(is)-(.*?)\?$/,
    Singular: true,
    Tag: SpecialReporter1ArgsBoth,
    Type: void 0,
    Position: 1,
    String: ["is-<breed>?"],
    Context: new AgentContexts("OTPL"),
    isCommand: false
  },
  {
    Match: /^(create)-(.*?)-(to|from|with)$/,
    Singular: void 0,
    Tag: SpecialCommandCreateLink,
    Type: 2 /* UndirectedLink */,
    Position: 1,
    String: ["create-<breed>-to", "create-<breed>-with", "create-<breed>-from"],
    Context: new AgentContexts("-T--"),
    isCommand: true
  },
  {
    Match: /^(.*?)-(with|neighbor\?)$/,
    Singular: true,
    Tag: SpecialReporter1ArgsLink,
    Type: 2 /* UndirectedLink */,
    Position: 0,
    String: ["<breed>-with", "<breed>-neighbor?"],
    Context: new AgentContexts("-T--"),
    isCommand: false
  },
  {
    Match: /^(.*?)-(neighbors)$/,
    Singular: true,
    Tag: SpecialReporter0ArgsLink,
    Type: 2 /* UndirectedLink */,
    Position: 0,
    String: ["<breed>-neighbors"],
    Context: new AgentContexts("-T--"),
    isCommand: false
  },
  {
    Match: /^(create-ordered|create)-(.*?)$/,
    Singular: false,
    Tag: SpecialCommandCreateTurtle,
    Type: 0 /* Turtle */,
    Position: 1,
    String: ["create-ordered-<breed>", "create-<breed>"],
    Context: new AgentContexts("O---"),
    isCommand: true
  },
  {
    Match: /^(hatch)-(.*?)$/,
    Singular: false,
    Tag: SpecialCommandCreateTurtle,
    Type: 0 /* Turtle */,
    Position: 1,
    String: ["hatch-<breed>"],
    Context: new AgentContexts("-T--"),
    isCommand: true
  },
  {
    Match: /^(sprout)-(.*?)$/,
    Singular: false,
    Tag: SpecialCommandCreateTurtle,
    Type: 0 /* Turtle */,
    Position: 1,
    String: ["sprout-<breed>"],
    Context: new AgentContexts("--P-"),
    isCommand: true
  }
];
function MatchBreed(token, context, guessing = false) {
  token = token.toLowerCase();
  if (!guessing) {
    let breedVars = context.BreedVars;
    if (breedVars.has(token)) return { Tag: Identifier, Valid: false };
    if (context.SingularBreeds.has(token)) {
      let plural2 = context.SingularToPlurals.get(token);
      var type = context.BreedTypes.get(plural2);
      if (type == 0 /* Turtle */) return { Tag: SpecialReporter1Args, Singular: token, Plural: plural2, Valid: true };
      else return { Tag: SpecialReporter2Args, Singular: token, Plural: plural2, Valid: true };
    }
  }
  var valid = true;
  for (let rule of BreedStatementRules) {
    let match = token.match(rule.Match);
    if (match) {
      var name2 = match[rule.Position + 1];
      var isSingular = rule.Singular !== void 0 ? rule.Singular : context.SingularBreeds.has(name2);
      var singular, plural;
      if (isSingular) {
        singular = name2;
        if (!context.SingularBreeds.has(name2)) {
          if (!guessing) return { Tag: 0, Valid: false };
          plural = getPluralName(name2);
          valid = false;
        } else {
          plural = context.SingularToPlurals.get(name2);
        }
      } else {
        plural = name2;
        if (!context.PluralBreeds.has(name2)) {
          if (!guessing) return { Tag: 0, Valid: false };
          singular = getSingularName(name2);
          valid = false;
        } else {
          singular = context.PluralToSingulars.get(name2);
        }
      }
      type = context.BreedTypes.get(plural);
      if (typeof type === "undefined" && guessing) type = rule.Type;
      if (type == 3 /* DirectedLink */) type = 2 /* UndirectedLink */;
      if (typeof rule.Type !== "undefined" && type !== rule.Type)
        return { Tag: SpecialCommandCreateTurtlePossible, Valid: false };
      switch (type) {
        case 0 /* Turtle */:
          match[rule.Position + 1] = isSingular ? "turtle" : "turtles";
          break;
        case 1 /* Patch */:
          match[rule.Position + 1] = isSingular ? "patch" : "patches";
          break;
        case 2 /* UndirectedLink */:
          match[rule.Position + 1] = isSingular ? "link" : "links";
          break;
      }
      return {
        Rule: rule,
        Tag: rule.Tag,
        Plural: plural,
        Singular: singular,
        Context: rule.Context,
        Type: type,
        Valid: valid,
        Prototype: match.slice(1).join("-")
      };
    }
  }
  return { Tag: 0, Valid: false };
}
function GetAllBreedPrimitives(lintContext) {
  let all = [];
  for (let b of lintContext.Breeds.values()) {
    all.push(...GetBreedPrimitives(b));
  }
  return all;
}
function GetBreedPrimitives(b) {
  let all = [];
  if (b.BreedType == 0 /* Turtle */ || b.BreedType == 1 /* Patch */) {
    if (b.BreedType == 0 /* Turtle */) {
      all.push("hatch-" + b.Plural);
      all.push("sprout-" + b.Plural);
      all.push("create-" + b.Plural);
      all.push("create-ordered-" + b.Plural);
    }
    all.push(b.Plural + "-at");
    all.push(b.Plural + "-here");
    all.push(b.Plural + "-on");
    all.push("is-" + b.Singular + "?");
  } else {
    all.push("create-" + b.Plural + "-to");
    all.push("create-" + b.Singular + "-to");
    all.push("create-" + b.Plural + "-from");
    all.push("create-" + b.Singular + "-from");
    all.push("create-" + b.Plural + "-with");
    all.push("create-" + b.Singular + "-with");
    all.push("out-" + b.Singular + "-to");
    all.push("out-" + b.Singular + "-neighbors");
    all.push("out-" + b.Singular + "-neighbor?");
    all.push("in-" + b.Singular + "-from");
    all.push("in-" + b.Singular + "-neighbors");
    all.push("in-" + b.Singular + "-neighbor?");
    all.push("my-" + b.Plural);
    all.push("my-in-" + b.Plural);
    all.push("my-out-" + b.Plural);
    all.push(b.Singular + "-neighbor?");
    all.push(b.Singular + "-neighbors");
    all.push(b.Singular + "-with");
    all.push("is-" + b.Singular + "?");
  }
  return all;
}
var getPluralName = function(singular) {
  if (singular[singular.length - 1] == "s") {
    return singular + "es";
  } else {
    return singular + "s";
  }
};
var getSingularName = function(plural) {
  if (plural[plural.length - 1] != "s") {
    return "a-" + plural;
  } else {
    return plural.substring(0, plural.length - 1);
  }
};

// src/codemirror/extension-state-netlogo.ts
var primitives = PrimitiveManager;
var StateNetLogo = class {
  constructor() {
    // #region "Information"
    /** Preprocess: Preprocess context from all editors in the first pass. */
    this.Preprocess = new PreprocessContext();
    /** Extensions: Extensions in the code. */
    this.Extensions = [];
    /** Globals: Globals in the code. */
    this.Globals = [];
    /** WidgetGlobals: Globals from the widgets. */
    this.WidgetGlobals = [];
    /** Breeds: Breeds in the code. */
    this.Breeds = /* @__PURE__ */ new Map();
    /** Procedures: Procedures in the code. */
    this.Procedures = /* @__PURE__ */ new Map();
    /** CompilerErrors: Errors from the compiler. */
    this.CompilerErrors = [];
    /** CompilerErrors: Errors during the runtime. */
    this.RuntimeErrors = [];
    /** IsDirty: Whether the current state is dirty. */
    this.IsDirty = true;
    /** Mode: The editor's parsing mode. */
    this.Mode = "Normal" /* Normal */;
    /** RecognizedMode: The editor's recognized mode. */
    this.RecognizedMode = "Unknown";
    /** ContextErrors: Context errors detected during processing. */
    this.ContextErrors = [];
    /** EditorID: The id of the editor. */
    this.EditorID = 0;
    /** Context: The context of the editor. */
    this.Context = "";
  }
  /** SetContext: Set the context of the editor. */
  SetContext(Context) {
    if (this.Context !== Context) {
      this.Context = Context;
      return true;
    } else return false;
  }
  // #endregion
  // #region "Version Control"
  /** SetDirty: Make the state dirty. */
  SetDirty() {
    this.IsDirty = true;
  }
  /** GetDirty: Gets if the state is dirty. */
  GetDirty() {
    return this.IsDirty;
  }
  // #endregion
  // #region "Parsing"
  /** ParseState: Parse the state from an editor state. */
  ParseState(State) {
    var _a;
    if (!this.IsDirty) return this;
    this.Breeds = /* @__PURE__ */ new Map();
    this.Procedures = /* @__PURE__ */ new Map();
    this.Extensions = [];
    this.Globals = [];
    this.ContextErrors = [];
    this.Breeds.set("turtle", new Breed("turtle", "turtles", [], 0 /* Turtle */));
    this.Breeds.set("patch", new Breed("patch", "patches", [], 1 /* Patch */));
    this.Breeds.set("link", new Breed("link", "links", [], 2 /* UndirectedLink */));
    let tempBreedVars = /* @__PURE__ */ new Map();
    this.IsDirty = false;
    const Cursor = GetCursorUntilMode(State);
    if (!Cursor) return this;
    switch (Cursor.node.name) {
      case "Embedded":
        this.RecognizedMode = "Command";
        break;
      case "OneLineReporter":
        this.RecognizedMode = "Reporter";
        break;
      case "Normal":
        this.RecognizedMode = "Model";
        break;
      default:
        this.RecognizedMode = "Unknown";
        break;
    }
    if (this.RecognizedMode == "Model") {
      if (!Cursor.firstChild()) return this;
      while (true) {
        if (Cursor.node.name == "Extensions") {
          Cursor.node.getChildren("Identifier").map((node) => {
            this.Extensions.push(getCodeName(State, node));
          });
        } else if (Cursor.node.name == "Globals") {
          this.Globals = [...this.Globals, ...this.getVariables(Cursor.node, State)];
        } else if (Cursor.node.name == "Breed") {
          let breedType = 0 /* Turtle */;
          Cursor.node.getChildren("BreedStr").map((node) => {
            let name2 = getCodeName(State, node);
            if (name2.toLowerCase() == "undirected-link-breed") {
              breedType = 2 /* UndirectedLink */;
            } else if (name2.toLowerCase() == "directed-link-breed") {
              breedType = 3 /* DirectedLink */;
            }
          });
          const Plural = Cursor.node.getChildren("BreedPlural");
          const Singular = Cursor.node.getChildren("BreedSingular");
          if (Plural.length == 1 && Singular.length == 1) {
            let singular = getCodeName(State, Singular[0]);
            let plural = getCodeName(State, Plural[0]);
            let vars = tempBreedVars.get(plural) ?? [];
            let breed = new Breed(singular, plural, vars, breedType);
            this.Breeds.set(singular, breed);
          }
        } else if (Cursor.node.name == "BreedsOwn") {
          let breedName = "";
          Cursor.node.getChildren("Own").map((node) => {
            breedName = getCodeName(State, node);
            breedName = breedName.substring(0, breedName.length - 4);
          });
          let breedVars = this.getVariables(Cursor.node, State);
          let found = false;
          for (let breed of this.Breeds.values()) {
            if (breed.Plural == breedName) {
              breed.Variables = breedVars;
              found = true;
            }
          }
          if (!found) tempBreedVars.set(breedName, breedVars);
        } else if (Cursor.node.name == "Procedure") {
          let procedure = this.gatherProcedure(Cursor.node, State);
          this.Procedures.set(procedure.Name, procedure);
        }
        if (!Cursor.nextSibling()) return this;
      }
    } else {
      if (this.RecognizedMode == "Command") {
        let procedure = this.gatherEmbeddedProcedure(Cursor.node, State);
        this.Procedures.set(procedure.Name, procedure);
      } else if (this.RecognizedMode == "Reporter") {
        let procedure = this.gatherEmbeddedReporter(Cursor.node, State);
        this.Procedures.set(procedure.Name, procedure);
      }
      let context = this.Preprocess.GetBreedContext(this.Context, false);
      this.combineContext(
        ((_a = syntaxTree3(State).cursor().node.firstChild) == null ? void 0 : _a.firstChild) ?? syntaxTree3(State).cursor().node,
        State,
        context,
        new AgentContexts()
      );
    }
    return this;
  }
  /** gatherEmbeddedProcedure: Gather all information about a procedure in embedded mode. */
  gatherEmbeddedProcedure(Node, State) {
    let procedure = new Procedure();
    procedure.PositionStart = Node.from;
    procedure.PositionEnd = Node.to;
    procedure.IsCommand = true;
    procedure.Name = "\u26A0EmbeddedProcedure\u26A0";
    procedure.Arguments = [];
    procedure.Variables = this.getLocalVarsCommand(Node, State, false);
    procedure.AnonymousProcedures = this.gatherAnonProcedures(Node, State, procedure);
    procedure.Context = this.getContext(Node, State);
    procedure.CodeBlocks = this.gatherCodeBlocks(
      State,
      Node,
      procedure.Context,
      procedure.Variables,
      procedure.Arguments
    );
    return procedure;
  }
  /** gatherEmbeddedReporter: Gather all information about a reporter in embedded mode. */
  gatherEmbeddedReporter(Node, State) {
    let procedure = new Procedure();
    procedure.PositionStart = Node.from;
    procedure.PositionEnd = Node.to;
    procedure.IsCommand = false;
    procedure.Name = "\u26A0EmbeddedReporter\u26A0";
    procedure.Arguments = [];
    procedure.Variables = this.getLocalVarsCommand(Node, State, false);
    procedure.AnonymousProcedures = this.gatherAnonProcedures(Node, State, procedure);
    procedure.Context = this.getContext(Node, State);
    procedure.CodeBlocks = this.gatherCodeBlocks(
      State,
      Node,
      procedure.Context,
      procedure.Variables,
      procedure.Arguments
    );
    return procedure;
  }
  /** gatherProcedure: Gather all information about a procedure. */
  gatherProcedure(Node, State) {
    let procedure = new Procedure();
    procedure.PositionStart = Node.from;
    procedure.PositionEnd = Node.to;
    procedure.IsCommand = true;
    if (Node.getChild("To")) {
      procedure.IsCommand = getCodeName(State, Node.getChildren("To")[0].node).toLowerCase() == "to";
    }
    Node.getChildren("ProcedureName").map((Children) => {
      procedure.Name = getCodeName(State, Children);
    });
    procedure.Arguments = this.getArgs(Node, State);
    procedure.Variables = this.getLocalVars(Node, State, false);
    procedure.AnonymousProcedures = this.gatherAnonProcedures(Node, State, procedure);
    procedure.Context = this.getContext(Node, State);
    procedure.CodeBlocks = this.gatherCodeBlocks(
      State,
      Node,
      procedure.Context,
      procedure.Variables,
      procedure.Arguments
    );
    this.checkReporterContext(Node, State);
    return procedure;
  }
  checkReporterContext(Node, State) {
    Node.cursor().iterate((noderef) => {
      if (noderef.name == "ReporterLeft1Args") {
        let left = null;
        let right = null;
        if (getCodeName(State, noderef) == "of") {
          left = noderef.node.prevSibling;
          right = noderef.node.nextSibling;
        } else if (getCodeName(State, noderef) == "with") {
          right = noderef.node.prevSibling;
          left = noderef.node.nextSibling;
        }
        if (left && right) {
          let breed = this.identifyBreed(right, State);
          let str = getCodeName(State, left);
          str = str.replace(/^\s*\[/, "");
          str = str.replace(/\]\s$/, "");
          str = str.replace(/\[[^\]]*\]/, "");
          if (breed) {
            for (let s of str.split(" ")) {
              if (this.Preprocess.BreedVarToPlurals.has(s.toLowerCase())) {
                let var_breed = this.Preprocess.BreedVarToPlurals.get(s.toLowerCase());
                let supertype = this.Preprocess.GetSuperType(breed);
                let context = new AgentContexts();
                if (supertype && var_breed && !var_breed.includes(breed) && !var_breed.includes(supertype)) {
                  if (supertype == "turtles" && var_breed.includes("patches")) {
                    continue;
                  } else {
                    for (let b of var_breed) {
                      context = combineContexts(context, this.Preprocess.GetBreedContext(b, true));
                    }
                    this.ContextErrors.push(
                      new ContextError(left.from, left.to, this.Preprocess.GetBreedContext(breed, false), context, s)
                    );
                  }
                }
              }
            }
          }
        }
      }
    });
  }
  /** getContext: Identify context of a block by looking at primitives and variable names. */
  getContext(node, state, priorContext_param) {
    let context = new AgentContexts();
    let priorContext = priorContext_param ?? new AgentContexts();
    let newContext = context;
    node.getChildren("ProcedureContent").map((node2) => {
      node2.getChildren("CommandStatement").map((node3) => {
        [priorContext, newContext] = this.combineContext(node3, state, priorContext, newContext);
      });
    });
    return priorContext;
  }
  /** combineContext: Identify context of a block by combining with the previous context. */
  combineContext(node, state, priorContext, newContext) {
    let cursor = node.cursor();
    cursor.iterate((child) => {
      var _a, _b;
      let context = void 0;
      let name2 = void 0;
      if (child.name.includes("Block") || child.name == "AnonymousProcedure") {
        return false;
      }
      if ((child.node.name.includes("Command") || child.node.name.includes("Reporter")) && !child.node.name.includes("Commands") && !child.node.name.includes("Reporters") && !child.node.name.includes("Special") && !child.node.name.includes("Content") && !child.node.name.includes("Statement")) {
        name2 = getCodeName(state, child.node);
        context = this.getPrimitiveContext(state, child.node, name2);
      } else if (child.node.name == "VariableDeclaration") {
        let n = (_a = child.node.getChild("SetVariable")) == null ? void 0 : _a.getChild("VariableName");
        if (n) {
          name2 = getCodeName(state, n);
          if (["shape", "breed", "hidden?", "label", "label-color", "color"].includes(name2)) {
            context = new AgentContexts("-T-L");
          } else if (n == null ? void 0 : n.getChild("PatchVar")) {
            context = new AgentContexts("-TP-");
          } else if (n == null ? void 0 : n.getChild("TurtleVar")) {
            context = new AgentContexts("-T--");
          } else if (n == null ? void 0 : n.getChild("LinkVar")) {
            context = new AgentContexts("---L");
          } else {
            context = this.Preprocess.GetBreedVariableContexts(name2);
          }
        }
      } else if (child.node.name.includes("Special")) {
        name2 = getCodeName(state, child.node);
        if (!child.node.name.includes("Both") && !child.node.name.includes("Turtle") && !child.node.name.includes("Link")) {
          context = (_b = this.Procedures.get(name2)) == null ? void 0 : _b.Context;
        } else {
          context = MatchBreed(name2, this.Preprocess).Context;
        }
      }
      if (context) {
        newContext = combineContexts(context, priorContext);
        if (!noContext(newContext)) {
          priorContext = newContext;
        } else {
          this.ContextErrors.push(new ContextError(child.node.from, child.node.to, priorContext, context, name2));
        }
      }
    });
    return [priorContext, newContext];
  }
  /** combineContext: Identify context of a block by combining with the previous context. */
  OLDcombineContext(node, state, priorContext, newContext) {
    var _a, _b;
    let cursor = node.cursor();
    let child = cursor.firstChild();
    while (child) {
      let context = void 0;
      let name2 = void 0;
      if ((cursor.node.name.includes("Command") || cursor.node.name.includes("Reporter")) && !cursor.node.name.includes("Commands") && !cursor.node.name.includes("Reporters") && !cursor.node.name.includes("Special")) {
        name2 = getCodeName(state, cursor.node);
        context = this.getPrimitiveContext(state, cursor.node, name2);
      } else if (cursor.node.name == "VariableDeclaration") {
        let n = (_a = cursor.node.getChild("SetVariable")) == null ? void 0 : _a.getChild("VariableName");
        if (n) {
          name2 = getCodeName(state, n);
          if (["shape", "breed", "hidden?", "label", "label-color", "color"].includes(name2)) {
            context = new AgentContexts("-T-L");
          } else if (n == null ? void 0 : n.getChild("PatchVar")) {
            context = new AgentContexts("-TP-");
          } else if (n == null ? void 0 : n.getChild("TurtleVar")) {
            context = new AgentContexts("-T--");
          } else if (n == null ? void 0 : n.getChild("LinkVar")) {
            context = new AgentContexts("---L");
          } else {
            context = this.Preprocess.GetBreedVariableContexts(name2);
          }
        }
      } else if (cursor.node.name.includes("Special")) {
        name2 = getCodeName(state, cursor.node);
        if (!cursor.node.name.includes("Both") && !cursor.node.name.includes("Turtle") && !cursor.node.name.includes("Link")) {
          context = (_b = this.Procedures.get(name2)) == null ? void 0 : _b.Context;
        } else {
          context = MatchBreed(name2, this.Preprocess).Context;
        }
      }
      if (context) {
        newContext = combineContexts(context, priorContext);
        if (!noContext(newContext)) {
          priorContext = newContext;
        } else {
          this.ContextErrors.push(new ContextError(cursor.node.from, cursor.node.to, priorContext, context, name2));
        }
      }
      child = cursor.nextSibling();
    }
    return [priorContext, newContext];
  }
  /** getPrimitiveContext: Identify context for a builtin primitive. */
  getPrimitiveContext(state, node, prim) {
    let prim_data = primitives.GetNamedPrimitive(prim);
    return prim_data == null ? void 0 : prim_data.AgentContext;
  }
  /** gatherCodeBlocks: Gather all information about code blocks inside a given node. */
  gatherCodeBlocks(state, node, parentContext, vars, args) {
    var blocks = [];
    node.cursor().iterate((noderef) => {
      if (noderef.node.to > node.to) return false;
      if (noderef.name == "Value")
        noderef.node.getChildren("CodeBlock").map((child) => {
          this.gatherCodeBlock(state, child, blocks, parentContext, vars, args);
        });
    });
    return blocks;
  }
  /** gatherCodeBlocks: Gather all information about a given code block. */
  gatherCodeBlock(state, node, blocks, parentContext, vars, args) {
    if (this.checkRanges(blocks, node)) return;
    let block = new CodeBlock();
    let prim = this.getPrimitive(node.parent.node.parent.node, state);
    block.Primitive = prim.name;
    block.PositionStart = node.from;
    block.PositionEnd = node.to;
    block.InheritParentContext = prim.inheritParentContext;
    let originalContext = noContext(prim.context) || block.InheritParentContext ? parentContext : prim.context;
    block.Context = this.getContext(node, state, originalContext);
    block.Variables = vars.concat(this.getLocalVars(node.node, state, true));
    block.Arguments = args;
    block.Breed = prim.breed;
    block.CodeBlocks = this.gatherCodeBlocks(state, node, block.Context, block.Variables, block.Arguments);
    blocks.push(block);
  }
  /** getPrimitive: Gather information about the primitive whose argument is a code block. */
  getPrimitive(node, state) {
    var _a, _b;
    let prim = {
      name: "",
      type: "",
      isSpecial: false,
      context: new AgentContexts("null"),
      firstArg: (_a = node.parent) == null ? void 0 : _a.getChild("Arg"),
      breed: "",
      inheritParentContext: false
    };
    let cursor = (_b = node.parent) == null ? void 0 : _b.cursor();
    let ask = false;
    if (cursor == null ? void 0 : cursor.firstChild()) {
      if (!["OpenParen", "CloseParen", "Reporters", "Commands", "Arg"].includes(cursor.node.name)) {
        prim.name = getCodeName(state, cursor.node);
        prim.type = cursor.node.name;
        if (prim.name == "ask") {
          ask = true;
        }
      }
      while (cursor.nextSibling() && (prim.name == "" || ask)) {
        if (!["OpenParen", "CloseParen", "Reporters", "Commands", "Arg"].includes(cursor.node.name)) {
          prim.name = getCodeName(state, cursor.node);
          prim.type = cursor.node.name;
        } else if (cursor.node.name == "Arg" && ask) {
          prim.breed = this.identifyBreed(cursor.node, state) ?? prim.breed;
          ask = false;
        }
      }
    }
    if (prim.type.includes("Special")) {
      prim.isSpecial = true;
      prim.breed = MatchBreed(prim.name, this.Preprocess).Plural ?? "";
    }
    if (prim.breed != "") {
      prim.context = new AgentContexts("null");
      if (this.Preprocess.PluralBreeds.has(prim.breed)) {
        prim.context = this.Preprocess.GetBreedContext(prim.breed, false);
      } else if (this.Preprocess.SingularBreeds.has(prim.breed)) {
        prim.context = this.Preprocess.GetBreedContext(this.Preprocess.SingularToPlurals.get(prim.breed), false);
      }
    } else {
      let primitive = primitives.GetNamedPrimitive(prim.name);
      prim.context = (primitive == null ? void 0 : primitive.BlockContext) ?? new AgentContexts("null");
      prim.inheritParentContext = (primitive == null ? void 0 : primitive.InheritParentContext) ?? false;
    }
    if (noContext(prim.context)) Log("No available context: " + prim.name);
    return prim;
  }
  /** identifyBreed: Identify the breed context of a given node. */
  identifyBreed(Node, State) {
    let str = getCodeName(State, Node);
    if (this.Preprocess.PluralBreeds.has(str)) return str;
    var breed = this.Preprocess.GetReporterBreed(str.split(" ")[0].trim());
    if (breed) return breed;
    Node.cursor().iterate((noderef) => {
      if (breed != void 0) return false;
      let str2 = getCodeName(State, noderef);
      if (str2.startsWith("[")) return false;
      if (this.Preprocess.PluralBreeds.has(str2)) {
        breed = str2;
        return false;
      } else if (this.Preprocess.SingularBreeds.has(str2)) {
        breed = this.Preprocess.SingularToPlurals.get(str2);
        return false;
      }
    });
    return breed;
  }
  /** searchAnonProcedure: Look for nested anonymous procedures within a node and procedure. */
  gatherAnonProcedures(node, State, procedure) {
    let anonymousProcedures = [];
    node.cursor().iterate((noderef) => {
      if (noderef.node.to > node.to) {
        return false;
      }
      if (node != noderef.node && (noderef.name == "AnonymousProcedure" || noderef.name == "ShortAnonymousProcedure") && !this.checkRanges(anonymousProcedures, noderef.node)) {
        anonymousProcedures.push(this.gatherAnonProcedure(noderef, State, procedure));
      }
    });
    return anonymousProcedures;
  }
  /** checkRanges: Identify whether a node is inside the set of procedures or code blocks. */
  checkRanges(procedures, node) {
    for (let p of procedures) {
      if (p.PositionStart <= node.from && p.PositionEnd >= node.to) return true;
    }
    return false;
  }
  /** getAnonProcedure: Gather information about an anonymous procedure. */
  gatherAnonProcedure(noderef, State, procedure) {
    let anonProc = new Procedure();
    anonProc.PositionStart = noderef.from;
    anonProc.PositionEnd = noderef.to;
    anonProc.Variables = procedure.Variables;
    anonProc.IsAnonymous = true;
    anonProc.Name = "";
    anonProc.IsCommand = noderef.node.getChildren("ProcedureContent").length > 0;
    let args = [];
    let Node = noderef.node;
    Node.getChildren("AnonArguments").map((node) => {
      node.getChildren("Identifier").map((subnode) => {
        args.push(getCodeName(State, subnode));
      });
      node.getChildren("Arguments").map((subnode) => {
        subnode.getChildren("Identifier").map((subsubnode) => {
          args.push(getCodeName(State, subsubnode));
        });
      });
    });
    anonProc.Arguments = args;
    anonProc.Variables = anonProc.Variables.concat(this.getLocalVars(Node, State, true));
    anonProc.AnonymousProcedures = this.gatherAnonProcedures(Node, State, anonProc);
    return anonProc;
  }
  /** getLocalVars: Collect local variables within a node. */
  getLocalVars(Node, State, isAnon) {
    let localVars = [];
    Node.getChildren("ProcedureContent").map((node1) => {
      localVars = localVars.concat(this.getLocalVarsCommand(node1, State, isAnon));
    });
    return localVars;
  }
  /** getLocalVarsCommand: Collect local variables within a command statement. */
  getLocalVarsCommand(Node, State, isAnon) {
    let localVars = [];
    Node.getChildren("CommandStatement").map((node2) => {
      node2.getChildren("VariableDeclaration").map((node3) => {
        node3.getChildren("NewVariableDeclaration").map((node4) => {
          node4.getChildren("Identifier").map((node5) => {
            let variable = new LocalVariable(getCodeName(State, node5), 1, node5.from);
            localVars.push(variable);
          });
          node4.getChildren("UnsupportedPrim").map((node5) => {
            let variable = new LocalVariable(getCodeName(State, node5), 1, node5.from);
            localVars.push(variable);
          });
        });
      });
    });
    return localVars;
  }
  /** getVariables: Get global or breed variables. */
  getVariables(Node, State) {
    let vars = [];
    Node.cursor().iterate((noderef) => {
      if (noderef.node.to > Node.to) {
        return false;
      }
      if (![
        "OpenParen",
        "CloseParen",
        "OpenBracket",
        "CloseBracket",
        "LineComment",
        "BreedsOwn",
        "Own",
        "GlobalStr",
        "ExtensionStr",
        "BreedDeclarative",
        "Globals",
        "Breed",
        "Extensions"
      ].includes(noderef.name)) {
        var Text2 = getCodeName(State, noderef.node);
        if (Text2 !== "" && !Text2.includes("\n")) vars.push(getCodeName(State, noderef.node));
      }
    });
    return [...new Set(vars)];
  }
  /** getArgs: Identify arguments for a given procedure. */
  getArgs(Node, State) {
    const args = [];
    Node.getChildren("Arguments").map((node) => {
      node.getChildren("Identifier").map((subnode) => {
        args.push(getCodeName(State, subnode));
      });
    });
    return args;
  }
  // #endregion
};
var stateExtension = StateField.define({
  create: (State) => {
    var NewState = new StateNetLogo();
    NewState.SetDirty();
    return NewState;
  },
  update: (Original, Transaction4) => {
    if (Transaction4.docChanged) {
      Original.SetDirty();
      Log(Original);
    }
    return Original;
  }
});

// src/codemirror/extension-state-preprocess.ts
var StatePreprocess = class {
  constructor() {
    /** PluralBreeds: Breeds in the model. */
    this.PluralBreeds = [];
    /** SingularBreeds: Breeds in the model. */
    this.SingularBreeds = [];
    /** SingularBreeds: Breed types in the model. */
    this.BreedTypes = [];
    /** BreedVars: Breed variables in the model. */
    this.BreedVars = /* @__PURE__ */ new Map();
    /** Commands: Commands in the model. */
    this.Commands = /* @__PURE__ */ new Map();
    /** Reporters: Reporters in the model. */
    this.Reporters = /* @__PURE__ */ new Map();
    /** Editor: The editor for the state. */
    this.Editor = null;
  }
  /** ParseState: Parse the state from an editor state. */
  ParseState(State) {
    this.Commands.clear();
    this.Reporters.clear();
    this.BreedVars.clear();
    let doc = State.doc.toString().toLowerCase();
    let globals = doc.replace(/(^|\n)([^;\n]+[ ]+)?to\s+[\s\S]*\s+end/gi, "");
    let breeds = globals.matchAll(
      /(^|\n)([^;\n]+[ ]+)?(directed-link-|undirected-link-)?breed\s*\[\s*([^\s]+)\s+([^\s]+)\s*\]/g
    );
    this.processBreeds(breeds);
    let breedVars = globals.matchAll(/(^|\n)([^;\n]+[ ]+)?([^\s]+)-own\s*\[([^\]]+)/g);
    this.processBreedVars(breedVars);
    let commands = doc.matchAll(/(^|\n)([^;\n]+[ ]+)?to\s+([^\s\[;]+)(\s*\[([^\];]*)\])?/g);
    this.Commands = this.processProcedures(commands);
    let reporters = doc.matchAll(/(^|\n)([^;\n]+[ ]+)?to-report\s+([^\s\[;]+)(\s*\[([^\]']*)\])?/g);
    this.Reporters = this.processProcedures(reporters);
    return this;
  }
  /** SetEditor: Set the editor for the state. */
  SetEditor(Editor) {
    this.Editor = Editor;
  }
  /** processBreedVars: Parse the code for breed variables. */
  processBreedVars(matches) {
    for (var m of matches) {
      let variables = m[4];
      variables = variables.replace(/;[^\n]*\n/g, "");
      variables = variables.replace(/\n/g, " ");
      this.BreedVars.set(
        m[3],
        variables.split(" ").filter((v) => v != "" && v != "\n")
      );
    }
    this.BreedVars.set(
      "patches",
      (this.BreedVars.get("patches") ?? []).concat(["pxcor", "pycor", "pcolor", "plabel", "plabel-color"])
    );
    this.BreedVars.set(
      "turtles",
      (this.BreedVars.get("turtles") ?? []).concat([
        "who",
        "color",
        "heading",
        "xcor",
        "ycor",
        "shape",
        "label",
        "label-color",
        "hidden?",
        "size",
        "pen-size",
        "pen-mode",
        "breed"
      ])
    );
    this.BreedVars.set(
      "links",
      (this.BreedVars.get("links") ?? []).concat([
        "end1",
        "end2",
        "color",
        "label",
        "label-color",
        "hidden?",
        "breed",
        "thickness",
        "shape",
        "tie-mode"
      ])
    );
  }
  /** processProcedures: Parse the code for procedure names. */
  processProcedures(procedures) {
    let matches = /* @__PURE__ */ new Map();
    for (var match of procedures) {
      if (!match[2] || match[2].split('"').length % 2 != 0) {
        const name2 = match[3];
        const args = match[5];
        matches.set(name2, args == null ? 0 : [...args.matchAll(/([^\s])+/g)].length);
      }
    }
    return matches;
  }
  /** processBreeds: Parse the code for breed names. */
  processBreeds(breeds) {
    this.SingularBreeds = ["patch", "turtle", "link"];
    this.PluralBreeds = ["patches", "turtles", "links"];
    this.BreedTypes = [1 /* Patch */, 0 /* Turtle */, 2 /* UndirectedLink */];
    for (var match of breeds) {
      var Type = 0 /* Turtle */;
      if (match[3] == "directed-link-") Type = 3 /* DirectedLink */;
      if (match[3] == "undirected-link-") Type = 2 /* UndirectedLink */;
      this.BreedTypes.push(Type);
      this.PluralBreeds.push(match[4]);
      this.SingularBreeds.push(match[5]);
    }
  }
};
var preprocessStateExtension = StateField.define({
  create: (State) => {
    let state = new StatePreprocess();
    state.ParseState(State);
    return state;
  },
  update: (Original, Transaction4) => {
    if (!Transaction4.docChanged) return Original;
    Original.ParseState(Transaction4.state);
    if (Original.Editor) Original.Editor.UpdatePreprocessContext();
    Log(Original);
    return Original;
  }
});

// src/codemirror/extension-tooltip.ts
import { hoverTooltip } from "@codemirror/view";

// src/lang/linters/linter-builder.ts
import { linter } from "@codemirror/lint";
var buildLinter = function(Source, Editor) {
  var LastVersion = -1;
  var Cached = [];
  var BuiltSource = (view) => {
    if (Editor.UpdateContext() || Editor.GetVersion() > LastVersion) {
      var state = view.state.field(stateExtension);
      Cached = Source(view, Editor.PreprocessContext, Editor.LintContext, state);
      LastVersion = Editor.GetVersion();
    }
    return Cached;
  };
  var Extension2 = linter(BuiltSource);
  Extension2.Source = BuiltSource;
  if (Extension2[2].length == 4) {
    lintState = Extension2[2][0];
    Extension2[2].splice(2, 1);
    console.log(Extension2);
  }
  return Extension2;
};
var lintState;
var getLintState = function(state) {
  return state.field(lintState);
};
var getDiagnostic = function(view, node, message, severity = "error", ...values) {
  var value = view.state.sliceDoc(node.from, node.to);
  var from = node.from + value.length - value.trimStart().length;
  var to = node.to - value.length + value.trimEnd().length;
  value = value.trim();
  if (value.length >= 20) value = value.replace("\n", " ").substring(0, 17) + "...";
  if (values.length == 0) values.push(value);
  return {
    from,
    to,
    severity,
    message: Localized.Get(message, ...values)
  };
};

// src/codemirror/extension-tooltip.ts
import elt from "crelt";

// src/lang/tooltip.ts
import { EditorView as EditorView3 } from "@codemirror/view";
import { syntaxTree as syntaxTree5 } from "@codemirror/language";

// src/utils/tooltip-utils.ts
import { syntaxTree as syntaxTree4 } from "@codemirror/language";
var classifyPrimitive = function(name2) {
  if (name2.indexOf("Reporter") != -1 && name2.indexOf("ReporterStatement") == -1) {
    if (name2.indexOf("Special") != -1) {
      if (name2.indexOf("Turtle") != -1 || name2.indexOf("Link") != -1 || name2.indexOf("Both") != -1) {
        name2 = "BreedReporter";
      } else {
        name2 = "CustomReporter";
      }
    } else {
      name2 = "Reporter";
    }
  }
  if (name2.indexOf("Command") != -1 && name2.indexOf("CommandStatement") == -1) {
    if (name2.indexOf("Special") != -1) {
      if (name2.indexOf("Create") != -1) {
        name2 = "BreedCommand";
      } else {
        name2 = "CustomCommand";
      }
    } else {
      name2 = "Command";
    }
  }
  return name2;
};
var classifyBreedName = function(term, breeds) {
  let plurals = [];
  let singular = [];
  let closestTerm = "";
  for (let b of breeds) {
    plurals.push(b.Plural);
    singular.push(b.Singular);
  }
  if (plurals.includes(term)) {
    closestTerm = "~BreedPlural";
  } else {
    closestTerm = "~BreedSingular";
  }
  return closestTerm;
};
var getLink = function(nodeName, childName, term, state) {
  let linkData = {
    to: 0,
    from: 0,
    hasLink: false
  };
  syntaxTree4(state).cursor().iterate((node) => {
    if (node.name == nodeName) {
      node.node.getChildren(childName).map((subnode) => {
        if (getCodeName(state, subnode) == term) {
          linkData = {
            to: subnode.to,
            from: subnode.from,
            hasLink: true
          };
        }
      });
    }
  });
  return linkData;
};

// src/lang/tooltip.ts
function getTooltip2(view, from, to, editor) {
  var lintContext = editor.LintContext;
  var preprocess = editor.PreprocessContext;
  var lastFrom = 0;
  var lastTo = 0;
  var closestTerm = "";
  var parentName = "";
  var secondTerm = null;
  syntaxTree5(view.state).iterate({
    enter: (ref) => {
      if (ref.from == ref.to || to == ref.from) return true;
      lastFrom = ref.from;
      lastTo = ref.to;
      var name2 = classifyPrimitive(ref.name);
      if (closestTerm == "~BreedSingular" || closestTerm == "~Arguments" || closestTerm == "~ProcedureName") {
      } else if (Dictionary.Check(`~${name2}`) || Localized.Get(`~${name2}`) != `~${name2}`) {
        closestTerm = `~${name2}`;
      } else if (Dictionary.Check(`~${parentName}/${name2}`) || Localized.Get(`~${parentName}/${name2}`) != `~${parentName}/${name2}`)
        closestTerm = `~${parentName}/${name2}`;
      parentName = name2;
    },
    from,
    to
  });
  if (lastFrom == lastTo) return;
  const term = getCodeName(view.state, { from: lastFrom, to: lastTo });
  if (Dictionary.Check(term)) {
    closestTerm = term;
  } else if (lintContext.Globals.has(term)) {
    closestTerm = "~Globals/Identifier";
  } else if (lintContext.WidgetGlobals.has(term)) {
    closestTerm = "~WidgetGlobal";
  } else if (lintContext.GetBreedNames().includes(term)) {
    closestTerm = classifyBreedName(term, lintContext.GetBreeds());
  } else {
    secondTerm = lintContext.GetBreedFromVariable(term);
    if (secondTerm != null) {
      closestTerm = "~BreedVariable";
    } else {
      if (closestTerm == "~VariableName" || closestTerm == "~NewVariableDeclaration/Identifier" || parentName == "Identifier" && closestTerm == "") {
        secondTerm = lintContext.GetProcedureFromVariable(term, lastFrom, lastTo);
        if (secondTerm != null) closestTerm = "~LocalVariable";
        else closestTerm = "~VariableName";
      }
    }
  }
  if (closestTerm == "~BreedReporter" || closestTerm == "~BreedCommand") {
    var match = MatchBreed(term, preprocess);
    if (match.Valid && match.Plural) {
      if (match.Prototype && Dictionary.Check(match.Prototype)) closestTerm = match.Prototype;
      secondTerm = match.Plural;
    } else {
      secondTerm = "Unknown";
    }
  }
  Log("Term: " + term, closestTerm, parentName);
  if (closestTerm == "") return;
  let result = getInternalLink(term, closestTerm, secondTerm ?? "", view.state, lintContext);
  return {
    from: lastFrom,
    to: lastTo,
    severity: "info",
    message: "",
    renderMessage: () => {
      const dom2 = document.createElement("span");
      var message = Dictionary.Get(closestTerm, secondTerm ?? "");
      if (Dictionary.ClickHandler != null && !closestTerm.startsWith("~")) {
        message += "\u27A4";
        dom2.addEventListener("click", () => Dictionary.ClickHandler(term));
        dom2.classList.add("cm-tooltip-extendable");
      } else if (result.hasLink) {
        message += "\u27A4";
        dom2.addEventListener(
          "click",
          () => view.dispatch({
            selection: EditorSelection.create([EditorSelection.range(result.from, result.to)]),
            effects: [EditorView3.scrollIntoView(result.from, { y: "center" })]
          })
        );
        dom2.classList.add("cm-tooltip-extendable");
      }
      dom2.innerText = message;
      return dom2;
    }
  };
}
function getInternalLink(term, closestTerm, secondTerm, state, lintContext) {
  let linkData = {
    to: 0,
    from: 0,
    hasLink: false
  };
  if (closestTerm == "~Globals/Identifier") {
    linkData = getLink("Globals", "Identifier", term, state);
  } else if (closestTerm == "~BreedSingular") {
    linkData = getLink("Breed", "BreedSingular", term, state);
  } else if (closestTerm == "~BreedPlural") {
    linkData = getLink("Breed", "BreedPlural", term, state);
  } else if (closestTerm == "~BreedVariable") {
    syntaxTree5(state).cursor().iterate((node) => {
      if (node.name == "BreedsOwn") {
        let correctNode = false;
        node.node.getChildren("Own").map((subnode) => {
          if (getCodeName(state, subnode) == secondTerm + "-own") correctNode = true;
        });
        if (correctNode) {
          node.node.getChildren("Identifier").map((subnode) => {
            if (getCodeName(state, subnode) == term) {
              linkData.to = subnode.to;
              linkData.from = subnode.from;
              linkData.hasLink = true;
            }
          });
        }
      }
    });
  } else if (closestTerm == "~CustomReporter" || closestTerm == "~CustomCommand") {
    syntaxTree5(state).cursor().iterate((node) => {
      if (node.name == "ProcedureName" && getCodeName(state, node) == term) {
        linkData.to = node.to;
        linkData.from = node.from;
        linkData.hasLink = true;
      }
    });
  } else if (closestTerm == "~LocalVariable") {
    let procName = secondTerm.replace("{anonymous},", "");
    let proc = lintContext.Procedures.get(procName);
    if (!proc) return linkData;
    if (proc.Arguments.includes(term)) {
      syntaxTree5(state).cursor().iterate((node) => {
        var _a;
        if (node.name == "Procedure") {
          let nameNode = node.node.getChild("ProcedureName");
          if (nameNode && getCodeName(state, nameNode) == procName) {
            (_a = node.node.getChild("Arguments")) == null ? void 0 : _a.getChildren("Identifier").map((subnode) => {
              if (getCodeName(state, subnode) == term) {
                linkData.to = subnode.to;
                linkData.from = subnode.from;
                linkData.hasLink = true;
              }
            });
          }
        }
      });
    } else if (!secondTerm.includes("{anonymous}")) {
      for (let vars2 of proc.Variables) {
        if (vars2.Name == term) {
          let subnode = syntaxTree5(state).cursorAt(vars2.CreationPos).node;
          linkData.to = subnode.to;
          linkData.from = subnode.from;
          linkData.hasLink = true;
        }
      }
    } else {
      for (var anonProc of proc.AnonymousProcedures) {
        if (anonProc.Arguments.includes(term)) {
          syntaxTree5(state).iterate({
            enter: (noderef) => {
              var _a, _b;
              if (noderef.name == "Identifier" && (((_a = noderef.node.parent) == null ? void 0 : _a.name) == "AnonArguments" || ((_b = noderef.node.parent) == null ? void 0 : _b.name) == "Arguments")) {
                if (getCodeName(state, noderef) == term) {
                  linkData.to = noderef.to;
                  linkData.from = noderef.from;
                  linkData.hasLink = true;
                }
              }
            },
            to: anonProc.PositionStart,
            from: anonProc.PositionEnd
          });
        } else {
          for (var vars of anonProc.Variables) {
            if (vars.Name == term) {
              let subnode = syntaxTree5(state).cursorAt(vars.CreationPos).node;
              linkData.to = subnode.to;
              linkData.from = subnode.from;
              linkData.hasLink = true;
            }
          }
        }
      }
    }
  }
  return linkData;
}

// src/lang/services/code-editing.ts
import { indentRange, syntaxTree as syntaxTree6 } from "@codemirror/language";

// src/lang/keywords.ts
var directives = [
  "breed",
  "to",
  "to-report",
  "globals",
  "directed-link-breed",
  "undirected-link-breed",
  "extensions",
  "__includes"
];
var turtleVars = [
  "who",
  "color",
  "heading",
  "xcor",
  "ycor",
  "shape",
  "label",
  "label-color",
  "hidden?",
  "size",
  "pen-size",
  "pen-mode",
  "breed"
];
var patchVars = ["pxcor", "pycor", "pcolor", "plabel", "plabel-color"];
var linkVars = [
  "end1",
  "end2",
  "color",
  "label",
  "label-color",
  "hidden?",
  "breed",
  "thickness",
  "shape",
  "tie-mode"
];
var constants = [
  "true",
  "false",
  "nobody",
  "e",
  "pi",
  "gray",
  "grey",
  "red",
  "orange",
  "brown",
  "yellow",
  "green",
  "lime",
  "turquoise",
  "cyan",
  "sky",
  "blue",
  "violet",
  "magenta",
  "pink",
  "black",
  "white"
];
var unsupported = [
  "ask-concurrent",
  "beep",
  "display",
  "export-interface",
  "file-close",
  "file-close-all",
  "file-delete",
  "file-flush",
  "file-open",
  "file-print",
  "file-show",
  "file-type",
  "file-write",
  "hubnet-broadcast",
  "hubnet-broadcast-clear-output",
  "hubnet-broadcast-message",
  "hubnet-clear-override",
  "hubnet-clear-overrides",
  "hubnet-kick-all-clients",
  "hubnet-kick-client",
  "hubnet-fetch-message",
  "hubnet-reset",
  "hubnet-reset-perspective",
  "hubnet-send",
  "hubnet-send-clear-output",
  "hubnet-send-follow",
  "hubnet-send-message",
  "hubnet-send-override",
  "hubnet-send-watch",
  "wait",
  "inspect",
  "no-display",
  "set-current-directory",
  "file-at-end?",
  "file-exists?",
  "file-read",
  "file-read-characters",
  "file-read-line",
  "hubnet-clients-list",
  "hubnet-enter-message?",
  "hubnet-exit-message?",
  "hubnet-message",
  "hubnet-message-source",
  "hubnet-message-tag",
  "hubnet-message-waiting?",
  "movie-status",
  "user-directory",
  "user-file",
  "user-new-file",
  "user-one-of",
  "__hubnet-clear-plot",
  "__hubnet-make-plot-narrowcast"
];
var reserved = [...directives, ...turtleVars, ...patchVars, ...linkVars, ...constants, ...unsupported];

// src/lang/services/code-editing.ts
var CodeEditing = class {
  /** Constructor: Create a new code editing service. */
  constructor(View) {
    this.View = View;
    this.Galapagos = View.state.field(preprocessStateExtension).Editor;
  }
  /** ChangeCode: Send a changeset into the editor. */
  ChangeCode(Changes) {
    this.View.dispatch({ changes: Changes });
  }
  /** GetSlice: Get a slice of the code. */
  GetSlice(From, To2) {
    return this.View.state.sliceDoc(From, To2);
  }
  /** FindFirstChild: Find the first child that matches a condition. */
  FindFirstChild(Parent, Field, Condition) {
    for (let Child of Parent.getChildren(Field)) {
      if ((Condition == null ? void 0 : Condition(Child)) ?? true) return Child;
    }
    return null;
  }
  /** AddTermToBracket: Add a term to a bracket. */
  AddTermToBracket(Contents, Node) {
    var Identifiers = Node.node.getChildren("Identifier").map((Child) => this.GetSlice(Child.from, Child.to).trim());
    Contents = Contents.filter((Content) => Identifiers.indexOf(Content) == -1);
    if (Contents.length == 0) return false;
    let Seperator = this.View.state.sliceDoc(Node.from, Node.to).includes("\n") ? "\n" : " ";
    var From = this.FindFirstChild(Node, "CloseBracket").from;
    for (let Content of Contents.reverse()) {
      this.ChangeCode({
        from: From,
        to: From,
        insert: Content + Seperator
      });
      this.ChangeCode(indentRange(this.View.state, From, From + 1 + Content.length));
    }
    return true;
  }
  // #endregion
  // #region "Global Statements"
  /** AppendGlobals: Append items of a global statement to the editor. */
  AppendGlobals(Field, Items) {
    Items = [...new Set(Items.filter((Item) => reserved.indexOf(Item) == -1))];
    if (Items.length == 0) return false;
    let Cursor = GetCursorUntilMode(this.View.state);
    if (Cursor) {
      var Statement = this.FindFirstChild(Cursor.node, Field);
      if (Statement) return this.AddTermToBracket(Items, Statement);
    }
    this.ChangeCode({
      from: 0,
      to: 0,
      insert: `${Field.toLowerCase()} [ ${Items.join(" ")} ]
`
    });
    return true;
  }
  /** AppendBreed: Append a breed to the editor. */
  AppendBreed(Type, Plural, Singular) {
    if (Plural == "patches" || Singular == "patch") return false;
    if (Plural == Singular) Singular = getSingularName(Plural);
    for (let [Sin, Breed5] of this.Galapagos.LintContext.Breeds) {
      if (Breed5.Plural == Plural || Breed5.Singular == Singular || Breed5.Singular == Plural || Breed5.Plural == Singular)
        return false;
    }
    var Name = "breed";
    if (Type == 3 /* DirectedLink */) Name = "directed-link-breed";
    if (Type == 2 /* UndirectedLink */) Name = "undirected-link-breed";
    this.ChangeCode({
      from: 0,
      to: 0,
      insert: `${Name} [ ${Plural} ${Singular} ]
`
    });
    return true;
  }
  /** AppendBreedVariables: Add variables to a breed. */
  AppendBreedVariables(Plural, Variables) {
    Variables = [...new Set(Variables.filter((Item) => reserved.indexOf(Item) == -1))];
    if (Variables.length == 0) return false;
    let Cursor = GetCursorInsideMode(this.View.state);
    if (Cursor) {
      while (true) {
        if (Cursor.node.name == "BreedsOwn") {
          var Own3 = this.FindFirstChild(Cursor.node, "Own");
          var Name = this.GetSlice(Own3.from, Own3.to).trim().toLowerCase();
          if (Name === Plural.toLowerCase() + "-own") {
            this.AddTermToBracket(Variables, Cursor.node);
            return true;
          }
        }
        if (!Cursor.nextSibling() || Cursor.node.name === "Procedure") break;
      }
    }
    this.ChangeCode({
      from: 0,
      to: 0,
      insert: `${Plural.toLowerCase()}-own [ ${Variables.join(" ")} ]
`
    });
    return true;
  }
  // #endregion
  // #region "Procedures"
  ReplaceProcedure(view, name2, content2) {
    let index = 0;
    name2 = name2.trim().toLowerCase();
    syntaxTree6(view.state).cursor().iterate((node) => {
      if (node.name == "Procedure" && getCodeName(view.state, node) == name2) {
        index = node.from + content2.length;
        view.dispatch({
          changes: {
            from: node.from,
            to: node.to,
            insert: content2
          }
        });
      }
    });
  }
  // #endregion
};

// src/lang/utils/actions.ts
import { syntaxTree as syntaxTree7 } from "@codemirror/language";
var addBreedAction = function(diagnostic, type, plural, singular) {
  diagnostic.actions = [
    ...diagnostic.actions ?? [],
    {
      name: Localized.Get("Add"),
      apply(view, from, to) {
        new CodeEditing(view).AppendBreed(type, plural, singular);
      }
    }
  ];
  return diagnostic;
};
var addGlobalsAction = function(diagnostic, type, items) {
  diagnostic.actions = [
    ...diagnostic.actions ?? [],
    {
      name: Localized.Get("Add"),
      apply(view, from, to) {
        new CodeEditing(view).AppendGlobals(type, items);
      }
    }
  ];
  return diagnostic;
};
var removeAction = function(diagnostic) {
  diagnostic.actions = [
    ...diagnostic.actions ?? [],
    {
      name: Localized.Get("Remove"),
      apply(view, from, to) {
        view.dispatch({ changes: { from, to, insert: "" } });
      }
    }
  ];
  return diagnostic;
};
var AddReplaceAction = function(diagnostic, replacement) {
  diagnostic.actions = [
    ...diagnostic.actions ?? [],
    {
      name: Localized.Get("Replace"),
      apply(view, from, to) {
        view.dispatch({ changes: { from, to, insert: replacement } });
      }
    }
  ];
  return diagnostic;
};
var explainAction = function(diagnostic, callback) {
  diagnostic.actions = [
    ...diagnostic.actions ?? [],
    {
      name: Localized.Get("Explain"),
      apply(view, from, to) {
        var node = syntaxTree7(view.state).resolve(from, -1);
        callback(diagnostic, getNodeContext(view.state, node));
      }
    }
  ];
  return diagnostic;
};

// src/codemirror/extension-tooltip.ts
var buildToolTips = (Editor) => {
  return hoverTooltip((view, pos, side) => {
    return getTooltips(view, pos, side, Editor);
  });
};
function getTooltips(view, pos, side, editor) {
  var diagnostics = getLintState(view.state).diagnostics;
  let found = [], stackStart = 2e8, stackEnd = 0;
  diagnostics.between(pos - (side < 0 ? 1 : 0), pos + (side > 0 ? 1 : 0), (from, to, { spec }) => {
    if (pos >= from && pos <= to && (from == to || (pos > from || side > 0) && (pos < to || side < 0))) {
      var diagnostic = spec.diagnostic;
      diagnostic.actions = diagnostic.actions ?? [];
      if (diagnostic.actions.length === 0 && editor.Options.OnExplain)
        explainAction(diagnostic, editor.Options.OnExplain);
      found.push(diagnostic);
      stackStart = Math.min(from, stackStart);
      stackEnd = Math.max(to, stackEnd);
    }
  });
  if (found.length == 0) {
    var tooltip = getTooltip2(view, pos, pos, editor);
    if (!tooltip) return null;
    stackStart = tooltip.from;
    stackEnd = tooltip.to;
    found.push(tooltip);
  }
  return {
    pos: stackStart,
    end: stackEnd,
    above: view.state.doc.lineAt(stackStart).to < stackEnd,
    create() {
      return { dom: diagnosticsTooltip(view, found) };
    }
  };
}
function diagnosticsTooltip(view, diagnostics) {
  return elt(
    "ul",
    { class: "cm-tooltip-lint" },
    diagnostics.map((d) => renderDiagnostic(view, d, false))
  );
}
function assignKeys(actions) {
  let assigned = [];
  if (actions)
    actions: for (let { name: name2 } of actions) {
      for (let i = 0; i < name2.length; i++) {
        let ch = name2[i];
        if (/[a-zA-Z]/.test(ch) && !assigned.some((c) => c.toLowerCase() == ch.toLowerCase())) {
          assigned.push(ch);
          continue actions;
        }
      }
      assigned.push("");
    }
  return assigned;
}
function renderDiagnostic(view, diagnostic, inPanel) {
  var _a;
  let keys = inPanel ? assignKeys(diagnostic.actions) : [];
  return elt(
    "li",
    { class: "cm-diagnostic cm-diagnostic-" + diagnostic.severity },
    elt(
      "span",
      { class: "cm-diagnosticText" },
      diagnostic.renderMessage ? diagnostic.renderMessage(view) : diagnostic.message
    ),
    (_a = diagnostic.actions) == null ? void 0 : _a.map((action, i) => {
      let fired = false, click = (e) => {
        e.preventDefault();
        if (fired) return;
        fired = true;
        let found = findDiagnostic(getLintState(view.state).diagnostics, diagnostic);
        if (found) action.apply(view, found.from, found.to);
      };
      let { name: name2 } = action, keyIndex = keys[i] ? name2.indexOf(keys[i]) : -1;
      let nameElt = keyIndex < 0 ? name2 : [name2.slice(0, keyIndex), elt("u", name2.slice(keyIndex, keyIndex + 1)), name2.slice(keyIndex + 1)];
      return elt(
        "button",
        {
          type: "button",
          class: "cm-diagnosticAction",
          onclick: click,
          onmousedown: click,
          "aria-label": ` Action: ${name2}${keyIndex < 0 ? "" : ` (access key "${keys[i]})"`}.`
        },
        nameElt
      );
    }),
    diagnostic.source && elt("div", { class: "cm-diagnosticSource" }, diagnostic.source)
  );
}
function findDiagnostic(diagnostics, diagnostic = null, after = 0) {
  let found = null;
  diagnostics.between(after, 1e9, (from, to, { spec }) => {
    if (diagnostic && spec.diagnostic != diagnostic) return;
    found = new SelectedDiagnostic(from, to, spec.diagnostic);
    return false;
  });
  return found;
}
var SelectedDiagnostic = class {
  constructor(from, to, diagnostic) {
    this.from = from;
    this.to = to;
    this.diagnostic = diagnostic;
  }
};

// src/codemirror/theme-light.ts
import { EditorView as EditorView4 } from "@codemirror/view";
var lightTheme = EditorView4.theme({
  "&.cm-editor": {
    height: "100%",
    "&.cm-focused": {
      outline: "none"
    }
  },
  ".cm-diagnostic": {
    fontSize: "0.9em",
    padding: "0.3em 0.5em"
  },
  ".cm-tooltip-extendable": {
    cursor: "pointer"
  },
  ".cm-tooltip-extendable:hover": {
    textDecoration: "underline"
  },
  ".cm-editor.cm-focused": {
    outline: "none"
  },
  ".cm-gutter-lint": {
    width: "3px"
  },
  ".cm-gutter-lint .cm-gutterElement": {
    padding: "0"
  },
  ".cm-lint-marker": {
    width: "100%",
    height: "100%"
  },
  ".cm-lint-marker-error": {
    background: "#cc2200",
    content: "none"
  },
  ".cm-lint-marker-warning": {
    background: "#FAD842",
    content: "none"
  },
  ".cm-added": {
    textDecoration: "overline underline",
    textDecorationColor: "#117432",
    textDecorationThickness: "2px"
  },
  ".cm-removed": {
    textDecoration: "overline underline",
    textDecorationColor: "#cc2200",
    textDecorationThickness: "2px"
  },
  ".cm-gutters": {
    userSelect: "none",
    webkitUserSelect: "none",
    msUserSelect: "none"
  }
});

// src/lang/lang.js
import { LRParser } from "@lezer/lr";

// src/lang/tokenizer.ts
import { ExternalTokenizer } from "@lezer/lr";
var primitives2 = PrimitiveManager;
var checker = generateChecker();
var keyword2 = new ExternalTokenizer((input, stack) => {
  let token = "";
  while (input.next >= 255 || checker[input.next]) {
    token += String.fromCharCode(input.next);
    input.advance();
  }
  if (token == "") return;
  token = token.toLowerCase();
  if (stack.context.extensionsGlobals || stack.context.procedureName < 2) {
    input.acceptToken(Identifier);
    return;
  }
  if (token == "set") {
    input.acceptToken(Set2);
  } else if (token == "let") {
    input.acceptToken(Let);
  } else if (token == "to" || token == "to-report") {
    input.acceptToken(To);
  } else if (token == "end") {
    input.acceptToken(End);
  } else if (token == "and" || token == "or" || token == "xor") {
    input.acceptToken(AndOr);
  } else if (token == "globals") {
    input.acceptToken(GlobalStr);
  } else if (token == "extensions") {
    input.acceptToken(ExtensionStr);
  } else if (token == "foreach") {
    input.acceptToken(APCommand);
  } else if (token == "n-values") {
    input.acceptToken(APReporterFlip);
  } else if (token == "map") {
    input.acceptToken(APReporterVar);
  } else if (token == "reduce" || token == "filter" || token == "sort-by") {
    input.acceptToken(APReporter);
  } else if ([
    "+",
    "*",
    "/",
    "^",
    "=",
    "!=",
    ">",
    "<",
    "<=",
    ">=",
    "and",
    "or",
    "mod",
    "in-radius",
    "at-points",
    "of",
    "with",
    "with-max",
    "with-min"
  ].indexOf(token) > -1) {
    input.acceptToken(ReporterLeft1Args);
  } else if (token == "-") {
    input.acceptToken(ReporterLeft1ArgsOpt);
  } else if (token == "in-cone") {
    input.acceptToken(ReporterLeft2Args);
  } else if (token == "breed") {
    if (stack.context.globalStatement) {
      input.acceptToken(BreedStr);
      return;
    }
    let offset = 0;
    let foundText = false;
    let seenBracket = false;
    let nextToken = "";
    while (offset < 100 && (isValidKeyword(input.peek(offset)) || !foundText)) {
      if (isValidKeyword(input.peek(offset))) {
        nextToken += String.fromCharCode(input.peek(offset));
        foundText = true;
      } else if (input.peek(offset) == 91) {
        seenBracket = true;
      }
      offset++;
    }
    if (seenBracket && [...GetContext().PluralBreeds.keys()].includes(nextToken.toLowerCase())) {
      input.acceptToken(BreedStr);
    } else {
      input.acceptToken(BreedToken);
    }
  } else if (token == "directed-link-breed" || token == "undirected-link-breed") {
    input.acceptToken(BreedStr);
  } else if (turtleVars.indexOf(token) != -1) {
    input.acceptToken(TurtleVar);
  } else if (patchVars.indexOf(token) != -1) {
    input.acceptToken(PatchVar);
  } else if (linkVars.indexOf(token) != -1) {
    input.acceptToken(LinkVar);
  } else if (constants.indexOf(token) != -1) {
    input.acceptToken(Constant);
  } else {
    const primitive = PrimitiveManager.GetNamedPrimitive(token);
    if (primitive != null) {
      if (PrimitiveManager.IsReporter(primitive)) {
        input.acceptToken(Reporter);
      } else {
        input.acceptToken(Command);
      }
      return;
    }
    const match = MatchBreed(token, GetContext());
    if (match.Tag != 0 && match.Valid) {
      input.acceptToken(match.Tag);
      return;
    }
    const customMatch = matchCustomProcedure(token);
    if (customMatch != 0) {
      input.acceptToken(customMatch);
      return;
    } else if (match.Tag != 0) {
      input.acceptToken(match.Tag);
    } else if (token.match(/^create-[^\?]+$/i)) {
      input.acceptToken(SpecialCommandCreateTurtlePossible);
    } else if (token.indexOf(":") != -1 && primitives2.GetExtensions().indexOf(token.split(":")[0]) == -1) {
      input.acceptToken(UnsupportedPrim);
    } else {
      input.acceptToken(Identifier);
    }
  }
});
function isValidKeyword(ch) {
  return ch >= 160 || // Unicode characters
  ch == 35 || //#
  ch == 33 || // !
  ch == 37 || // %
  ch == 39 || // '
  ch == 63 || // ?
  // 0-9
  ch >= 42 && ch <= 58 || // -
  ch == 45 || ch == 94 || // _
  ch == 95 || // A-Z
  ch >= 60 && ch <= 90 || ch == 94 || ch == 95 || // a-z
  ch >= 97 && ch <= 122;
}
function generateChecker() {
  let c = [];
  for (var i = 0; i < 256; i++) {
    c.push(isValidKeyword(i));
  }
  return c;
}
function matchCustomProcedure(token) {
  let parseContext = GetContext();
  if (parseContext.Commands.has(token)) return SpecialCommand;
  if (parseContext.Reporters.has(token)) return SpecialReporter;
  return 0;
}

// src/lang/context-tracker.ts
import { ContextTracker } from "@lezer/lr";
var contextTracker = new ContextTracker({
  //false,
  start: {
    extensionsGlobals: false,
    globalStatement: true,
    procedureName: 2
  },
  shift: (context, term, stack, input) => {
    let globalStatements = input.pos == 0 ? true : context.globalStatement;
    let procedureName = context.procedureName < 2 ? context.procedureName + 1 : context.procedureName;
    let token = "";
    if (input.next == 93) {
      input.advance();
      return {
        extensionsGlobals: false,
        globalStatement: globalStatements,
        procedureName
      };
    }
    while (isValidKeyword(input.next)) {
      token += String.fromCharCode(input.next).toLowerCase();
      input.advance();
    }
    token = token.toLowerCase();
    if (token == "extensions" || token == "globals" || token == "breed" || token == "directed-link-breed" || token == "undirected-link-breed" || token.endsWith("-own")) {
      while (input.next == 32) {
        input.advance();
      }
      if (input.next == 91 && globalStatements) {
        return {
          extensionsGlobals: true,
          globalStatement: globalStatements,
          procedureName
        };
      }
    } else if (token == "to" || token == "to-report") {
      return {
        extensionsGlobals: context.extensionsGlobals,
        globalStatement: false,
        procedureName: 0
      };
    } else if (token == "end") {
      return {
        extensionsGlobals: context.extensionsGlobals,
        globalStatement: true,
        procedureName
      };
    }
    return {
      extensionsGlobals: context.extensionsGlobals,
      globalStatement: globalStatements,
      procedureName
    };
  }
});

// src/lang/specializer.ts
var primitives3 = PrimitiveManager;
var specializeReporter = function(token) {
  token = token.toLowerCase();
  if (token == "se" || token == "list" || token == "sentence" || token == "word") {
    return Reporter2ArgsVar0;
  } else if (token == "patch-set" || token == "link-set" || token == "turtle-set") {
    return Reporter1ArgsVar0;
  }
  let reporter = primitives3.GetPrimitive("", token);
  if (reporter) {
    let repeats = false;
    let args = reporter == null ? void 0 : reporter.RightArgumentTypes.length;
    reporter.RightArgumentTypes.map((arg) => {
      if (arg.CanRepeat) {
        repeats = true;
        if (reporter == null ? void 0 : reporter.DefaultOption) {
          args = reporter == null ? void 0 : reporter.DefaultOption;
        }
      }
    });
    if (repeats) {
      if (args == 0) {
        return Reporter0ArgsVar;
      } else if (args == 1) {
        return Reporter1ArgsVar;
      } else if (args == 2) {
        return Reporter2ArgsVar;
      } else if (args == 3) {
        return Reporter3ArgsVar;
      } else if (args == 4) {
        return Reporter4ArgsVar;
      } else if (args == 5) {
        return Reporter5ArgsVar;
      } else if (args == 6) {
        return Reporter6ArgsVar;
      }
    } else {
      if (args == 0) {
        return Reporter0Args;
      } else if (args == 1) {
        return Reporter1Args;
      } else if (args == 2) {
        return Reporter2Args;
      } else if (args == 3) {
        return Reporter3Args;
      } else if (args == 4) {
        return Reporter4Args;
      } else if (args == 5) {
        return Reporter5Args;
      } else if (args == 6) {
        return Reporter6Args;
      }
    }
  } else {
    return -1;
  }
};
var specializeSpecialReporter = function(token) {
  token = token.toLowerCase();
  let parseContext = GetContext();
  let reporters = parseContext.Reporters;
  if (reporters.has(token)) {
    let args = reporters.get(token);
    if (args == 0) {
      return SpecialReporter0Args;
    } else if (args == 1) {
      return SpecialReporter1Args;
    } else if (args == 2) {
      return SpecialReporter2Args;
    } else if (args == 3) {
      return SpecialReporter3Args;
    } else if (args == 4) {
      return SpecialReporter4Args;
    } else if (args == 5) {
      return SpecialReporter5Args;
    } else if (args == 6) {
      return SpecialReporter6Args;
    } else {
      return -1;
    }
  }
};
var specializeCommand = function(token) {
  token = token.toLowerCase();
  if (token == "ifelse" || token == "if-else") return Command3ArgsVar2;
  if (token == "create-turtles") return SpecialCommandCreateTurtle;
  if (token == "create-links") return SpecialCommandCreateLink;
  let commands = primitives3.GetPrimitive("", token);
  if (commands) {
    let repeats = false;
    let nonoptional = 0;
    let args = commands == null ? void 0 : commands.RightArgumentTypes.length;
    commands.RightArgumentTypes.map((arg) => {
      if (arg.CanRepeat) {
        repeats = true;
        if (commands == null ? void 0 : commands.DefaultOption) {
          args = commands == null ? void 0 : commands.DefaultOption;
        }
      }
      if (!arg.Optional) {
        nonoptional += 1;
      }
    });
    if (repeats) {
      if (args == 0) {
        return Command0ArgsVar;
      } else if (args == 1) {
        return Command1ArgsVar;
      } else if (args == 2) {
        return Command2ArgsVar;
      } else if (args == 3) {
        return Command3ArgsVar;
      } else if (args == 4) {
        return Command4ArgsVar;
      } else if (args == 5) {
        return Command5ArgsVar;
      } else if (args == 6) {
        return Command6ArgsVar;
      }
    } else if (nonoptional == 1 && args == 2) {
      return Command1_2ArgsOpt;
    } else {
      if (args == 0) {
        return Command0Args;
      } else if (args == 1) {
        return Command1Args;
      } else if (args == 2) {
        return Command2Args;
      } else if (args == 3) {
        return Command3Args;
      } else if (args == 4) {
        return Command4Args;
      } else if (args == 5) {
        return Command5Args;
      } else if (args == 6) {
        return Command6Args;
      }
    }
  } else {
    return -1;
  }
};
var specializeSpecialCommand = function(token) {
  token = token.toLowerCase();
  let parseContext = GetContext();
  let commands = parseContext.Commands;
  if (commands.has(token)) {
    let args = commands.get(token);
    if (args == 0) {
      return SpecialCommand0Args;
    } else if (args == 1) {
      return SpecialCommand1Args;
    } else if (args == 2) {
      return SpecialCommand2Args;
    } else if (args == 3) {
      return SpecialCommand3Args;
    } else if (args == 4) {
      return SpecialCommand4Args;
    } else if (args == 5) {
      return SpecialCommand5Args;
    } else if (args == 6) {
      return SpecialCommand6Args;
    } else {
      return -1;
    }
  } else {
    return -1;
  }
};

// src/lang/lang.js
var parser = LRParser.deserialize({
  version: 14,
  states: "&+bO$OQROOO&jQRO'#E]O+jQPO'#ElO+oQPO'#EmO+tQPO'#EnO+yQPO'#EqOOQQ'#Fg'#FgO1RQRO'#EsOOQQ'#E_'#E_O1`QRO'#E_O4jQRO'#E_O5TQRO'#E_O5bQRO'#E_O5bQRO'#E_O5bQRO'#E_O5bQRO'#E_O5bQRO'#E_O8aQRO'#E_O5bQRO'#E_O5bQRO'#E_O5bQRO'#E_O5bQRO'#E_O5bQRO'#E_O5bQRO'#E_O8zQRO'#E_O;ZQRO'#E_O8zQRO'#E_OOQQ'#Et'#EtOOQQ'#Ex'#ExO>YQRO'#ExOOQQ'#EY'#EYO>mQRO'#FTOOQQ'#EX'#EXO5bQRO'#FiO?OQRO'#E|OAqQRO'#E}OOQQ'#E{'#E{OOQQ'#EW'#EWODgQRO'#EWO5bQRO'#EWO5bQRO'#EWO5bQRO'#EWO5bQRO'#EWO5bQRO'#EWOLoQRO'#EWO5bQRO'#EWO5bQRO'#EWO5bQRO'#EWO5bQRO'#EWO5bQRO'#EWO5bQRO'#EWO5bQRO'#EWOLvQRO'#FUOOQQ'#FU'#FUO!#dQRO'#EVO!%mQRO'#FROOQQ'#Fa'#FaO!&^QRO'#FPQOQPOOO&jQRO'#E]O!(]QRO,5:wO!(nQRO,5:zO!)PQRO'#FeO!,OQPO,5:{O!,TQPO,5;UO!,YQRO,5;WO!,bQRO,5;XO!,jQRO,5;YO!,uQRO,5;]O!,}QRO'#FWO!0rQRO'#FWO!1lQRO'#EfO!1wQRO'#EgOOQO'#Ef'#EfOOQQ'#Ek'#EkO!2gQRO'#ExOOQQ'#Ei'#EiO!3PQRO'#EiO!5zQPO,5;PO!6PQRO'#F[O!9oQRO,5;_O!ChQRO,5;_O!EdQRO'#F]OOQQ'#F]'#F]O!H_QRO,5;cO!JpQRO,5;fO!KRQRO,5;eO5bQRO'#FfOOQQ,5:y,5:yO5TQRO,5:yO!KdQRO,5:yO!KuQRO'#E_O#)QQRO,5:yO#)kQRO,5:yO#)kQRO,5:yO#)kQRO,5:yO#)kQRO,5:yO#){QRO'#FVO#/qQRO,5:yO#)kQRO,5:yO#)kQRO,5:yO#)kQRO,5:yO#)kQRO,5:yO#)kQRO,5:yO#5XQRO'#ErOOQQ'#Eb'#EbO#7{QRO,5:yO5bQRO,5:yO#8SQRO,5<TOOQQ'#Fk'#FkOOQQ'#Fj'#FjODgQRO,5;hO#:qQRO,5;hODgQRO,5;iO#=aQRO,5;iO#BlQRO,5:rO#B|QRO,5:rO#)kQRO,5:rO#)kQRO,5:rO#)kQRO,5:rO#)kQRO,5:rO#C^QRO,5:rO#)kQRO,5:rO#)kQRO,5:rO#)kQRO,5:rO#)kQRO,5:rO#)kQRO,5:rO#JlQRO,5:rO#LsQRO'#EjO5bQRO'#FiOOQQ-E9S-E9SOOQQ'#FS'#FSO#L}QRO,5;mOOQQ'#FQ'#FQOOQQ-E9_-E9_O$ SQPO,5:xO$ XQRO1G0cO$$yQRO1G0fO$(kQRO,5<POOQQ1G0g1G0gO$+`QRO1G0pOOQQ'#FY'#FYO$+jQRO1G0rOOQQ1G0r1G0rO$+rQRO1G0sOOQQ1G0s1G0sOOQQ'#Eo'#EoO$+zQRO1G0tO$,SQRO1G0wOOQQ1G0w1G0wOOQQ'#FW'#FWOOQQ-E9U-E9UO$,[QRO,5;RO$1dQRO,5;RO!,jQRO,5;VO$2yQRO1G0kOOQQ'#F['#F[OOQQ-E9Y-E9YO$3ZQRO'#EsOOQQ1G0y1G0yO$3bQRO'#EjO$6cQPO'#EkO$6hQRO'#EsOOQQ-E9Z-E9ZOOQQ1G0}1G0}OOQQ1G1Q1G1QOOQQ1G1P1G1PO$8yQRO,5<QO$9ZQRO1G0eO#)QQRO1G0eO#)kQRO1G0eO#)kQRO1G0eO#)kQRO1G0eOOQQ-E9T-E9TO$9lQRO1G0eO#)kQRO1G0eO#)kQRO1G0eO#)kQRO1G0eO#)kQRO1G0eO$:VQRO'#FWOOQQ'#FX'#FXO$:dQRO,5;^O$?qQRO'#FZO$BwQRO,5;^OOQQ,5;^,5;^O$COQRO,5;^O$F{QRO'#EbO$IZQRO'#EbOOQQ1G0e1G0eO$LZQRO1G1nO$LnQRO'#FlOOQQ1G1S1G1SOOQQ'#F^'#F^O%$aQRO1G1SOOQQ1G1T1G1TOOQQ'#F`'#F`O%$hQRO1G1TO%'XQRO1G0^O#B|QRO1G0^O#)kQRO1G0^O#)kQRO1G0^O#)kQRO1G0^O%'iQRO1G0^O#)kQRO1G0^O#)kQRO1G0^O#)kQRO1G0^O#)kQRO1G0^O%/jQRO'#ErO%7OQRO'#ExO%>dQRO'#EYOOQQ'#FO'#FOOOQQ1G0^1G0^O%>kQPO,5;UO%>pQRO'#EgO%>{QRO1G1XOOQQ1G1X1G1XO%>{QRO1G1XOOQQ1G0d1G0dOOQQ-E9W-E9WOOQQ7+&^7+&^OOQQ7+&_7+&_OOQO'#Ep'#EpO%@}QPO7+&`OOQQ7+&c7+&cOOQQ1G0m1G0mO$+zQRO1G0qO%ASQRO7+&VO%CUQRO7+&VOOQQ7+&V7+&VO%C]QRO7+&VOOQQ,5;_,5;_O%CnQRO,5:xO%DPQRO'#F[O%G[QRO1G1lO%GsQRO7+&PO#)QQRO7+&PO#)kQRO7+&PO#)kQRO7+&PO%HUQRO7+&PO#)kQRO7+&PO#)kQRO7+&PO#)kQRO7+&POOQQ-E9V-E9VOOQQ1G0x1G0xOOQQ-E9X-E9XOOQQ-E9[-E9[O%HoQPO7+&nOOQQ-E9^-E9^O%HtQPO7+&oO%KcQRO7+%xO#B|QRO7+%xO#)kQRO7+%xO#)kQRO7+%xO%KsQRO7+%xO#)kQRO7+%xO#)kQRO7+%xO#)kQRO7+%xO&#dQRO'#FXO&&OQRO,5;eO&&VQRO,5;^O&(qQRO,5;^OOQQ1G0p1G0pO&)SQRO,5;ROOQQ,5;R,5;ROOQQ7+&s7+&sO&)_QRO7+&sOOQQ<<Iz<<IzO&+aQPO7+&]OOQQ<<Iq<<IqOOQQ7+&P7+&PO&+fQRO<<IkO#)QQRO<<IkO#)kQRO<<IkO&+wQRO<<IkO#)kQRO<<IkO#)kQRO<<IkO5bQRO<<JYO5bQRO<<JZO&.zQRO<<IdO#B|QRO<<IdO#)kQRO<<IdO&/[QRO<<IdO#)kQRO<<IdO#)kQRO<<IdO&2SQRO1G0xOOQQ<<J_<<J_OOQQ<<Iw<<IwOOQQ<<Ik<<IkO&7xQROAN?VO#)QQROAN?VO&8ZQROAN?VO#)kQROAN?VOOQQ'#F_'#F_O&8tQROAN?tO&8{QROAN?uO&;lQROAN?OO#B|QROAN?OO&;|QROAN?OO#)kQROAN?OOOQQAN?VAN?VO&>tQROG24qO&?VQROG24qOOQQ-E9]-E9]OOQQG25`G25`OOQQG25aG25aO&BYQROG24jO&BjQROG24jOOQQG24qG24qO&EbQRO'#E_O5bQRO'#E_O&KRQRO'#E_O'#_QRO'#E_O')RQRO'#E_O')YQRO'#E_O'+sQRO'#E_O5bQRO'#E_O5bQRO'#E_O5bQRO'#E_O5bQRO'#E_O5bQRO'#E_O5bQRO'#E_O!)PQRO'#EWO'.zQRO'#EWO'1yQRO'#EWO'4xQRO'#EWO'7wQRO'#EWO':vQRO'#EWO':}QRO'#EWO'={QRO'#EWO'>SQRO'#EWO'@}QRO'#FeO5bQRO'#FeO'C|QRO'#FeO'F{QRO'#FeO'IzQRO'#FeO'LyQRO'#FeO( xQRO'#FeO($wQRO'#FeO('vQRO'#FeO(*uQRO'#FeO(-tQRO'#FeO(0sQRO'#FeO(3rQRO'#FeO(6qQRO'#FeO(9pQRO'#FeO(<oQRO'#FeO(?nQRO'#FWO(?uQRO'#FWO(@rQRO'#FWO(DiQRO'#FWO5bQRO,5:yO'C|QRO,5:yO'F{QRO,5:yO'IzQRO,5:yO'LyQRO,5:yO( xQRO,5:yO(HPQRO,5:yO($wQRO,5:yO('vQRO,5:yO(KOQRO,5:yO;ZQRO,5:yO(M}QRO,5:yO(*uQRO,5:yO)!|QRO,5:yO(-tQRO,5:yO)%{QRO,5:yO(0sQRO,5:yO(3rQRO,5:yO)(zQRO,5:yO)+yQRO,5:yO(9pQRO,5:yODgQRO,5:yO'.zQRO,5:yO(<oQRO,5:yO(6qQRO,5:yO'4xQRO,5:yO'@}QRO,5:yO'7wQRO,5:yO).xQRO,5:yO)2]QRO,5:yO)7|QRO,5:yO):vQRO,5:yO)=mQRO,5:yO)@WQRO,5:yO)@_QRO,5:yO)C_QRO,5:yO)EuQRO,5:yO)HoQRO,5:yO)KiQRO,5:yO)N`QRO,5:yO*!yQRO,5:yO*#QQRO,5:yO*&QQRO,5:yO*(hQRO,5:yO*(oQRO'#E_O#)kQRO,5:yO*){QRO,5:yO**]QRO,5:yO**mQRO,5:yO**}QRO,5:yO*+_QRO,5:yO*+oQRO,5:yO*,PQRO,5:yO*,aQRO,5:yO*,qQRO,5:yO*-RQRO,5:yO*-cQRO,5:yO*-sQRO,5:yO*.TQRO,5:yO*.eQRO,5:yO*.uQRO,5:yO*/VQRO,5:yO*/gQRO,5:yO*/wQRO,5:yO*0XQRO,5:yO*0iQRO,5:yO#B|QRO,5:yO*0yQRO,5:yO*1ZQRO,5:yO*1kQRO,5:yO*1{QRO,5:yO*2]QRO,5:yO*2mQRO,5:yO*2}QRO,5:yO*4TQRO,5:yO*7_QRO,5:yO*:iQRO,5:yO*=sQRO,5:yO#)kQRO,5:yO*@bQRO,5:yO5bQRO,5:yO*@iQRO,5<TO*@|QRO,5<TO*ChQRO,5<TO*FSQRO,5<TO*HqQRO,5<TO!)PQRO,5;hO'.zQRO,5;hO'1yQRO,5;hO'4xQRO,5;hO'7wQRO,5;hO!)PQRO,5;iO'.zQRO,5;iO'1yQRO,5;iO'4xQRO,5;iO'7wQRO,5;iO*K]QRO,5:rO*NWQRO,5:rO+#QQRO,5:rO+%wQRO,5:rO+(_QRO,5:rO+(rQRO,5:rO$8yQRO,5:rO*0yQRO,5:rO+)cQRO,5:rO*1{QRO,5:rO*2mQRO,5:rO+)sQRO,5:rO+)zQRO,5:rO+,rQRO,5:rO+/mQRO,5:rO5bQRO'#FiO5bQRO'#FiO5bQRO'#FiO5bQRO'#FiO5bQRO'#FiO+2bQRO1G0cO+:^QRO1G0fO+H[QRO1G0fO+HoQRO1G0fO+BYQRO1G0fO+LZQRO,5<PO, hQRO,5<PO,'UQRO,5<PO,*OQRO,5<PO,,uQRO,5<PO,/`QRO,5<PO,/jQRO,5<PO,2gQRO,5<PO,4}QRO,5<PO,5XQRO,5<PO,5pQRO,5<PO,5zQRO,5<PO,6UQRO,5<PO,6`QRO,5<PO,6jQRO,5<PO,6wQRO,5<PO,7RQRO,5<PO,7]QRO1G0pO#)kQRO,5<QO*){QRO,5<QO**]QRO,5<QO**mQRO,5<QO**}QRO,5<QO*+_QRO,5<QO*+oQRO,5<QO*,PQRO,5<QO*,aQRO,5<QO*,qQRO,5<QO*0XQRO,5<QO*-cQRO,5<QO*.TQRO,5<QO*.uQRO,5<QO*/wQRO,5<QO,;PQRO1G0eO,>dQRO1G0eO,DTQRO1G0eO,F}QRO1G0eO,ItQRO1G0eO,L_QRO1G0eO,LfQRO1G0eO- fQRO1G0eO-#|QRO1G0eO-&vQRO1G0eO-)pQRO1G0eO-,gQRO1G0eO-/QQRO1G0eO-/XQRO1G0eO-2XQRO1G0eO-4oQRO1G0eO#)kQRO1G0eO*){QRO1G0eO**]QRO1G0eO**mQRO1G0eO**}QRO1G0eO*+_QRO1G0eO*+oQRO1G0eO*,PQRO1G0eO*,aQRO1G0eO*,qQRO1G0eO*-RQRO1G0eO*-cQRO1G0eO*-sQRO1G0eO*.TQRO1G0eO*.eQRO1G0eO*.uQRO1G0eO*/VQRO1G0eO*/gQRO1G0eO*/wQRO1G0eO*0XQRO1G0eO*0iQRO1G0eO#B|QRO1G0eO*0yQRO1G0eO*1ZQRO1G0eO*1kQRO1G0eO*1{QRO1G0eO*2]QRO1G0eO*2mQRO1G0eO-4vQRO1G0eO-5|QRO1G0eO-9WQRO1G0eO-<bQRO1G0eO-?lQRO1G0eO#)kQRO1G0eO-C[QRO'#EbO-EjQRO'#EbO-HtQRO'#EbO-JvQRO'#EbO-NQQRO'#EbO.#XQRO1G1nO.&PQRO1G1nO.&dQRO1G1nO.&wQRO1G1nO.)_QRO1G1nO.)rQRO1G1nO.*fQRO1G0^O.-aQRO1G0^O.0ZQRO1G0^O.3QQRO1G0^O.5hQRO1G0^O.5{QRO1G0^O$8yQRO1G0^O*0yQRO1G0^O+)cQRO1G0^O*1{QRO1G0^O*2mQRO1G0^O.6lQRO1G0^O.6sQRO1G0^O.9kQRO1G0^O.<fQRO1G0^O.DTQRO'#ExO.D[QRO'#ExO%/qQRO'#ExO.FyQRO'#ExO.NnQRO'#EYO.NuQRO'#EYO%7VQRO'#EYO/#dQRO'#EYO/)ZQRO1G1lO/.zQRO1G1lO/1tQRO1G1lO/4kQRO1G1lO/7UQRO1G1lO/7]QRO1G1lO/:]QRO1G1lO/<sQRO1G1lO/<zQRO7+&PO/@_QRO7+&PO/FOQRO7+&PO/HxQRO7+&PO/KoQRO7+&PO/NYQRO7+&PO/NaQRO7+&PO0#aQRO7+&PO0%wQRO7+&PO0(qQRO7+&PO0+kQRO7+&PO0.bQRO7+&PO00{QRO7+&PO01SQRO7+&PO04SQRO7+&PO06jQRO7+&PO#)kQRO7+&PO*){QRO7+&PO**]QRO7+&PO**mQRO7+&PO**}QRO7+&PO*+_QRO7+&PO*+oQRO7+&PO*,PQRO7+&PO*,aQRO7+&PO*,qQRO7+&PO*-RQRO7+&PO*-cQRO7+&PO*-sQRO7+&PO*.TQRO7+&PO*.eQRO7+&PO*.uQRO7+&PO*/VQRO7+&PO*/gQRO7+&PO*/wQRO7+&PO*0XQRO7+&PO*0iQRO7+&PO#B|QRO7+&PO*0yQRO7+&PO*1ZQRO7+&PO*1kQRO7+&PO*1{QRO7+&PO*2]QRO7+&PO*2mQRO7+&PO06qQRO7+&PO07wQRO7+&PO0;RQRO7+&PO0>]QRO7+&PO0AgQRO7+&PO#)kQRO7+&PO0DUQRO7+%xO0GPQRO7+%xO0IyQRO7+%xO0LpQRO7+%xO1 WQRO7+%xO1 kQRO7+%xO$8yQRO7+%xO*0yQRO7+%xO+)cQRO7+%xO*1{QRO7+%xO*2mQRO7+%xO1![QRO7+%xO1!cQRO7+%xO1%ZQRO7+%xO1(UQRO7+%xO1*yQRO,5;^O1+QQRO,5;^O1-oQRO,5;^O10WQRO,5;^O13RQRO<<IkO16fQRO<<IkO1<VQRO<<IkO1?PQRO<<IkO1AvQRO<<IkO1DaQRO<<IkO1DhQRO<<IkO1GhQRO<<IkO1JOQRO<<IkO1LxQRO<<IkO2 rQRO<<IkO2$iQRO<<IkO2'SQRO<<IkO2'ZQRO<<IkO2*ZQRO<<IkO2,qQRO<<IkO#)kQRO<<IkO*){QRO<<IkO**]QRO<<IkO**mQRO<<IkO**}QRO<<IkO*+_QRO<<IkO*+oQRO<<IkO*,PQRO<<IkO*,aQRO<<IkO*,qQRO<<IkO*-RQRO<<IkO*-cQRO<<IkO*-sQRO<<IkO*.TQRO<<IkO*.eQRO<<IkO*.uQRO<<IkO*/VQRO<<IkO*/gQRO<<IkO*/wQRO<<IkO*0XQRO<<IkO*0iQRO<<IkO#B|QRO<<IkO*0yQRO<<IkO*1ZQRO<<IkO*1kQRO<<IkO*1{QRO<<IkO*2]QRO<<IkO*2mQRO<<IkO2,xQRO<<IkO2.OQRO<<IkO21YQRO<<IkO24dQRO<<IkO27nQRO<<IkO#)kQRO<<IkO2:]QRO<<IdO2=WQRO<<IdO2@QQRO<<IdO2BwQRO<<IdO2E_QRO<<IdO2ErQRO<<IdO$8yQRO<<IdO*0yQRO<<IdO+)cQRO<<IdO*1{QRO<<IdO*2mQRO<<IdO2FcQRO<<IdO2FjQRO<<IdO2IbQRO<<IdO2L]QRO<<IdO3 QQROAN?VO3$eQROAN?VO3*UQROAN?VO3-OQROAN?VO3/uQROAN?VO32`QROAN?VO32gQROAN?VO35gQROAN?VO37}QROAN?VO3:wQROAN?VO3=qQROAN?VO3@hQROAN?VO3CRQROAN?VO3CYQROAN?VO3FYQROAN?VO3HpQROAN?VO#)kQROAN?VO*){QROAN?VO**]QROAN?VO**mQROAN?VO**}QROAN?VO*+_QROAN?VO*+oQROAN?VO*,PQROAN?VO*,aQROAN?VO*,qQROAN?VO*-RQROAN?VO*-cQROAN?VO*-sQROAN?VO*.TQROAN?VO*.eQROAN?VO*.uQROAN?VO*/VQROAN?VO*/gQROAN?VO*/wQROAN?VO*0XQROAN?VO*0iQROAN?VO#B|QROAN?VO*0yQROAN?VO*1ZQROAN?VO*1kQROAN?VO*1{QROAN?VO*2]QROAN?VO*2mQROAN?VO3HwQROAN?VO3I}QROAN?VO3MXQROAN?VO4!cQROAN?VO4%mQROAN?VO#)kQROAN?VO4([QROAN?OO4+VQROAN?OO4.PQROAN?OO40vQROAN?OO43^QROAN?OO43qQROAN?OO$8yQROAN?OO*0yQROAN?OO+)cQROAN?OO*1{QROAN?OO*2mQROAN?OO44bQROAN?OO44iQROAN?OO47aQROAN?OO4:[QROAN?OO4=PQROG24qO4@dQROG24qO4FTQROG24qO4H}QROG24qO4KtQROG24qO4N_QROG24qO4NfQROG24qO5#fQROG24qO5%|QROG24qO5(vQROG24qO5+pQROG24qO5.gQROG24qO51QQROG24qO51XQROG24qO54XQROG24qO56oQROG24qO56vQROG24qO57|QROG24qO5;WQROG24qO5>bQROG24qO5AlQROG24qO5DZQROG24jO5GUQROG24jO5JOQROG24jO5LuQROG24jO6 ]QROG24jO6 pQROG24jO6!aQROG24jO6!hQROG24jO6%`QROG24jO6(ZQROG24jO6+OQRO'#E_O6+^QRO'#E_O6+lQRO'#E_O6+zQRO'#E_O6,YQRO'#E_O6,hQRO'#E_O6,vQRO'#E_O6-UQRO'#E_O!)PQRO'#E_O)(zQRO'#E_O(3rQRO'#E_O)+yQRO'#E_O(0sQRO'#E_O)%{QRO'#E_O(9pQRO'#E_O(-tQRO'#E_O)!|QRO'#E_O'.zQRO'#E_O(*uQRO'#E_O(M}QRO'#E_O(<oQRO'#E_O(6qQRO'#E_O'1yQRO'#E_O(KOQRO'#E_O'4xQRO'#E_O6-dQRO'#E_O('vQRO'#E_O'@}QRO'#E_O'7wQRO'#E_O($wQRO'#E_O(HPQRO'#E_O( xQRO'#E_O'LyQRO'#E_ODgQRO'#E_O'IzQRO'#E_O;ZQRO'#E_O'F{QRO'#E_O'C|QRO'#E_O5bQRO'#E_O5bQRO'#E_O5bQRO'#E_O5bQRO'#E_O5bQRO'#E_O5bQRO'#E_O5bQRO'#E_O5bQRO'#E_O5bQRO'#E_O5bQRO'#E_O5bQRO'#E_O5bQRO'#E_O5bQRO'#E_O5bQRO'#E_O5bQRO'#E_O5bQRO'#E_O5bQRO'#E_O5bQRO'#E_O5bQRO'#E_O5bQRO'#E_O5bQRO'#E_O5bQRO'#E_O5bQRO'#E_O5bQRO'#E_O5bQRO'#E_O5bQRO'#E_O5bQRO'#E_O5bQRO'#E_O5bQRO'#E_O8zQRO'#E_O8zQRO'#E_O8zQRO'#E_O8zQRO'#E_O8zQRO'#E_O8zQRO'#E_O8zQRO'#E_O8zQRO'#E_O8zQRO'#E_O8zQRO'#E_O8zQRO'#E_O8zQRO'#E_O8zQRO'#E_O8zQRO'#E_O8zQRO'#E_O8zQRO'#E_O8zQRO'#E_O8zQRO'#E_O8zQRO'#E_O8zQRO'#E_O8zQRO'#E_O8zQRO'#E_O8zQRO'#E_O8zQRO'#E_O8zQRO'#E_O8zQRO'#E_O8zQRO'#E_O8zQRO'#E_O;ZQRO'#E_O8zQRO'#E_O60cQRO'#ExO60vQRO'#ExO60vQRO'#ExO?OQRO'#E|O?OQRO'#E|O?OQRO'#E|O?OQRO'#E|O?OQRO'#E|OAqQRO'#E}OAqQRO'#E}OAqQRO'#E}OAqQRO'#E}OAqQRO'#E}O6-dQRO'#EWO5bQRO'#EWO5bQRO'#EWO5bQRO'#EWO5bQRO'#EWO5bQRO'#EWO5bQRO'#EWO5bQRO'#EWO5bQRO'#EWO5bQRO'#EWO61ZQRO,5:wO61lQRO,5:zO61}QRO,5:zO62`QRO,5:zO62qQRO,5:zO!)PQRO'#FeO63SQPO,5;UO5bQRO'#FfO5bQRO'#FfO5bQRO'#FfO5bQRO'#FfO5bQRO'#FfO5bQRO'#FfO5bQRO'#FfO5bQRO'#FfO5bQRO'#FfO5bQRO'#FfO5bQRO'#FfO5bQRO'#FfO5bQRO'#FfO5bQRO'#FfO5bQRO'#FfO!)PQRO,5:yO$8yQRO,5:yO#)kQRO,5:yO#)kQRO,5:yO#)kQRO,5:yO#)kQRO,5:yO#)kQRO,5:yO#)kQRO,5:yO#)kQRO,5:yO#)kQRO,5:yO#)kQRO,5:yO#)kQRO,5:yO#)kQRO,5:yO#)kQRO,5:yO#)kQRO,5:yO#)kQRO,5:yO#)kQRO,5:yO#)kQRO,5:yO#)kQRO,5:yO#)kQRO,5:yO#)kQRO,5:yO#)kQRO,5:yO#)kQRO,5:yO#)kQRO,5:yO#)kQRO,5:yO#)kQRO,5:yO#)kQRO,5:yO#)kQRO,5:yO#)kQRO,5:yO#)kQRO,5:yO#)kQRO,5:yO#)kQRO,5:yO#)kQRO,5:yO#)kQRO,5:yO#)kQRO,5:yO#)kQRO,5:yO63XQRO,5:yO63`QRO,5:yO63gQRO,5:yO63nQRO,5:yO63uQRO,5:yO5bQRO,5:yO5bQRO,5:yO5bQRO,5:yO5bQRO,5:yO5bQRO,5:yO63|QRO,5<TO6-dQRO,5;hO6-dQRO,5;iO66[QRO,5:rO#)kQRO,5:rO#)kQRO,5:rO#)kQRO,5:rO#)kQRO,5:rO#)kQRO,5:rO#)kQRO,5:rO#)kQRO,5:rO#)kQRO,5:rO#)kQRO,5:rO66lQRO,5:rO66vQRO,5:rO67QQRO,5:rO67[QRO,5:rO$8yQRO1G0eO#)kQRO1G0eO#)kQRO1G0eO#)kQRO1G0eO#)kQRO1G0eO#)kQRO1G0eO#)kQRO1G0eO#)kQRO1G0eO#)kQRO1G0eO#)kQRO1G0eO#)kQRO1G0eO#)kQRO1G0eO#)kQRO1G0eO#)kQRO1G0eO#)kQRO1G0eO#)kQRO1G0eO#)kQRO1G0eO#)kQRO1G0eO#)kQRO1G0eO#)kQRO1G0eO#)kQRO1G0eO#)kQRO1G0eO#)kQRO1G0eO#)kQRO1G0eO#)kQRO1G0eO#)kQRO1G0eO#)kQRO1G0eO#)kQRO1G0eO#)kQRO1G0eO#)kQRO1G0eO#)kQRO1G0eO#)kQRO1G0eO#)kQRO1G0eO#)kQRO1G0eO#)kQRO1G0eO66[QRO1G0^O#)kQRO1G0^O#)kQRO1G0^O#)kQRO1G0^O#)kQRO1G0^O#)kQRO1G0^O#)kQRO1G0^O#)kQRO1G0^O#)kQRO1G0^O#)kQRO1G0^O67fQRO'#ErO67mQRO'#ErO67tQRO'#ErO67{QRO'#ErO$8yQRO7+&PO#)kQRO7+&PO#)kQRO7+&PO#)kQRO7+&PO#)kQRO7+&PO#)kQRO7+&PO#)kQRO7+&PO#)kQRO7+&PO#)kQRO7+&PO#)kQRO7+&PO#)kQRO7+&PO#)kQRO7+&PO#)kQRO7+&PO#)kQRO7+&PO#)kQRO7+&PO#)kQRO7+&PO#)kQRO7+&PO#)kQRO7+&PO#)kQRO7+&PO#)kQRO7+&PO#)kQRO7+&PO#)kQRO7+&PO#)kQRO7+&PO#)kQRO7+&PO#)kQRO7+&PO#)kQRO7+&PO#)kQRO7+&PO#)kQRO7+&PO#)kQRO7+&PO#)kQRO7+&PO#)kQRO7+&PO#)kQRO7+&PO#)kQRO7+&PO#)kQRO7+&PO#)kQRO7+&PO66[QRO7+%xO#)kQRO7+%xO#)kQRO7+%xO#)kQRO7+%xO#)kQRO7+%xO#)kQRO7+%xO#)kQRO7+%xO#)kQRO7+%xO#)kQRO7+%xO#)kQRO7+%xO$8yQRO<<IkO#)kQRO<<IkO#)kQRO<<IkO#)kQRO<<IkO#)kQRO<<IkO#)kQRO<<IkO#)kQRO<<IkO#)kQRO<<IkO#)kQRO<<IkO#)kQRO<<IkO#)kQRO<<IkO#)kQRO<<IkO#)kQRO<<IkO#)kQRO<<IkO#)kQRO<<IkO#)kQRO<<IkO#)kQRO<<IkO#)kQRO<<IkO#)kQRO<<IkO#)kQRO<<IkO#)kQRO<<IkO#)kQRO<<IkO#)kQRO<<IkO#)kQRO<<IkO#)kQRO<<IkO#)kQRO<<IkO#)kQRO<<IkO#)kQRO<<IkO#)kQRO<<IkO#)kQRO<<IkO#)kQRO<<IkO#)kQRO<<IkO#)kQRO<<IkO#)kQRO<<IkO#)kQRO<<IkO66[QRO<<IdO#)kQRO<<IdO#)kQRO<<IdO#)kQRO<<IdO#)kQRO<<IdO#)kQRO<<IdO#)kQRO<<IdO#)kQRO<<IdO#)kQRO<<IdO#)kQRO<<IdO$8yQROAN?VO#)kQROAN?VO#)kQROAN?VO#)kQROAN?VO#)kQROAN?VO#)kQROAN?VO66[QROAN?OO#)kQROAN?OO#)kQROAN?OO#)kQROAN?OO#)kQROAN?OO'1yQRO,5:yO6-dQRO,5:yO68SQRO,5:yO68ZQRO,5:yO68bQRO,5:yO68iQRO,5:yO68pQRO,5:yO68}QRO,5:yO69UQRO,5:yO69]QRO,5:yO69dQRO,5:yO69kQRO,5:yO69rQRO,5:yO69yQRO,5:yO6:WQRO,5:yO6:_QRO,5:yO+)cQRO,5:yO66[QRO,5:yO6:fQRO1G0eO6:mQRO1G0eO6:tQRO1G0eO6:{QRO1G0eO6;SQRO1G0eO6;aQRO1G0eO6;hQRO1G0eO6;oQRO1G0eO6;vQRO1G0eO6;}QRO1G0eO6<UQRO1G0eO6<]QRO1G0eO6<jQRO1G0eO6<qQRO1G0eO+)cQRO1G0eO66[QRO1G0eO6<xQRO1G1lO6=PQRO1G1lO6=WQRO1G1lO6=_QRO1G1lO6=fQRO1G1lO6=sQRO1G1lO6=zQRO1G1lO6>RQRO7+&PO6>YQRO7+&PO6>aQRO7+&PO6>hQRO7+&PO6>oQRO7+&PO6>|QRO7+&PO6?TQRO7+&PO6?[QRO7+&PO6?cQRO7+&PO6?jQRO7+&PO6?qQRO7+&PO6?xQRO7+&PO6@VQRO7+&PO6@^QRO7+&PO+)cQRO7+&PO66[QRO7+&PO6@eQRO<<IkO6@lQRO<<IkO6@sQRO<<IkO6@zQRO<<IkO6ARQRO<<IkO6A`QRO<<IkO6AgQRO<<IkO6AnQRO<<IkO6AuQRO<<IkO6A|QRO<<IkO6BTQRO<<IkO6B[QRO<<IkO6BiQRO<<IkO6BpQRO<<IkO+)cQRO<<IkO66[QRO<<IkO6BwQROAN?VO6COQROAN?VO6CVQROAN?VO6C^QROAN?VO6CeQROAN?VO6CrQROAN?VO6CyQROAN?VO6DQQROAN?VO6DXQROAN?VO6D`QROAN?VO6DgQROAN?VO6DnQROAN?VO6D{QROAN?VO6ESQROAN?VO+)cQROAN?VO66[QROAN?VO6EZQROG24qO6EbQROG24qO6EiQROG24qO6EpQROG24qO6EwQROG24qO6FUQROG24qO6F]QROG24qO6FdQROG24qO6FkQROG24qO6FrQROG24qO6FyQROG24qO6GQQROG24qO6G_QROG24qO6GfQROG24qO&jQRO'#E]O&jQRO'#E]O&jQRO'#E]O5bQRO'#E_O5bQRO'#E_O5bQRO'#E_O5bQRO'#E_O5bQRO'#E_O5bQRO'#E_O5bQRO'#E_O5bQRO'#E_O5bQRO'#E_O5bQRO'#E_O5bQRO'#E_O5bQRO'#E_O5bQRO'#E_O5bQRO'#E_O5bQRO'#E_O5bQRO'#E_O5bQRO'#E_O5bQRO'#E_O5bQRO'#E_O5bQRO'#E_O5bQRO'#E_O5bQRO'#E_O5bQRO'#E_O5bQRO'#E_O5bQRO'#E_O5bQRO'#E_O5bQRO'#E_O5bQRO'#E_O5bQRO'#E_O5bQRO'#E_O5bQRO'#E_O5bQRO'#E_O5bQRO'#E_O5bQRO'#E_O5bQRO'#E_O8zQRO'#E_O;ZQRO'#E_O;ZQRO'#E_O;ZQRO'#E_O;ZQRO'#E_O;ZQRO'#E_O8zQRO'#E_O8zQRO'#E_O8zQRO'#E_O8zQRO'#E_O8zQRO'#E_O?OQRO'#E|OAqQRO'#E}O5bQRO'#EWO5bQRO'#EWO5bQRO'#EWO5bQRO'#EWO5bQRO'#EWO5bQRO'#EWO5bQRO'#EWO5bQRO'#EWO5bQRO'#EWO5bQRO'#EWO5bQRO'#EWO5bQRO'#EWO5bQRO'#EWO5bQRO'#EWO&jQRO'#E]O&jQRO'#E]O#)kQRO,5:yO#)kQRO,5:yO#)kQRO,5:yO#)kQRO,5:yO#)kQRO,5:yO#)kQRO,5:yO#)kQRO,5:yO#)kQRO,5:yO#)kQRO,5:yO#)kQRO,5:yO#)kQRO,5:yO#)kQRO,5:yO#)kQRO,5:yO#)kQRO,5:yO#)kQRO,5:yO#)kQRO,5:yO#)kQRO,5:yO#)kQRO,5:yO#)kQRO,5:yO#)kQRO,5:yO#)kQRO,5:yO#)kQRO,5:yO#)kQRO,5:yO#)kQRO,5:yO#)kQRO,5:yO#)kQRO,5:yO#)kQRO,5:yO#)kQRO,5:yO#)kQRO,5:yO#)kQRO,5:yO#)kQRO,5:yO#)kQRO,5:yO#)kQRO,5:yO#)kQRO,5:yO#)kQRO,5:yO#)kQRO,5:rO#)kQRO,5:rO#)kQRO,5:rO#)kQRO,5:rO#)kQRO,5:rO#)kQRO,5:rO#)kQRO,5:rO#)kQRO,5:rO#)kQRO,5:rO#)kQRO,5:rO#)kQRO1G0eO#)kQRO1G0eO#)kQRO1G0eO#)kQRO1G0eO#)kQRO1G0eO#)kQRO1G0eO#)kQRO1G0eO#)kQRO1G0eO#)kQRO1G0eO#)kQRO1G0eO#)kQRO1G0eO#)kQRO1G0eO#)kQRO1G0eO#)kQRO1G0eO#)kQRO1G0eO#)kQRO1G0eO#)kQRO1G0eO#)kQRO1G0eO#)kQRO1G0eO#)kQRO1G0eO#)kQRO1G0eO#)kQRO1G0eO#)kQRO1G0eO#)kQRO1G0eO#)kQRO1G0eO#)kQRO1G0eO#)kQRO1G0eO#)kQRO1G0eO#)kQRO1G0eO#)kQRO1G0eO#)kQRO1G0eO#)kQRO1G0eO#)kQRO1G0eO#)kQRO1G0eO#)kQRO1G0eO#)kQRO1G0^O#)kQRO1G0^O#)kQRO1G0^O#)kQRO1G0^O#)kQRO1G0^O#)kQRO1G0^O#)kQRO1G0^O#)kQRO1G0^O#)kQRO1G0^O#)kQRO1G0^O#)kQRO7+&PO#)kQRO7+&PO#)kQRO7+&PO#)kQRO7+&PO#)kQRO7+&PO#)kQRO7+&PO#)kQRO7+&PO#)kQRO7+&PO#)kQRO7+&PO#)kQRO7+&PO#)kQRO7+&PO#)kQRO7+&PO#)kQRO7+&PO#)kQRO7+&PO#)kQRO7+&PO#)kQRO7+&PO#)kQRO7+&PO#)kQRO7+&PO#)kQRO7+&PO#)kQRO7+&PO#)kQRO7+&PO#)kQRO7+&PO#)kQRO7+&PO#)kQRO7+&PO#)kQRO7+&PO#)kQRO7+&PO#)kQRO7+&PO#)kQRO7+&PO#)kQRO7+&PO#)kQRO7+&PO#)kQRO7+&PO#)kQRO7+&PO#)kQRO7+&PO#)kQRO7+&PO#)kQRO7+&PO#)kQRO7+%xO#)kQRO7+%xO#)kQRO7+%xO#)kQRO7+%xO#)kQRO7+%xO#)kQRO7+%xO#)kQRO7+%xO#)kQRO7+%xO#)kQRO7+%xO#)kQRO7+%xO#)kQRO<<IkO#)kQRO<<IkO#)kQRO<<IkO#)kQRO<<IkO#)kQRO<<IkO#)kQRO<<IkO#)kQRO<<IdO#)kQRO<<IdO#)kQRO<<IdO#)kQRO<<IdO#)kQRO<<IdO5bQRO'#E_O5bQRO'#E_O8zQRO'#E_O8zQRO'#E_O#)kQRO,5:yO#)kQRO,5:yO#)kQRO1G0eO#)kQRO1G0eO#)kQRO7+&PO#)kQRO7+&PO#)kQRO<<IkO#)kQRO<<IkO5bQRO'#E_O5bQRO'#E_O5bQRO'#E_O5bQRO'#E_O5bQRO'#E_O5bQRO'#E_O5bQRO'#E_O5bQRO'#E_O5bQRO'#E_O5bQRO'#E_O5bQRO'#E_O5bQRO'#E_O5bQRO'#E_O5bQRO'#E_O5bQRO'#E_O5bQRO'#E_O5bQRO'#E_O5bQRO'#E_O5bQRO'#E_O5bQRO'#E_O5bQRO'#E_O5bQRO'#E_O5bQRO'#E_O5bQRO'#E_O5bQRO'#E_O5bQRO'#E_O5bQRO'#E_O5bQRO'#E_O5bQRO'#E_O5bQRO'#E_O5bQRO'#E_O5bQRO'#E_O5bQRO'#E_O5bQRO'#E_O5bQRO'#E_O5bQRO'#EWO5bQRO'#EWO5bQRO'#EWO5bQRO'#EWO5bQRO'#EWO5bQRO'#EWO5bQRO'#EWO5bQRO'#EWO5bQRO'#EWO5bQRO'#EWO#)kQRO,5:yO#)kQRO,5:yO#)kQRO,5:yO#)kQRO,5:yO#)kQRO,5:yO#)kQRO,5:yO#)kQRO,5:yO#)kQRO,5:yO#)kQRO,5:yO#)kQRO,5:yO#)kQRO,5:yO#)kQRO,5:yO#)kQRO,5:yO#)kQRO,5:yO#)kQRO,5:yO#)kQRO,5:yO#)kQRO,5:yO#)kQRO,5:yO#)kQRO,5:yO#)kQRO,5:yO#)kQRO,5:yO#)kQRO,5:yO#)kQRO,5:yO#)kQRO,5:yO#)kQRO,5:yO#)kQRO,5:yO#)kQRO,5:yO#)kQRO,5:yO#)kQRO,5:yO#)kQRO,5:yO#)kQRO,5:yO#)kQRO,5:yO#)kQRO,5:yO#)kQRO,5:yO#)kQRO,5:yO#)kQRO,5:rO#)kQRO,5:rO#)kQRO,5:rO#)kQRO,5:rO#)kQRO,5:rO#)kQRO,5:rO#)kQRO,5:rO#)kQRO,5:rO#)kQRO,5:rO#)kQRO,5:rO#)kQRO1G0eO#)kQRO1G0eO#)kQRO1G0eO#)kQRO1G0eO#)kQRO1G0eO#)kQRO1G0eO#)kQRO1G0eO#)kQRO1G0eO#)kQRO1G0eO#)kQRO1G0eO#)kQRO1G0eO#)kQRO1G0eO#)kQRO1G0eO#)kQRO1G0eO#)kQRO1G0eO#)kQRO1G0eO#)kQRO1G0eO#)kQRO1G0eO#)kQRO1G0eO#)kQRO1G0eO#)kQRO1G0eO#)kQRO1G0eO#)kQRO1G0eO#)kQRO1G0eO#)kQRO1G0eO#)kQRO1G0eO#)kQRO1G0eO#)kQRO1G0eO#)kQRO1G0eO#)kQRO1G0eO#)kQRO1G0eO#)kQRO1G0eO#)kQRO1G0eO#)kQRO1G0eO#)kQRO1G0eO#)kQRO1G0^O#)kQRO1G0^O#)kQRO1G0^O#)kQRO1G0^O#)kQRO1G0^O#)kQRO1G0^O#)kQRO1G0^O#)kQRO1G0^O#)kQRO1G0^O#)kQRO1G0^O#)kQRO7+&PO#)kQRO7+&PO#)kQRO7+&PO#)kQRO7+&PO#)kQRO7+&PO#)kQRO7+&PO#)kQRO7+%xO#)kQRO7+%xO#)kQRO7+%xO#)kQRO7+%xO#)kQRO7+%xO5bQRO'#E_O5bQRO'#E_O#)kQRO,5:yO#)kQRO,5:yO#)kQRO1G0eO#)kQRO1G0eO#)kQRO7+&PO#)kQRO7+&PO5bQRO'#E_O5bQRO'#E_O5bQRO'#E_O5bQRO'#E_O5bQRO'#E_O5bQRO'#E_O5bQRO'#E_O5bQRO'#E_O5bQRO'#E_O5bQRO'#E_O5bQRO'#E_O5bQRO'#E_O5bQRO'#E_O5bQRO'#E_O5bQRO'#E_O5bQRO'#E_O5bQRO'#E_O5bQRO'#E_O5bQRO'#E_O5bQRO'#E_O5bQRO'#E_O5bQRO'#E_O5bQRO'#E_O5bQRO'#E_O5bQRO'#E_O5bQRO'#E_O5bQRO'#E_O5bQRO'#E_O5bQRO'#E_O5bQRO'#E_O5bQRO'#E_O5bQRO'#E_O5bQRO'#E_O5bQRO'#E_O5bQRO'#E_O5bQRO'#EWO5bQRO'#EWO5bQRO'#EWO5bQRO'#EWO5bQRO'#EWO5bQRO'#EWO5bQRO'#EWO5bQRO'#EWO5bQRO'#EWO5bQRO'#EWO#)kQRO,5:yO#)kQRO,5:yO#)kQRO,5:yO#)kQRO,5:yO#)kQRO,5:yO#)kQRO,5:yO#)kQRO,5:yO#)kQRO,5:yO#)kQRO,5:yO#)kQRO,5:yO#)kQRO,5:yO#)kQRO,5:yO#)kQRO,5:yO#)kQRO,5:yO#)kQRO,5:yO#)kQRO,5:yO#)kQRO,5:yO#)kQRO,5:yO#)kQRO,5:yO#)kQRO,5:yO#)kQRO,5:yO#)kQRO,5:yO#)kQRO,5:yO#)kQRO,5:yO#)kQRO,5:yO#)kQRO,5:yO#)kQRO,5:yO#)kQRO,5:yO#)kQRO,5:yO#)kQRO,5:yO#)kQRO,5:yO#)kQRO,5:yO#)kQRO,5:yO#)kQRO,5:yO#)kQRO,5:yO#)kQRO,5:rO#)kQRO,5:rO#)kQRO,5:rO#)kQRO,5:rO#)kQRO,5:rO#)kQRO,5:rO#)kQRO,5:rO#)kQRO,5:rO#)kQRO,5:rO#)kQRO,5:rO#)kQRO1G0eO#)kQRO1G0eO#)kQRO1G0eO#)kQRO1G0eO#)kQRO1G0eO#)kQRO1G0eO#)kQRO1G0^O#)kQRO1G0^O#)kQRO1G0^O#)kQRO1G0^O#)kQRO1G0^O5bQRO'#E_O5bQRO'#E_O#)kQRO,5:yO#)kQRO,5:yO#)kQRO1G0eO#)kQRO1G0eO5bQRO'#E_O5bQRO'#E_O5bQRO'#E_O5bQRO'#E_O5bQRO'#E_O5bQRO'#E_O5bQRO'#E_O5bQRO'#E_O5bQRO'#E_O5bQRO'#E_O5bQRO'#E_O5bQRO'#E_O5bQRO'#E_O5bQRO'#E_O5bQRO'#E_O5bQRO'#E_O5bQRO'#E_O5bQRO'#E_O5bQRO'#E_O5bQRO'#E_O5bQRO'#E_O5bQRO'#E_O5bQRO'#E_O5bQRO'#E_O5bQRO'#E_O5bQRO'#E_O5bQRO'#E_O5bQRO'#E_O5bQRO'#E_O5bQRO'#E_O5bQRO'#E_O5bQRO'#E_O5bQRO'#E_O5bQRO'#E_O5bQRO'#E_O5bQRO'#EWO5bQRO'#EWO5bQRO'#EWO5bQRO'#EWO5bQRO'#EWO5bQRO'#EWO5bQRO'#EWO5bQRO'#EWO5bQRO'#EWO5bQRO'#EWO#)kQRO,5:yO#)kQRO,5:yO#)kQRO,5:yO#)kQRO,5:yO#)kQRO,5:yO#)kQRO,5:yO#)kQRO,5:rO#)kQRO,5:rO#)kQRO,5:rO#)kQRO,5:rO#)kQRO,5:rO5bQRO'#E_O5bQRO'#E_O#)kQRO,5:yO#)kQRO,5:yO5bQRO'#E_O5bQRO'#E_O5bQRO'#E_O5bQRO'#E_O5bQRO'#E_O5bQRO'#E_O5bQRO'#EWO5bQRO'#EWO5bQRO'#EWO5bQRO'#EWO5bQRO'#EWO5bQRO'#E_O5bQRO'#E_",
  stateData: "6Gm~O$WOS!wOS~O[lO_lO`lOalObkOflOiiOjjOkhOoZOpWOqZOr[OsWOtZOuWOwWOxZOy[Oz]O{^O|_O}`O!OaO!PbO!QcO!RdO!SeO!TfO!UgO!VcO!WbO!XWO!YZO!Z[O![]O!]^O!^_O!_`O#WVO#ikO#jkO~OSROTQOUSOVTOWsOXrOY!XOcuOh!TOlYOmqOnqOvmO!`uO!avO!bwO!cxO!dyO!ezO!f{O!g|O!h}O!i!OO!j!PO!k!QO!l!RO!m!SO!n!PO!oqO!puO!qvO!rwO!sxO!tyO!uzO!v{O#OPO$U#sP~PYOP!`OR!`OW5ZOX5UO[lO_lO`lOalObkOcuOflOh>ZOiiOjjOk=rOlYOm+SOn+SOo3UOpWOq3UOr<}OsWOt3UOuWOv5ROwWOx3UOy<}OzAuO{EVO|GfO}HtO!OaO!PbO!QcO!RdO!SeO!TfO!UgO!VcO!WbO!XWO!Y3UO!Z<}O![AuO!]EVO!^GfO!_HtO!`uO!a'}O!b5aO!c>QO!dBkO!eE{O!fH[O!g(SO!h5fO!i>VO!jBpO!kFQO!lHaO!mH{O!nBpO!o+SO!puO!q'}O!r5aO!s>QO!tBkO!uE{O!vH[O#O!]O#WVO#ikO#jkO~O#W!cO~O#W!dO~O#W!eO~O#W!fO~OSROTQOUSOVTOW5_OX5YO_lO`lOalObkOcuOf!mOh>^OiiOjjOk=rOm+TOn+TOo3UOpWOq3UOr<}OsWOt3UOuWOv5TOwWOx3UOy<}OzAuO{EVO|GfO}HtO!OaO!PbO!QcO!RdO!SeO!TfO!UgO!VcO!WbO!XWO!Y3UO!Z<}O![AuO!]EVO!^GfO!_HtO!`uO!a(RO!b5eO!c>UO!dBoO!eFPO!fH`O!g(VO!h5iO!i>YO!jBsO!kFTO!lHdO!mIOO!nBsO!o+TO!puO!q(RO!r5eO!s>UO!tBoO!uFPO!vH`O#O<zO#W!jO#ikO#jkO#[#YP~O[!gOl!hO#V!sO~P,OOP(WOQ!yOR(WOg!{O~OP#RXP#lXQ#RXQ#lXR#RXR#lXS!zXT!zXU!zXV!zXW!zXX!zXc!zXg#RXg#lXh!zXl!zXm!zXn!zXv!zX!`!zX!a!zX!b!zX!c!zX!d!zX!e!zX!f!zX!g!zX!h!zX!i!zX!j!zX!k!zX!l!zX!m!zX!n!zX!o!zX!p!zX!q!zX!r!zX!s!zX!t!zX!u!zX!v!zX#O!zX~OY!zX$U!zX$U#RX$U#lX!}!zX!}#RX!}#lX~P1nOl!}OvlO#O!]O~PYO[lO_lO`lOalObkOflOi5POj5QOk4cOl!}Oo'qOpWOq'qOr3tOsWOt'qOuWOvlOwWOx'qOy3tOz=OO{AvO|EWO}GgO!OWO!P'wO!Q4bO!R=qO!SBiO!TEyO!UHYO!V4bO!W'wO!XWO!Y'qO!Z3tO![=OO!]AvO!^EWO!_GgO#O>_O#WVO#ikO#jkO~OP#RXQ#RXR#RXg#RX$U#RX!}#RX#V#RX~P5bOP#]OQ#]OR#]O[#]Oo#]Op#]Oq#]Or#]Os#]Ot#]Ou#]Ow#]Ox#]Oy#]Oz#]O{#]O|#]O}#]O!O#]O!P#]O!Q#]O!R#]O!S#]O!T#]O!U#]O!V#]O!W#]O!X#]O!Y#]O!Z#]O![#]O!]#]O!^#]O!_#]O#W#[O~O[lO_lO`lOalObkOflOi=uOj=zOk4mOl!}Oo3qOpWOq3qOr4OOsWOt3qOuWOvlOwWOx3qOy4OOz=YO{BQO|EbO}GqO!O'rO!P'{O!Q=nO!RBfO!SEvO!THVO!UHwO!V=nO!W'{O!XWO!Y3qO!Z4OO![=YO!]BQO!^EbO!_GqO#O>_O#WVO#ikO#jkO~OP#lXQ#lXR#lXg#lX$U#lX~P5bOP!{XQ!{XR!{Xg!{X$U#wX~OP#aOQ#aOR#aO[#bO_#bO`#bOa#bOl#bOv#bOw#aOx#aOy#aOz#aO{#aO|#aO}#aO!O#aO!P#aO!Q#aO!R#aO!S#aO!T#aO!U#aO!V#aO!W#aO!`#aO!a#aO!b#aO!c#aO!d#aO!e#aO!f#aO!g#aO!h#aO!i#aO!j#aO!k#aO!l#aO!m#aO!n#aO#W#dO~OP#aOQ#aOR#aO[lO_lO`lOalOflOllOvlOw#aOx#aOy#aOz#aO{#aO|#aO}#aO!O#aO!P#aO!Q#aO!R#aO!S#aO!T#aO!U#aO!V#aO!W#aO!`#aO!a#aO!b#aO!c#aO!d#aO!e#aO!f#aO!g#aO!h#aO!i#aO!j#aO!k#aO!l#aO!m#aO!n#aO#W#fO~O[lO_lO`lOalObkOflOi=tOj=yOk4xOl!}Oo3oOpWOq3oOr4ZOsWOt3oOuWOvlOwWOx3oOy4ZOz=eO{B]O|EmO}G|O!O'uO!P'zO!Q=mO!RBeO!SEuO!THUO!UHvO!V=mO!W'zO!XWO!Y3oO!Z4ZO![=eO!]B]O!^EmO!_G|O#O>_O#WVO#ikO#jkO~O[lO_lO`lOalObkOflOi5POj5QOk4cOo'qOpWOq'qOr3tOsWOt'qOuWOwWOx'qOy3tOz=OO{AvO|EWO}GgO!OWO!P'wO!Q4bO!R=qO!SBiO!TEyO!UHYO!V4bO!W'wO!XWO!Y'qO!Z3tO![=OO!]AvO!^EWO!_GgO#WVO#ikO#jkOS!zXT!zXU!zXV!zXW!zXX!zXY!zXc!zXh!zXl!zXm!zXn!zXv!zX!`!zX!a!zX!b!zX!c!zX!d!zX!e!zX!f!zX!g!zX!h!zX!i!zX!j!zX!k!zX!l!zX!m!zX!n!zX!o!zX!p!zX!q!zX!r!zX!s!zX!t!zX!u!zX!v!zX$U!zX~O#O!zX~PGfOS#tXT#tXU#tXV#tXW#tXW#xXX#tXX#xXY#tXc#tXc#xXh#tXh#xXl#tXl#xXm#tXm#xXn#tXn#xXv#tXv#xX!`#tX!`#xX!a#tX!a#xX!b#tX!b#xX!c#tX!c#xX!d#tX!d#xX!e#tX!e#xX!f#tX!f#xX!g#tX!g#xX!h#tX!h#xX!i#tX!i#xX!j#tX!j#xX!k#tX!k#xX!l#tX!l#xX!m#tX!m#xX!n#tX!n#xX!o#tX!o#xX!p#tX!p#xX!q#tX!q#xX!r#tX!r#xX!s#tX!s#xX!t#tX!t#xX!u#tX!u#xX!v#tX!v#xX#O#xX$U#tX$U#xX~OW>OOX=}OcuOh!TOluOm#uOn#uOv#uO!`uO!a5`O!b>PO!cBjO!dEzO!eHZO!fHzO!g|O!h}O!i!OO!j!PO!k!QO!l!RO!m!SO!n!PO!o#uO!puO!q5`O!r>PO!sBjO!tEzO!uHZO!vHzO#O#tO$U!yX~O[#wO~OSROTQOUSOVTOcuOluO!`uO!puO~OW5^OX5XOY!XOh>]Om+POn+POv+PO!a(QO!b5dO!c>TO!dBnO!eFOO!fH_O!g(UO!h5hO!i>XO!jBrO!kFSO!lHcO!mH}O!nBrO!o+PO!q(QO!r5dO!s>TO!tBnO!uFOO!vH_O$U#sX~P!%rO!}#|OP!{XQ!{XR!{Xg!{X~O!}#}OP!{XQ!{XR!{Xg!{X~O[lO_lO`lOalObkOflOiiOjjOk=rOl!}Oo3UOpWOq3UOr<}OsWOt3UOuWOvlOwWOx3UOy<}OzAuO{EVO|GfO}HtO!OaO!PbO!QcO!RdO!SeO!TfO!UgO!VcO!WbO!XWO!Y3UO!Z<}O![AuO!]EVO!^GfO!_HtO#O!]O#WVO#ikO#jkO~O!}$PO~O!}$QO~O[$RO#V$TO~O[$RO#V$VO~O[$WOw$WO!Y$WO~O[$RO#V$ZO~OP#lXQ#lXR#lXS$PXT$PXU$PXV$PXW$PXX$PX[#zX[$OX[$PXb$OXb$PXc$PXf$PXg#lXh$PXl#zXl$PXm$PXn$PXv$PX!`$PX!a$PX!b$PX!c$PX!d$PX!e$PX!f$PX!g$PX!h$PX!i$PX!j$PX!k$PX!l$PX!m$PX!n$PX!o$PX!p$PX!q$PX!r$PX!s$PX!t$PX!u$PX!v$PX#O$PX#V#lX#V$OX#V$PX#W$OX#W$PX#[#zX#i$OX#i$PX#j$OX#j$PX~O[!zX[#zXb!zXf!zXl#zX#V!zX#V#RX#V#lX#W!zX#[#zX#i!zX#j!zX~P1nO[$[Ol$[O#[#YX~O[(hOl(iO#V$_O~P,OOP#lXQ#lXR#lXg#lX#V#lX~O#W$`O~P!2UOP!|XQ!|XR!|Xg!|X#V!|X~OS#]XT#]XU#]XV#]XW#]XX#]X[#]Xb#]Xc#]Xf#]Xh#]Xl#]Xm#]Xn#]Xv#]X!`#]X!a#]X!b#]X!c#]X!d#]X!e#]X!f#]X!g#]X!h#]X!i#]X!j#]X!k#]X!l#]X!m#]X!n#]X!o#]X!p#]X!q#]X!r#]X!s#]X!t#]X!u#]X!v#]X#O#]X#V#]X#W#]X#i#]X#j#]X~P!2nO#[$aO~OS$PXT$PXU$PXV$PXW$PXX$PX[$OX[$PXb$OXb$PXc$PXf$PXh$PXl$PXm$PXn$PXv$PX!`$PX!a$PX!b$PX!c$PX!d$PX!e$PX!f$PX!g$PX!h$PX!i$PX!j$PX!k$PX!l$PX!m$PX!n$PX!o$PX!p$PX!q$PX!r$PX!s$PX!t$PX!u$PX!v$PX#O$PX#V$OX#V$PX#W$OX#W$PX#i$OX#i$PX#j$OX#j$PX~P!2nO[$bObkO#W$dO#ikO#jkO~O#V$eO~P!9^OP#gaP#kaQ#gaQ#kaR#gaR#kag#gag#ka[#ga[#ka_#ga_#ka`#ga`#kaa#gaa#kab#gab#kaf#gaf#kai#gai#kaj#gaj#kak#gak#kal#gal#kao#gao#kap#gap#kaq#gaq#kar#gar#kas#gas#kat#gat#kau#gau#kav#gav#kaw#gaw#kax#gax#kay#gay#kaz#gaz#ka{#ga{#ka|#ga|#ka}#ga}#ka!O#ga!O#ka!P#ga!P#ka!Q#ga!Q#ka!R#ga!R#ka!S#ga!S#ka!T#ga!T#ka!U#ga!U#ka!V#ga!V#ka!W#ga!W#ka!X#ga!X#ka!Y#ga!Y#ka!Z#ga!Z#ka![#ga![#ka!]#ga!]#ka!^#ga!^#ka!_#ga!_#ka#O#ga#O#ka#W#ga#W#ka#i#ga#i#ka#j#ga#j#kam#gam#kan#gan#ka!`#ga!`#ka!a#ga!a#ka!b#ga!b#ka!c#ga!c#ka!d#ga!d#ka!e#ga!e#ka!f#ga!f#ka!g#ga!g#ka!h#ga!h#ka!i#ga!i#ka!j#ga!j#ka!k#ga!k#ka!l#ga!l#ka!m#ga!m#ka!n#ga!n#ka!p#ga!p#ka!q#ga!q#ka!r#ga!r#ka!s#ga!s#ka!t#ga!t#ka!u#ga!u#ka!v#ga!v#kae#gae#ka~O$U#ga$U#ka!}#ga!}#kaS#gaS#kaT#gaT#kaU#gaU#kaV#gaV#kaW#gaW#kaX#gaX#kaY#gaY#kac#gac#kah#gah#ka!o#ga!o#ka#V#ga#V#kaZ#gaZ#ka~P!9vOS$PXT$PXU$PXV$PXW$PXX$PX[$PXb$PXc$PXf$PXh$PXl$PXm$PXn$PXv$PX!`$PX!a$PX!b$PX!c$PX!d$PX!e$PX!f$PX!g$PX!h$PX!i$PX!j$PX!k$PX!l$PX!m$PX!n$PX!o$PX!p$PX!q$PX!r$PX!s$PX!t$PX!u$PX!v$PX#O$PX#V$PX#W$PX#i$PX#j$PX~P!2nOW5_OX5YO[!uObkOf$gOh>^Om+TOn+TOv+TO!a(RO!b5eO!c>UO!dBoO!eFPO!fH`O!g(VO!h5iO!i>YO!jBsO!kFTO!lHdO!mIOO!nBsO!o+TO!q(RO!r5eO!s>UO!tBoO!uFPO!vH`O#O$fO#V$jO#W$hO#ikO#jkO~P!%rO#V$kOP!|XQ!|XR!|Xg!|X~O#V$lOP!{XQ!{XR!{Xg!{X~OP(WOQ!yOR(WOg#Ra$U#Ra~OP#RXQ#RXR#RXg#RX$U#RX$U#lX[#RX[#lX_#RX_#lX`#RX`#lXa#RXa#lXb#RXb#lXf#RXf#lXi#RXi#lXj#RXj#lXk#RXk#lXl#RXl#lXo#RXo#lXp#RXp#lXq#RXq#lXr#RXr#lXs#RXs#lXt#RXt#lXu#RXu#lXv#RXv#lXw#RXw#lXx#RXx#lXy#RXy#lXz#RXz#lX{#RX{#lX|#RX|#lX}#RX}#lX!O#RX!O#lX!P#RX!P#lX!Q#RX!Q#lX!R#RX!R#lX!S#RX!S#lX!T#RX!T#lX!U#RX!U#lX!V#RX!V#lX!W#RX!W#lX!X#RX!X#lX!Y#RX!Y#lX!Z#RX!Z#lX![#RX![#lX!]#RX!]#lX!^#RX!^#lX!_#RX!_#lX#O#RX#O#lX#W#RX#W#lX#i#RX#i#lX#j#RX#j#lXS#RXS#lXT#RXT#lXU#RXU#lXV#RXV#lXW#RXW#lXX#RXX#lXY#RXY#lXc#RXc#lXh#RXh#lXm#RXm#lXn#RXn#lX!`#RX!`#lX!a#RX!a#lX!b#RX!b#lX!c#RX!c#lX!d#RX!d#lX!e#RX!e#lX!f#RX!f#lX!g#RX!g#lX!h#RX!h#lX!i#RX!i#lX!j#RX!j#lX!k#RX!k#lX!l#RX!l#lX!m#RX!m#lX!n#RX!n#lX!o#RX!o#lX!p#RX!p#lX!q#RX!q#lX!r#RX!r#lX!s#RX!s#lX!t#RX!t#lX!u#RX!u#lX!v#RX!v#lXe#RXe#lX!}#RX!}#lX#V#RXZ#RXZ#lX~P!2UOP(XOQ5qOR(XOg(lOl!}OvlO#O!]O~PYOP(XOQ5qOR(XOg(lO~P5bOP(XOQ5qOR(XOg(lO[#yX_#yX`#yXa#yXb#yXf#yXi#yXj#yXk#yXl#yXo#yXp#yXq#yXr#yXs#yXt#yXu#yXv#yXw#yXx#yXy#yXz#yX{#yX|#yX}#yX!O#yX!P#yX!Q#yX!R#yX!S#yX!T#yX!U#yX!V#yX!W#yX!X#yX!Y#yX!Z#yX![#yX!]#yX!^#yX!_#yX#O#yX#W#yX#i#yX#j#yX$U#yXS#yXT#yXU#yXV#yXW#yXX#yXY#yXc#yXh#yXm#yXn#yX!`#yX!a#yX!b#yX!c#yX!d#yX!e#yX!f#yX!g#yX!h#yX!i#yX!j#yX!k#yX!l#yX!m#yX!n#yX!o#yX!p#yX!q#yX!r#yX!s#yX!t#yX!u#yX!v#yXe#yX!}#yX#V#yXZ#yX~OP#RaQ#RaR#Rag#Ra$U#Ra!}#Ra#V#Ra~P5bOSROTQOUSOVTOW5]OX5WO_lO`lOalObkOcuOf!mOh>[Oi5POj5QOk4cOm+QOn+QOo'qOpWOq'qOr3tOsWOt'qOuWOv5SOwWOx'qOy3tOz=OO{AvO|EWO}GgO!OWO!P'wO!Q4bO!R=qO!SBiO!TEyO!UHYO!V4bO!W'wO!XWO!Y'qO!Z3tO![=OO!]AvO!^EWO!_GgO!`uO!a(PO!b5cO!c>SO!dBmO!eE}O!fH^O!g(TO!h5gO!i>WO!jBqO!kFRO!lHbO!mH|O!nBqO!o+QO!puO!q(PO!r5cO!s>SO!tBmO!uE}O!vH^O#O<|O#ikO#jkO~O[$yOl(kO#V%OO#W!jO#[#YP~P#0[OP%QOR%QO[#]Og(vOo#]Op#]Oq#]Or#]Os#]Ot#]Ou#]Ow#]Ox#]Oy#]Oz#]O{#]O|#]O}#]O!O#]O!P#]O!Q#]O!R#]O!S#]O!T#]O!U#]O!V#]O!W#]O!X#]O!Y#]O!Z#]O![#]O!]#]O!^#]O!_#]O#W#[O~OQ%RO~P#5lOP(XOQ5qOR(XOg(lOS$]aT$]aU$]aV$]aW$]aX$]aY$]ac$]ah$]am$]an$]a!`$]a!a$]a!b$]a!c$]a!d$]a!e$]a!f$]a!g$]a!h$]a!i$]a!j$]a!k$]a!l$]a!m$]a!n$]a!o$]a!p$]a!q$]a!r$]a!s$]a!t$]a!u$]a!v$]a$U$]a~PDgOP#aOQ#aOR#aO[#bO_#bO`#bOa#bOl#bOv#bOw#aOx#aOy#aOz#aO{#aO|#aO}#aO!O#aO!P#aO!Q#aO!R#aO!S#aO!T#aO!U#aO!V#aO!W#aO!`#aO!a#aO!b#aO!c#aO!d#aO!e#aO!f#aO!g#aO!h#aO!i#aO!j#aO!k#aO!l#aO!m#aO!n#aO~OP#aOQ#aOR#aO[lO_lO`lOalOflOllOvlOw#aOx#aOy#aOz#aO{#aO|#aO}#aO!O#aO!P#aO!Q#aO!R#aO!S#aO!T#aO!U#aO!V#aO!W#aO!`#aO!a#aO!b#aO!c#aO!d#aO!e#aO!f#aO!g#aO!h#aO!i#aO!j#aO!k#aO!l#aO!m#aO!n#aO~OS!zaT!zaU!zaV!zaW!zaX!zaY!zac!zah!zal!zam!zan!zav!za!`!za!a!za!b!za!c!za!d!za!e!za!f!za!g!za!h!za!i!za!j!za!k!za!l!za!m!za!n!za!o!za!p!za!q!za!r!za!s!za!t!za!u!za!v!za#O!za$U!za~OP(gOQ6OOR(gOg)RO~P#@SOP(XOQ5qOR(XOg(lO~PDgO[lO_lO`lOalObkOflOi5POj5QOk4cOo'qOpWOq'qOr3tOsWOt'qOuWOwWOx'qOy3tOz=OO{AvO|EWO}GgO!OWO!P'wO!Q4bO!R=qO!SBiO!TEyO!UHYO!V4bO!W'wO!XWO!Y'qO!Z3tO![=OO!]AvO!^EWO!_GgO#WVO#ikO#jkO~P#@SO_lO`lOalObkOe%jOflOi5POj5QOk4cOl!}Om%jOn%jOo'qOpWOq'qOr3tOsWOt'qOuWOvlOwWOx'qOy3tOz=OO{AvO|EWO}GgO!OWO!P'wO!Q4bO!R=qO!SBiO!TEyO!UHYO!V4bO!W'wO!XWO!Y'qO!Z3tO![=OO!]AvO!^EWO!_GgO!`%jO!a%jO!b%jO!c%jO!d%jO!e%jO!f%jO!g%jO!h%jO!i%jO!j%jO!k%jO!l%jO!m%jO!n%jO!p%jO!q%jO!r%jO!s%jO!t%jO!u%jO!v%jO#O>_O#ikO#jkO~O[%hO#W%gO~P#FUOW5ZOX5UOcuOh>ZOm+SOn+SO!`uO!a'}O!b5aO!c>QO!dBkO!eE{O!fH[O!g(SO!h5fO!i>VO!jBpO!kFQO!lHaO!mH{O!nBpO!o+SO!puO!q'}O!r5aO!s>QO!tBkO!uE{O!vH[O~OluOv+SO~P#JvOW5[OX5VOZ%oOf$gOh>[Om+ROn+ROv+RO!a(OO!b5bO!c>RO!dBlO!eE|O!fH]O!g(TO!h5gO!i>WO!jBqO!kFRO!lHbO!mH|O!nBqO!o+RO!q(OO!r5bO!s>RO!tBlO!uE|O!vH]O#O$fO#W%mO~P!%rO!}%qO~OP#PiP#QiQ#PiQ#QiR#PiR#Qig#Pig#Qi$U#Pi$U#Qi!}#Pi!}#QiS#QiT#QiU#QiV#QiW#QiX#Qi[#Qib#Qic#Qif#Qih#Qil#Qim#Qin#Qiv#Qi!`#Qi!a#Qi!b#Qi!c#Qi!d#Qi!e#Qi!f#Qi!g#Qi!h#Qi!i#Qi!j#Qi!k#Qi!l#Qi!m#Qi!n#Qi!o#Qi!p#Qi!q#Qi!r#Qi!s#Qi!t#Qi!u#Qi!v#Qi#O#Qi#V#Pi#V#Qi#W#Qi#i#Qi#j#Qi~OP#QiP#SiQ#QiQ#SiR#QiR#Sig#Qig#Si$U#Qi$U#Si!}#Qi!}#SiS#QiT#QiU#QiV#QiW#QiX#Qi[#Qib#Qic#Qif#Qih#Qil#Qim#Qin#Qiv#Qi!`#Qi!a#Qi!b#Qi!c#Qi!d#Qi!e#Qi!f#Qi!g#Qi!h#Qi!i#Qi!j#Qi!k#Qi!l#Qi!m#Qi!n#Qi!o#Qi!p#Qi!q#Qi!r#Qi!s#Qi!t#Qi!u#Qi!v#Qi#O#Qi#V#Qi#V#Si#W#Qi#i#Qi#j#Qi~OP5oOQ!yOR5oOg6QO!}$Xa~OP#QiQ#QiR#QiW#^iX#^ic#^ig#Qih#^il#^im#^in#^iv#^i!`#^i!a#^i!b#^i!c#^i!d#^i!e#^i!f#^i!g#^i!h#^i!i#^i!j#^i!k#^i!l#^i!m#^i!n#^i!o#^i!p#^i!q#^i!r#^i!s#^i!t#^i!u#^i!v#^i#O#^i~O$U#Qi$U#^i~P$(|O[$RO#V%sO~O[$RO#V%tO~O[%uO!Y%uO~O[$RO#V%wO~O[$[Ol$[O#V%xO#[#YX~OP#gaP#kaQ#gaQ#kaR#gaR#ka[#ga[#kab#gab#kaf#gaf#kag#gag#kal#gal#kam#gam#kan#gan#kav#gav#ka!`#ga!`#ka!a#ga!a#ka!b#ga!b#ka!c#ga!c#ka!d#ga!d#ka!e#ga!e#ka!f#ga!f#ka!g#ga!g#ka!h#ga!h#ka!i#ga!i#ka!j#ga!j#ka!k#ga!k#ka!l#ga!l#ka!m#ga!m#ka!n#ga!n#ka!p#ga!p#ka!q#ga!q#ka!r#ga!r#ka!s#ga!s#ka!t#ga!t#ka!u#ga!u#ka!v#ga!v#ka#O#ga#O#ka#W#ga#W#ka#i#ga#i#ka#j#ga#j#ka~OS#gaS#kaT#gaT#kaU#gaU#kaV#gaV#kaW#gaW#kaX#gaX#kac#gac#kah#gah#ka!o#ga!o#ka#V#ga#V#ka#[#Za~P$,jO[lOl'pO#V%|O#WVO~P#0[O#V&OO~P!9^O[lO_lO`lOalObkOflOiiOjjOk=rOlYOo3UOpWOq3UOr<}OsWOt3UOuWOv5ROwWOx3UOy<}OzAuO{EVO|GfO}HtO!OaO!PbO!QcO!RdO!SeO!TfO!UgO!VcO!WbO!XWO!Y3UO!Z<}O![AuO!]EVO!^GfO!_HtO#O!]O#WVO#ikO#jkO~P#JvO#W$`O~OW5_OX5YO[&QObkOf$gOh>^Om+TOn+TOv+TO!a(RO!b5eO!c>UO!dBoO!eFPO!fH`O!g(VO!h5iO!i>YO!jBsO!kFTO!lHdO!mIOO!nBsO!o+TO!q(RO!r5eO!s>UO!tBoO!uFPO!vH`O#O$fO#V!sO#W$hO#ikO#jkO~P!%rOP(XOQ5qOR(XOg(lO~P!)POP(WOQ!yOR(WOg#Ri$U#Ri~OP#RiQ#RiR#Rig#Ri$U#Ri!}#Ri#V#Ri~P5bO[#zXl#zX#[#zX~P!2UOW5]OX5WOf$gOh>[Om+QOn+QOv+QO!a(PO!b5cO!c>SO!dBmO!eE}O!fH^O!g(TO!h5gO!i>WO!jBqO!kFRO!lHbO!mH|O!nBqO!o+QO!q(PO!r5cO!s>SO!tBmO!uE}O!vH^O#O$fO#V&]O~P!%rOP!{XQ!{XR!{X[#}X_#}X`#}Xa#}Xb#}Xf#}Xg!{Xi#}Xj#}Xk#}Xl#}Xo#}Xp#}Xq#}Xr#}Xs#}Xt#}Xu#}Xv#}Xw#}Xx#}Xy#}Xz#}X{#}X|#}X}#}X!O#}X!P#}X!Q#}X!R#}X!S#}X!T#}X!U#}X!V#}X!W#}X!X#}X!Y#}X!Z#}X![#}X!]#}X!^#}X!_#}X#O#}X#W#}X#i#}X#j#}X~O#V#}X~P$<fO[lO_lO`lOalObkOflOi5POj5QOk4cOl)jOo'qOpWOq'qOr3tOsWOt'qOuWOvlOwWOx'qOy3tOz=OO{AvO|EWO}GgO!OWO!P'wO!Q4bO!R=qO!SBiO!TEyO!UHYO!V4bO!W'wO!XWO!Y'qO!Z3tO![=OO!]AvO!^EWO!_GgO#O>`O#WVO#ikO#jkO~O#V&]O~P$?xO#V&]OP!{XQ!{XR!{Xg!{X~O[lO_lO`lOalObkOflOpWOsWOuWOwWO!XWO#O>_O#WVO#ikO#jkOP#UXQ#UXR#UXg#UX$U#UXS#UXT#UXU#UXV#UXW#UXX#UXY#UXc#UXh#UXm#UXn#UX!`#UX!a#UX!b#UX!c#UX!d#UX!e#UX!f#UX!g#UX!h#UX!i#UX!j#UX!k#UX!l#UX!m#UX!n#UX!o#UX!p#UX!q#UX!r#UX!s#UX!t#UX!u#UX!v#UX~Oi=uOj=zOk4{Ol!}Oo3cOq3cOr4^Ot3cOvlOx3cOy4^Oz=hO{B`O|EpO}HPO!O'rO!P'{O!Q=nO!RBfO!SEvO!THVO!UHwO!V=nO!W'{O!Y3cO!Z4^O![=hO!]B`O!^EpO!_HPO!}#UX#V#UXe#UXZ#UX~P$CaOP#UXQ#UXR#UXg#UX$U#UX!}#UX#V#UX~P5bOS$[iT$[iU$[iV$[iW$[iX$[iY$[ic$[ih$[il$[im$[in$[iv$[i!`$[i!a$[i!b$[i!c$[i!d$[i!e$[i!f$[i!g$[i!h$[i!i$[i!j$[i!k$[i!l$[i!m$[i!n$[i!o$[i!p$[i!q$[i!r$[i!s$[i!t$[i!u$[i!v$[i$U$[i~OP(gOQ6OOR(gOg)RO#O$[i~P$ItOP!{XQ!{XR!{XS$`XT$`XU$`XV$`XW$`XX$`XY$`Xc$`Xg!{Xh$`Xl$`Xm$`Xn$`Xv$`X!`$`X!a$`X!b$`X!c$`X!d$`X!e$`X!f$`X!g$`X!h$`X!i$`X!j$`X!k$`X!l$`X!m$`X!n$`X!o$`X!p$`X!q$`X!r$`X!s$`X!t$`X!u$`X!v$`X#O$`X$U$`X!}$`X[$`Xb$`Xf$`X#V$`X#W$`X#i$`X#j$`XZ$`X_$`X`$`Xa$`Xi$`Xj$`Xk$`Xo$`Xp$`Xq$`Xr$`Xs$`Xt$`Xu$`Xw$`Xx$`Xy$`Xz$`X{$`X|$`X}$`X!O$`X!P$`X!Q$`X!R$`X!S$`X!T$`X!U$`X!V$`X!W$`X!X$`X!Y$`X!Z$`X![$`X!]$`X!^$`X!_$`X~O#V&`O~P#:qO#V&bO~P#=aOS!ziT!ziU!ziV!ziW!ziX!ziY!zic!zih!zil!zim!zin!ziv!zi!`!zi!a!zi!b!zi!c!zi!d!zi!e!zi!f!zi!g!zi!h!zi!i!zi!j!zi!k!zi!l!zi!m!zi!n!zi!o!zi!p!zi!q!zi!r!zi!s!zi!t!zi!u!zi!v!zi#O!zi$U!zi~OP(gOQ6OOR(gOg)RO~P%$oO[lO_lO`lOalObkOflOi5POj5QOk4cOo'qOpWOq'qOr3tOsWOt'qOuWOwWOx'qOy3tOz=OO{AvO|EWO}GgO!OWO!P'wO!Q4bO!R=qO!SBiO!TEyO!UHYO!V4bO!W'wO!XWO!Y'qO!Z3tO![=OO!]AvO!^EWO!_GgO#WVO#ikO#jkO~P%$oOSROTQOUSOVTOW5_OX5YO[!gO_lO`lOalObkOcuOf!mOh>^Oi5POj5QOk4cOl(jOm+TOn+TOo'qOpWOq'qOr3tOsWOt'qOuWOv5TOwWOx'qOy3tOz=OO{AvO|EWO}GgO!OWO!P'wO!Q4bO!R=qO!SBiO!TEyO!UHYO!V4bO!W'wO!XWO!Y'qO!Z3tO![=OO!]AvO!^EWO!_GgO!`uO!a(RO!b5eO!c>UO!dBoO!eFPO!fH`O!g(VO!h5iO!i>YO!jBsO!kFTO!lHdO!mIOO!nBsO!o+TO!puO!q(RO!r5eO!s>UO!tBoO!uFPO!vH`O#O<{O#W!jO#ikO#jkO#[#YP~O#V&mO~P%*aOP#lXQ#lXR#lXS#rXT#rXU#rXV#rXW#rXX#rXY#rX[#lX_#lX`#lXa#lXb#lXc#rXe#lXf#lXg#lXh#rXi#lXj#lXk#lXl#lXl#rXm#lXm#rXn#lXn#rXo#lXp#lXq#lXr#lXs#lXt#lXu#lXv#lXv#rXw#lXx#lXy#lXz#lX{#lX|#lX}#lX!O#lX!P#lX!Q#lX!R#lX!S#lX!T#lX!U#lX!V#lX!W#lX!X#lX!Y#lX!Z#lX![#lX!]#lX!^#lX!_#lX!`#lX!`#rX!a#lX!a#rX!b#lX!b#rX!c#lX!c#rX!d#lX!d#rX!e#lX!e#rX!f#lX!f#rX!g#lX!g#rX!h#lX!h#rX!i#lX!i#rX!j#lX!j#rX!k#lX!k#rX!l#lX!l#rX!m#lX!m#rX!n#lX!n#rX!o#rX!p#lX!p#rX!q#lX!q#rX!r#lX!r#rX!s#lX!s#rX!t#lX!t#rX!u#lX!u#rX!v#lX!v#rX#O#lX#W#lX#i#lX#j#lX$U#rX~O#O#rX~P%/qOP!|XQ!|XR!|XS#rXT#rXU#rXV#rXW#rXX#rXY#rX[!|X_!|X`!|Xa!|Xb!|Xc#rXe!|Xf!|Xg!|Xh#rXi!|Xj!|Xk!|Xl!|Xl#rXm!|Xm#rXn!|Xn#rXo!|Xp!|Xq!|Xr!|Xs!|Xt!|Xu!|Xv!|Xv#rXw!|Xx!|Xy!|Xz!|X{!|X|!|X}!|X!O!|X!P!|X!Q!|X!R!|X!S!|X!T!|X!U!|X!V!|X!W!|X!X!|X!Y!|X!Z!|X![!|X!]!|X!^!|X!_!|X!`!|X!`#rX!a!|X!a#rX!b!|X!b#rX!c!|X!c#rX!d!|X!d#rX!e!|X!e#rX!f!|X!f#rX!g!|X!g#rX!h!|X!h#rX!i!|X!i#rX!j!|X!j#rX!k!|X!k#rX!l!|X!l#rX!m!|X!m#rX!n!|X!n#rX!o#rX!p!|X!p#rX!q!|X!q#rX!r!|X!r#rX!s!|X!s#rX!t!|X!t#rX!u!|X!u#rX!v!|X!v#rX#O!|X#W!|X#i!|X#j!|X$U#rX~O#O#rX~P%7VO!}&oO~O[$[Ol$[O#V&qO~OW5[OX5VOZ&rOf$gOh>[Om+ROn+ROv+RO!a(OO!b5bO!c>RO!dBlO!eE|O!fH]O!g(TO!h5gO!i>WO!jBqO!kFRO!lHbO!mH|O!nBqO!o+RO!q(OO!r5bO!s>RO!tBlO!uE|O!vH]O#O$fO~P!%rO#V&tO~OW5]OX5WOf$gOh>[Om+QOn+QOv+QO!a(PO!b5cO!c>SO!dBmO!eE}O!fH^O!g(TO!h5gO!i>WO!jBqO!kFRO!lHbO!mH|O!nBqO!o+QO!q(PO!r5cO!s>SO!tBmO!uE}O!vH^O#O$fO#V&vO~P!%rO#V&vO~P$?xO#V&vOP!{XQ!{XR!{Xg!{X~O!}%qOP!{XQ!{XR!{Xg!{X~OS$PXT$PXU$PXV$PXW$PXX$PX[$OX[$PXb$OXb$PXc$PXf$PXh$PXl$PXm$PXn$PXv$PX!`$PX!a$PX!b$PX!c$PX!d$PX!e$PX!f$PX!g$PX!h$PX!i$PX!j$PX!k$PX!l$PX!m$PX!n$PX!o$PX!p$PX!q$PX!r$PX!s$PX!t$PX!u$PX!v$PX#O$PX#V$OX#V$PX#W$OX#W$PX#i$OX#i$PX#j$OX#j$PX~OP5oOQ!yOR5oOg$Yi$U$Yi!}$Yi#V$Yi~OP(WOQ!yOR(WOg#Rq$U#Rq~OP#RqQ#RqR#Rqg#Rq$U#Rq!}#Rq#V#Rq~P5bO#W'OO~O#W'PO~OS!zqT!zqU!zqV!zqW!zqX!zqY!zqc!zqh!zql!zqm!zqn!zqv!zq!`!zq!a!zq!b!zq!c!zq!d!zq!e!zq!f!zq!g!zq!h!zq!i!zq!j!zq!k!zq!l!zq!m!zq!n!zq!o!zq!p!zq!q!zq!r!zq!s!zq!t!zq!u!zq!v!zq#O!zq$U!zq~OP(gOQ6OOR(gOg)RO~P%HyO[lO_lO`lOalObkOflOi5POj5QOk4cOo'qOpWOq'qOr3tOsWOt'qOuWOwWOx'qOy3tOz=OO{AvO|EWO}GgO!OWO!P'wO!Q4bO!R=qO!SBiO!TEyO!UHYO!V4bO!W'wO!XWO!Y'qO!Z3tO![=OO!]AvO!^EWO!_GgO#WVO#ikO#jkO~P%HyOS$PXT$PXU$PXV$PXW$PXX$PX[$PXb$PXc$PXf$PXh$PXl$PXm$PXn$PXv$PX!`$PX!a$PX!b$PX!c$PX!d$PX!e$PX!f$PX!g$PX!h$PX!i$PX!j$PX!k$PX!l$PX!m$PX!n$PX!o$PX!p$PX!q$PX!r$PX!s$PX!t$PX!u$PX!v$PX#O$PX#V$PX#W$PX#i$PX#j$PX~OS#{XT#{XU#{XV#{XW#{XX#{Xc#{Xf#{Xh#{Xl#{Xm#{Xn#{Xv#{X!`#{X!a#{X!b#{X!c#{X!d#{X!e#{X!f#{X!g#{X!h#{X!i#{X!j#{X!k#{X!l#{X!m#{X!n#{X!o#{X!p#{X!q#{X!r#{X!s#{X!t#{X!u#{X!v#{X#O#{X#V#{X~P%NkO#V$lO~P$<fOS#faT#faU#faV#faW#faX#faY#fac#fah#fal#fam#fan#fav#fa!`#fa!a#fa!b#fa!c#fa!d#fa!e#fa!f#fa!g#fa!h#fa!i#fa!j#fa!k#fa!l#fa!m#fa!n#fa!o#fa!p#fa!q#fa!r#fa!s#fa!t#fa!u#fa!v#fa#O#fa$U#fa~P!9vO#V'WOP!{XQ!{XR!{Xg!{X~O[$[Ol$[O#V%xO~OW5[OX5VOZ'XOf$gOh>[Om+ROn+ROv+RO!a(OO!b5bO!c>RO!dBlO!eE|O!fH]O!g(TO!h5gO!i>WO!jBqO!kFRO!lHbO!mH|O!nBqO!o+RO!q(OO!r5bO!s>RO!tBlO!uE|O!vH]O#O$fO~P!%rO#V'YO~OP(WOQ!yOR(WOg#Ry$U#Ry~OP#RyQ#RyR#Ryg#Ry$U#Ry!}#Ry#V#Ry~P5bOS!zyT!zyU!zyV!zyW!zyX!zyY!zyc!zyh!zyl!zym!zyn!zyv!zy!`!zy!a!zy!b!zy!c!zy!d!zy!e!zy!f!zy!g!zy!h!zy!i!zy!j!zy!k!zy!l!zy!m!zy!n!zy!o!zy!p!zy!q!zy!r!zy!s!zy!t!zy!u!zy!v!zy#O!zy$U!zy~OP(gOQ6OOR(gOg)RO~P&,bO[lO_lO`lOalObkOflOi5POj5QOk4cOo'qOpWOq'qOr3tOsWOt'qOuWOwWOx'qOy3tOz=OO{AvO|EWO}GgO!OWO!P'wO!Q4bO!R=qO!SBiO!TEyO!UHYO!V4bO!W'wO!XWO!Y'qO!Z3tO![=OO!]AvO!^EWO!_GgO#WVO#ikO#jkO~P&,bOP#miQ#miR#miS#fiT#fiU#fiV#fiW#fiX#fiY#fi[#mi_#mi`#mia#mib#mic#fie#mif#mig#mih#fii#mij#mik#mil#mim#min#mio#mip#miq#mir#mis#mit#miu#miv#miw#mix#miy#miz#mi{#mi|#mi}#mi!O#mi!P#mi!Q#mi!R#mi!S#mi!T#mi!U#mi!V#mi!W#mi!X#mi!Y#mi!Z#mi![#mi!]#mi!^#mi!_#mi!`#mi!a#mi!b#mi!c#mi!d#mi!e#mi!f#mi!g#mi!h#mi!i#mi!j#mi!k#mi!l#mi!m#mi!n#mi!o#fi!p#mi!q#mi!r#mi!s#mi!t#mi!u#mi!v#mi#O#mi#W#mi#i#mi#j#mi$U#fi!}#fi#V#fiZ#fi~OP(WOQ!yOR(WOg#R!R$U#R!R~OP#R!RQ#R!RR#R!Rg#R!R$U#R!R!}#R!R#V#R!R~P5bO#V'kO~P5bO#V'lO~P5bOS!z!RT!z!RU!z!RV!z!RW!z!RX!z!RY!z!Rc!z!Rh!z!Rl!z!Rm!z!Rn!z!Rv!z!R!`!z!R!a!z!R!b!z!R!c!z!R!d!z!R!e!z!R!f!z!R!g!z!R!h!z!R!i!z!R!j!z!R!k!z!R!l!z!R!m!z!R!n!z!R!o!z!R!p!z!R!q!z!R!r!z!R!s!z!R!t!z!R!u!z!R!v!z!R#O!z!R$U!z!R~OP(gOQ6OOR(gOg)RO~P&9SO[lO_lO`lOalObkOflOi5POj5QOk4cOo'qOpWOq'qOr3tOsWOt'qOuWOwWOx'qOy3tOz=OO{AvO|EWO}GgO!OWO!P'wO!Q4bO!R=qO!SBiO!TEyO!UHYO!V4bO!W'wO!XWO!Y'qO!Z3tO![=OO!]AvO!^EWO!_GgO#WVO#ikO#jkO~P&9SOP(WOQ!yOR(WOg#R!Z$U#R!Z~OP#R!ZQ#R!ZR#R!Zg#R!Z$U#R!Z!}#R!Z#V#R!Z~P5bOS!z!ZT!z!ZU!z!ZV!z!ZW!z!ZX!z!ZY!z!Zc!z!Zh!z!Zl!z!Zm!z!Zn!z!Zv!z!Z!`!z!Z!a!z!Z!b!z!Z!c!z!Z!d!z!Z!e!z!Z!f!z!Z!g!z!Z!h!z!Z!i!z!Z!j!z!Z!k!z!Z!l!z!Z!m!z!Z!n!z!Z!o!z!Z!p!z!Z!q!z!Z!r!z!Z!s!z!Z!t!z!Z!u!z!Z!v!z!Z#O!z!Z$U!z!Z~OP(gOQ6OOR(gOg)RO~P&?pO[lO_lO`lOalObkOflOi5POj5QOk4cOo'qOpWOq'qOr3tOsWOt'qOuWOwWOx'qOy3tOz=OO{AvO|EWO}GgO!OWO!P'wO!Q4bO!R=qO!SBiO!TEyO!UHYO!V4bO!W'wO!XWO!Y'qO!Z3tO![=OO!]AvO!^EWO!_GgO#WVO#ikO#jkO~P&?pO[#RX_#RX`#RXa#RXb#RXf!zXf#RXi#RXj#RXk#RXl#RXo#RXp#RXq#RXr#RXs#RXt#RXu#RXv#RXw#RXx#RXy#RXz#RX{#RX|#RX}#RX!O#RX!P#RX!Q#RX!R#RX!S#RX!T#RX!U#RX!V#RX!W#RX!X#RX!Y#RX!Z#RX![#RX!]#RX!^#RX!_#RX#O#RX#V!zX#V#RX#V#lX#W#RX#i#RX#j#RX~P1nOP#RXQ#RXR#RX[#RXg#RXo#RXp#RXq#RXr#RXs#RXt#RXu#RXw#RXx#RXy#RXz#RX{#RX|#RX}#RX!O#RX!P#RX!Q#RX!R#RX!S#RX!T#RX!U#RX!V#RX!W#RX!X#RX!Y#RX!Z#RX![#RX!]#RX!^#RX!_#RX#W#RX~O_lO`lOalObkOflOi5POj5QOk4cOl!}OvlO#O>_O#ikO#jkO~P&HoO[lO_lO`lOalObkOi5POj5QOk4cOo'qOpWOq'qOr3tOsWOt'qOuWOwWOx'qOy3tOz=OO{AvO|EWO}GgO!OWO!P'wO!Q4bO!R=qO!SBiO!TEyO!UHYO!V4bO!W'wO!XWO!Y'qO!Z3tO![=OO!]AvO!^EWO!_GgO#WVO#ikO#jkOP#RXQ#RXR#RXS#RXT#RXU#RXV#RXW#RXX#RXc#RXg#RXh#RXl#RXm#RXn#RXv#RX!`#RX!a#RX!b#RX!c#RX!d#RX!e#RX!f#RX!g#RX!h#RX!i#RX!j#RX!k#RX!l#RX!m#RX!n#RX!o#RX!p#RX!q#RX!r#RX!s#RX!t#RX!u#RX!v#RX#O#RX~Of#RX#V#RXZ#RX~P&LOO[lO_lO`lOalObkOflOi5POj5QOk4cOo'qOpWOq'qOr3tOsWOt'qOuWOwWOx'qOy3tOz=OO{AvO|EWO}GgO!OWO!P'wO!Q4bO!R=qO!SBiO!TEyO!UHYO!V4bO!W'wO!XWO!Y'qO!Z3tO![=OO!]AvO!^EWO!_GgO#WVO#ikO#jkOP#RXQ#RXR#RXS#RXT#RXU#RXV#RXW#RXX#RXY#RXc#RXg#RXh#RXl#RXm#RXn#RXv#RX!`#RX!a#RX!b#RX!c#RX!d#RX!e#RX!f#RX!g#RX!h#RX!i#RX!j#RX!k#RX!l#RX!m#RX!n#RX!o#RX!p#RX!q#RX!r#RX!s#RX!t#RX!u#RX!v#RX$U#RX~O#O>_O~P'#lO#O#RX~P'#lO_lO`lOalOi5POj5QOk4cOo'qOpWOq'qOr3tOsWOt'qOuWOwWOx'qOy3tOz=OO{AvO|EWO}GgO!OWO!P'wO!Q4bO!R=qO!SBiO!TEyO!UHYO!V4bO!W'wO!XWO!Y'qO!Z3tO![=OO!]AvO!^EWO!_GgO~OP#RXQ#RXR#RXS#RXT#RXU#RXV#RXW#RXX#RX[#RXb#RXc#RXf#RXg#RXh#RXl#RXm#RXn#RXv#RX!`#RX!a#RX!b#RX!c#RX!d#RX!e#RX!f#RX!g#RX!h#RX!i#RX!j#RX!k#RX!l#RX!m#RX!n#RX!o#RX!p#RX!q#RX!r#RX!s#RX!t#RX!u#RX!v#RX#O#RX#V#RX#W#RX#i#RX#j#RX~P')aO[lO_lO`lOalObkOflOi=sOj=xOk4yOl!}Oo3_OpWOq3_Or4[OsWOt3_OuWOvlOwWOx3_Oy4[Oz=fO{B^O|EnO}G}O!O'sO!P'xO!Q=lO!RBdO!SEtO!THTO!UHuO!V=lO!W'xO!XWO!Y3_O!Z4[O![=fO!]B^O!^EnO!_G}O#O>_O#WVO#ikO#jkO~O[lO_lO`lOalObkOflOi=sOj=xOkAkOl!}Oo3dOpWOq3dOrAiOsWOt3dOuWOvlOwWOx3dOyAiOzD}O{G`O|HpO}IPO!O'sO!P'xO!Q=lO!RBdO!SEtO!THTO!UHuO!V=lO!W'xO!XWO!Y3dO!ZAiO![D}O!]G`O!^HpO!_IPO#O>_O#WVO#ikO#jkO~O[lO_lO`lOalObkOflOi=vOj={Ok4|Ol!}Oo3fOpWOq3fOr4_OsWOt3fOuWOvlOwWOx3fOy4_Oz=iO{BaO|EqO}HQO!O'tO!P'|O!Q=oO!RBgO!SEwO!THWO!UHxO!V=oO!W'|O!XWO!Y3fO!Z4_O![=iO!]BaO!^EqO!_HQO#O>_O#WVO#ikO#jkO~O[lO_lO`lOalObkOflOi=wOj=|Ok5OOl!}Oo3jOpWOq3jOr4aOsWOt3jOuWOvlOwWOx3jOy4aOz=kO{BcO|EsO}HSO!O'vO!P'yO!Q=pO!RBhO!SExO!THXO!UHyO!V=pO!W'yO!XWO!Y3jO!Z4aO![=kO!]BcO!^EsO!_HSO#O>_O#WVO#ikO#jkO~O!}!zX~P5bO[lObkO#WVO#ikO#jkOS!zXT!zXU!zXV!zXW!zXX!zXc!zXf!zXh!zXl!zXm!zXn!zXv!zX!`!zX!a!zX!b!zX!c!zX!d!zX!e!zX!f!zX!g!zX!h!zX!i!zX!j!zX!k!zX!l!zX!m!zX!n!zX!o!zX!p!zX!q!zX!r!zX!s!zX!t!zX!u!zX!v!zX#O!zX#V!zXZ!zX~P')aO#O>_O~PGfOS!zXT!zXU!zXV!zXW!zXX!zX[!zXb!zXc!zXf!zXh!zXl!zXm!zXn!zXv!zX!`!zX!a!zX!b!zX!c!zX!d!zX!e!zX!f!zX!g!zX!h!zX!i!zX!j!zX!k!zX!l!zX!m!zX!n!zX!o!zX!p!zX!q!zX!r!zX!s!zX!t!zX!u!zX!v!zX#O!zX#V!zX#W!zX#i!zX#j!zX~P')aO[lO_lO`lOalObkOflOiiOjjOk4}Ol!}Oo3iOpWOq3iOr4`OsWOt3iOuWOvlOwWOx3iOy4`Oz=jO{BbO|ErO}HRO!OaO!PbO!QcO!RdO!SeO!TfO!UgO!VcO!WbO!XWO!Y3iO!Z4`O![=jO!]BbO!^ErO!_HRO#O!]O#WVO#ikO#jkO~O[lO_lO`lOalObkOflOi=sOj=xOk4dOl!}Oo3sOpWOq3sOr3uOsWOt3sOuWOvlOwWOx3sOy3uOz=PO{AwO|EXO}GhO!O'sO!P'xO!Q=lO!RBdO!SEtO!THTO!UHuO!V=lO!W'xO!XWO!Y3sO!Z3uO![=PO!]AwO!^EXO!_GhO#O>_O#WVO#ikO#jkO~O[lO_lO`lOalObkOflOi=sOj=xOk4eOl!}Oo3rOpWOq3rOr3vOsWOt3rOuWOvlOwWOx3rOy3vOz=QO{AxO|EYO}GiO!O'sO!P'xO!Q=lO!RBdO!SEtO!THTO!UHuO!V=lO!W'xO!XWO!Y3rO!Z3vO![=QO!]AxO!^EYO!_GiO#O>_O#WVO#ikO#jkO~O[lO_lO`lOalObkOflOi=vOj={Ok4fOl!}Oo3pOpWOq3pOr3wOsWOt3pOuWOvlOwWOx3pOy3wOz=RO{AyO|EZO}GjO!O'tO!P'|O!Q=oO!RBgO!SEwO!THWO!UHxO!V=oO!W'|O!XWO!Y3pO!Z3wO![=RO!]AyO!^EZO!_GjO#O>_O#WVO#ikO#jkO~O[lO_lO`lOalObkOflOi=tOj=yOk4gOl!}Oo3nOpWOq3nOr3xOsWOt3nOuWOvlOwWOx3nOy3xOz=SO{AzO|E[O}GkO!O'uO!P'zO!Q=mO!RBeO!SEuO!THUO!UHvO!V=mO!W'zO!XWO!Y3nO!Z3xO![=SO!]AzO!^E[O!_GkO#O>_O#WVO#ikO#jkO~O[lO_lO`lOalObkOflOi=wOj=|Ok4hOl!}Oo3mOpWOq3mOr3yOsWOt3mOuWOvlOwWOx3mOy3yOz=TO{A{O|E]O}GlO!O'vO!P'yO!Q=pO!RBhO!SExO!THXO!UHyO!V=pO!W'yO!XWO!Y3mO!Z3yO![=TO!]A{O!^E]O!_GlO#O>_O#WVO#ikO#jkO~O[lO_lO`lOalObkOflOi=tOj=yOk4jOl!}Oo3kOpWOq3kOr3{OsWOt3kOuWOvlOwWOx3kOy3{Oz=VO{A}O|E_O}GnO!O'uO!P'zO!Q=mO!RBeO!SEuO!THUO!UHvO!V=mO!W'zO!XWO!Y3kO!Z3{O![=VO!]A}O!^E_O!_GnO#O>_O#WVO#ikO#jkO~O[lO_lO`lOalObkOflOi=uOj=zOk4kOl!}Oo3hOpWOq3hOr3|OsWOt3hOuWOvlOwWOx3hOy3|Oz=WO{BOO|E`O}GoO!O'rO!P'{O!Q=nO!RBfO!SEvO!THVO!UHwO!V=nO!W'{O!XWO!Y3hO!Z3|O![=WO!]BOO!^E`O!_GoO#O>_O#WVO#ikO#jkO~O[lO_lO`lOalObkOflOi=sOj=xOk4oOl!}Oo3`OpWOq3`Or4QOsWOt3`OuWOvlOwWOx3`Oy4QOz=[O{BSO|EdO}GsO!O'sO!P'xO!Q=lO!RBdO!SEtO!THTO!UHuO!V=lO!W'xO!XWO!Y3`O!Z4QO![=[O!]BSO!^EdO!_GsO#O>_O#WVO#ikO#jkO~O[lO_lO`lOalObkOflOi=sOj=xOk4qOl!}Oo3]OpWOq3]Or4SOsWOt3]OuWOvlOwWOx3]Oy4SOz=^O{BUO|EfO}GuO!O'sO!P'xO!Q=lO!RBdO!SEtO!THTO!UHuO!V=lO!W'xO!XWO!Y3]O!Z4SO![=^O!]BUO!^EfO!_GuO#O>_O#WVO#ikO#jkO~O[lO_lO`lOalObkOflOi=vOj={Ok4sOl!}Oo3YOpWOq3YOr4UOsWOt3YOuWOvlOwWOx3YOy4UOz=`O{BWO|EhO}GwO!O'tO!P'|O!Q=oO!RBgO!SEwO!THWO!UHxO!V=oO!W'|O!XWO!Y3YO!Z4UO![=`O!]BWO!^EhO!_GwO#O>_O#WVO#ikO#jkO~O[lO_lO`lOalObkOflOi=tOj=yOk4tOl!}Oo3WOpWOq3WOr4VOsWOt3WOuWOvlOwWOx3WOy4VOz=aO{BXO|EiO}GxO!O'uO!P'zO!Q=mO!RBeO!SEuO!THUO!UHvO!V=mO!W'zO!XWO!Y3WO!Z4VO![=aO!]BXO!^EiO!_GxO#O>_O#WVO#ikO#jkO~O[lO_lO`lOalObkOflOi=uOj=zOk4{Ol!}Oo3cOpWOq3cOr4^OsWOt3cOuWOvlOwWOx3cOy4^Oz=hO{B`O|EpO}HPO!O'rO!P'{O!Q=nO!RBfO!SEvO!THVO!UHwO!V=nO!W'{O!XWO!Y3cO!Z4^O![=hO!]B`O!^EpO!_HPO#O>_O#WVO#ikO#jkO~O[lO_lO`lOalObkOflOi=wOj=|Ok4wOl!}Oo3[OpWOq3[Or4YOsWOt3[OuWOvlOwWOx3[Oy4YOz=dO{B[O|ElO}G{O!O'vO!P'yO!Q=pO!RBhO!SExO!THXO!UHyO!V=pO!W'yO!XWO!Y3[O!Z4YO![=dO!]B[O!^ElO!_G{O#O>_O#WVO#ikO#jkO~O[lO_lO`lOalObkOflOi=tOj=yOk4zOl!}Oo3bOpWOq3bOr4]OsWOt3bOuWOvlOwWOx3bOy4]Oz=gO{B_O|EoO}HOO!O'uO!P'zO!Q=mO!RBeO!SEuO!THUO!UHvO!V=mO!W'zO!XWO!Y3bO!Z4]O![=gO!]B_O!^EoO!_HOO#O>_O#WVO#ikO#jkO~O#V#zX~P!,}O[!zX[#zXb!zXf!zXl#zX#V!zX#V#RX#V#lX#V#zX#W!zX#[#zX#i!zX#j!zX~P1nO[!zX[#RX[#zX_#RX`#RXa#RXb!zXb#RXf!zXf#RXi#RXj#RXk#RXl#RXl#zXo#RXp#RXq#RXr#RXs#RXt#RXu#RXv#RXw#RXx#RXy#RXz#RX{#RX|#RX}#RX!O#RX!P#RX!Q#RX!R#RX!S#RX!T#RX!U#RX!V#RX!W#RX!X#RX!Y#RX!Z#RX![#RX!]#RX!^#RX!_#RX#O#RX#V!zX#V#RX#V#lX#W!zX#W#RX#[#zX#i!zX#i#RX#j!zX#j#RX~P1nO[#RX[#zX_#RX`#RXa#RXb#RXf!zXf#RXi#RXj#RXk#RXl#RXl#zXo#RXp#RXq#RXr#RXs#RXt#RXu#RXv#RXw#RXx#RXy#RXz#RX{#RX|#RX}#RX!O#RX!P#RX!Q#RX!R#RX!S#RX!T#RX!U#RX!V#RX!W#RX!X#RX!Y#RX!Z#RX![#RX!]#RX!^#RX!_#RX#O#RX#V!zX#V#RX#V#lX#W#RX#[#zX#i#RX#j#RX~P1nO[lO_lO`lOalObkOflOi=sOj=xOk4iOl!}Oo3lOpWOq3lOr3zOsWOt3lOuWOvlOwWOx3lOy3zOz=UO{A|O|E^O}GmO!O'sO!P'xO!Q=lO!RBdO!SEtO!THTO!UHuO!V=lO!W'xO!XWO!Y3lO!Z3zO![=UO!]A|O!^E^O!_GmO#O>_O#WVO#ikO#jkO~O[lO_lO`lOalObkOflOi=sOj=xOk4lOl!}Oo3eOpWOq3eOr3}OsWOt3eOuWOvlOwWOx3eOy3}Oz=XO{BPO|EaO}GpO!O'sO!P'xO!Q=lO!RBdO!SEtO!THTO!UHuO!V=lO!W'xO!XWO!Y3eO!Z3}O![=XO!]BPO!^EaO!_GpO#O>_O#WVO#ikO#jkO~O[lO_lO`lOalObkOflOi=vOj={Ok4nOl!}Oo3aOpWOq3aOr4POsWOt3aOuWOvlOwWOx3aOy4POz=ZO{BRO|EcO}GrO!O'tO!P'|O!Q=oO!RBgO!SEwO!THWO!UHxO!V=oO!W'|O!XWO!Y3aO!Z4PO![=ZO!]BRO!^EcO!_GrO#O>_O#WVO#ikO#jkO~O[lO_lO`lOalObkOflOi=tOj=yOk4pOl!}Oo3^OpWOq3^Or4ROsWOt3^OuWOvlOwWOx3^Oy4ROz=]O{BTO|EeO}GtO!O'uO!P'zO!Q=mO!RBeO!SEuO!THUO!UHvO!V=mO!W'zO!XWO!Y3^O!Z4RO![=]O!]BTO!^EeO!_GtO#O>_O#WVO#ikO#jkO~O[lO_lO`lOalObkOflOi=wOj=|Ok4rOl!}Oo3ZOpWOq3ZOr4TOsWOt3ZOuWOvlOwWOx3ZOy4TOz=_O{BVO|EgO}GvO!O'vO!P'yO!Q=pO!RBhO!SExO!THXO!UHyO!V=pO!W'yO!XWO!Y3ZO!Z4TO![=_O!]BVO!^EgO!_GvO#O>_O#WVO#ikO#jkO~O[lO_lO`lOalObkOflOi=tOj=yOk4uOl!}Oo3VOpWOq3VOr4WOsWOt3VOuWOvlOwWOx3VOy4WOz=bO{BYO|EjO}GyO!O'uO!P'zO!Q=mO!RBeO!SEuO!THUO!UHvO!V=mO!W'zO!XWO!Y3VO!Z4WO![=bO!]BYO!^EjO!_GyO#O>_O#WVO#ikO#jkO~O[lO_lO`lOalObkOflOi=uOj=zOk4vOl!}Oo3XOpWOq3XOr4XOsWOt3XOuWOvlOwWOx3XOy4XOz=cO{BZO|EkO}GzO!O'rO!P'{O!Q=nO!RBfO!SEvO!THVO!UHwO!V=nO!W'{O!XWO!Y3XO!Z4XO![=cO!]BZO!^EkO!_GzO#O>_O#WVO#ikO#jkO~OP5oOQ!yOR5oOg#Ra!}#Ra#V#Ra$U#Ra~O[#Rab#Raf#Rag#Ral#Rav#Ra#O#Ra#W#Ra#i#Ra#j#RaS#RaT#RaU#RaV#RaW#RaX#Rac#Rah#Ram#Ran#Ra!`#Ra!a#Ra!b#Ra!c#Ra!d#Ra!e#Ra!f#Ra!g#Ra!h#Ra!i#Ra!j#Ra!k#Ra!l#Ra!m#Ra!n#Ra!o#Ra!p#Ra!q#Ra!r#Ra!s#Ra!t#Ra!u#Ra!v#Ra#V#Ra~OP(XOQ5qOR(XO_#Ra`#Raa#Rai#Raj#Rak#Rao#Rap#Raq#Rar#Ras#Rat#Rau#Raw#Rax#Ray#Raz#Ra{#Ra|#Ra}#Ra!O#Ra!P#Ra!Q#Ra!R#Ra!S#Ra!T#Ra!U#Ra!V#Ra!W#Ra!X#Ra!Y#Ra!Z#Ra![#Ra!]#Ra!^#Ra!_#Ra$U#RaY#Rae#Ra!}#RaZ#Ra~P)/aOP(YOR(YOS#RaT#RaU#RaV#RaW#RaX#RaZ#Rac#Raf#Rag#Rah#Ral#Ram#Ran#Rav#Ra!`#Ra!a#Ra!b#Ra!c#Ra!d#Ra!e#Ra!f#Ra!g#Ra!h#Ra!i#Ra!j#Ra!k#Ra!l#Ra!m#Ra!n#Ra!o#Ra!p#Ra!q#Ra!r#Ra!s#Ra!t#Ra!u#Ra!v#Ra#O#Ra~OQ5rO~P)5ZOP(ZOR(ZOS#RaT#RaU#RaV#RaW#RaX#Rac#Raf#Rag#Rah#Ral#Ram#Ran#Rav#Ra!`#Ra!a#Ra!b#Ra!c#Ra!d#Ra!e#Ra!f#Ra!g#Ra!h#Ra!i#Ra!j#Ra!k#Ra!l#Ra!m#Ra!n#Ra!o#Ra!p#Ra!q#Ra!r#Ra!s#Ra!t#Ra!u#Ra!v#Ra#O#Ra#V#Ra~OQ5sO~P)8TOP([OR([OS#RaT#RaU#RaV#RaW#RaX#RaY#Rac#Rag#Rah#Ral#Ram#Ran#Rav#Ra!`#Ra!a#Ra!b#Ra!c#Ra!d#Ra!e#Ra!f#Ra!g#Ra!h#Ra!i#Ra!j#Ra!k#Ra!l#Ra!m#Ra!n#Ra!o#Ra!p#Ra!q#Ra!r#Ra!s#Ra!t#Ra!u#Ra!v#Ra$U#Ra~OQ5tO~P):}OP(]OR(]OW#RaX#Rac#Rag#Rah#Ral#Ram#Ran#Rav#Ra!`#Ra!a#Ra!b#Ra!c#Ra!d#Ra!e#Ra!f#Ra!g#Ra!h#Ra!i#Ra!j#Ra!k#Ra!l#Ra!m#Ra!n#Ra!o#Ra!p#Ra!q#Ra!r#Ra!s#Ra!t#Ra!u#Ra!v#Ra#O#Ra$U#Ra~OQ5uO~P)=tOP(^OQ5vOR(^O~P)/aOP(_OR(_OS#RaT#RaU#RaV#RaW#RaX#RaY#Rac#Rag#Rah#Ral#Ram#Ran#Rav#Ra!`#Ra!a#Ra!b#Ra!c#Ra!d#Ra!e#Ra!f#Ra!g#Ra!h#Ra!i#Ra!j#Ra!k#Ra!l#Ra!m#Ra!n#Ra!o#Ra!p#Ra!q#Ra!r#Ra!s#Ra!t#Ra!u#Ra!v#Ra#O#Ra$U#Ra~OQ5xO~P)@lOP(`OR(`O[#Rag#Rao#Rap#Raq#Rar#Ras#Rat#Rau#Raw#Rax#Ray#Raz#Ra{#Ra|#Ra}#Ra!O#Ra!P#Ra!Q#Ra!R#Ra!S#Ra!T#Ra!U#Ra!V#Ra!W#Ra!X#Ra!Y#Ra!Z#Ra![#Ra!]#Ra!^#Ra!_#Ra#W#Ra~OQ5yO~P)CfOP(aOR(aOS#RaT#RaU#RaV#RaW#RaX#RaZ#Rac#Raf#Rag#Rah#Ral#Ram#Ran#Rav#Ra!`#Ra!a#Ra!b#Ra!c#Ra!d#Ra!e#Ra!f#Ra!g#Ra!h#Ra!i#Ra!j#Ra!k#Ra!l#Ra!m#Ra!n#Ra!o#Ra!p#Ra!q#Ra!r#Ra!s#Ra!t#Ra!u#Ra!v#Ra#O#Ra~OQ5rO~P)E|OP(bOR(bOS#RaT#RaU#RaV#RaW#RaX#Rac#Raf#Rag#Rah#Ral#Ram#Ran#Rav#Ra!`#Ra!a#Ra!b#Ra!c#Ra!d#Ra!e#Ra!f#Ra!g#Ra!h#Ra!i#Ra!j#Ra!k#Ra!l#Ra!m#Ra!n#Ra!o#Ra!p#Ra!q#Ra!r#Ra!s#Ra!t#Ra!u#Ra!v#Ra#O#Ra#V#Ra~OQ5sO~P)HvOP(cOR(cOS#RaT#RaU#RaV#RaW#RaX#RaY#Rac#Rag#Rah#Ral#Ram#Ran#Rav#Ra!`#Ra!a#Ra!b#Ra!c#Ra!d#Ra!e#Ra!f#Ra!g#Ra!h#Ra!i#Ra!j#Ra!k#Ra!l#Ra!m#Ra!n#Ra!o#Ra!p#Ra!q#Ra!r#Ra!s#Ra!t#Ra!u#Ra!v#Ra$U#Ra~OQ5tO~P)KpOP(dOR(dOW#RaX#Rac#Rag#Rah#Ral#Ram#Ran#Rav#Ra!`#Ra!a#Ra!b#Ra!c#Ra!d#Ra!e#Ra!f#Ra!g#Ra!h#Ra!i#Ra!j#Ra!k#Ra!l#Ra!m#Ra!n#Ra!o#Ra!p#Ra!q#Ra!r#Ra!s#Ra!t#Ra!u#Ra!v#Ra#O#Ra$U#Ra~OQ5uO~P)NgOP(fOQ5vOR(fO~P)/aOP(gOR(gOS#RaT#RaU#RaV#RaW#RaX#RaY#Rac#Rag#Rah#Ral#Ram#Ran#Rav#Ra!`#Ra!a#Ra!b#Ra!c#Ra!d#Ra!e#Ra!f#Ra!g#Ra!h#Ra!i#Ra!j#Ra!k#Ra!l#Ra!m#Ra!n#Ra!o#Ra!p#Ra!q#Ra!r#Ra!s#Ra!t#Ra!u#Ra!v#Ra#O#Ra$U#Ra~OQ5xO~P*#_OP(eOR(eO[#Rag#Rao#Rap#Raq#Rar#Ras#Rat#Rau#Raw#Rax#Ray#Raz#Ra{#Ra|#Ra}#Ra!O#Ra!P#Ra!Q#Ra!R#Ra!S#Ra!T#Ra!U#Ra!V#Ra!W#Ra!X#Ra!Y#Ra!Z#Ra![#Ra!]#Ra!^#Ra!_#Ra#W#Ra~OQ5yO~P*&XOP#lXQ#lXR#lX_#RX`#RXa#RXb#RXf#RXg#lXi#RXj#RXk#RXl#RXv#RX#O#RX#V#RX#i#RX#j#RX~P&HoOP(XOQ5qOR(XOg(lO~P'C|OP(XOQ5qOR(XOg(lO~P'F{OP(XOQ5qOR(XOg(lO~P'IzOP(XOQ5qOR(XOg(lO~P'LyOP(XOQ5qOR(XOg(lO~P( xOP(XOQ5qOR(XOg(lO~P(HPOP(XOQ5qOR(XOg(lO~P($wOP(XOQ5qOR(XOg(lO~P('vOP(XOQ5qOR(XOg(lO~P(KOOP(XOQ5qOR(XOg(lO~P;ZOP(XOQ5qOR(XOg(lO~P(M}OP(XOQ5qOR(XOg(lO~P(*uOP(XOQ5qOR(XOg(lO~P)!|OP(XOQ5qOR(XOg(lO~P(-tOP(XOQ5qOR(XOg(lO~P)%{OP(XOQ5qOR(XOg(lO~P(0sOP(XOQ5qOR(XOg(lO~P(3rOP(XOQ5qOR(XOg(lO~P)(zOP(XOQ5qOR(XOg(lO~P)+yOP(XOQ5qOR(XOg(lO~P(9pOP(XOQ5qOR(XOg(lO~P'.zOP(XOQ5qOR(XOg(lO~P(<oOP(XOQ5qOR(XOg(lO~P(6qOP(XOQ5qOR(XOg(lO~P'4xOP(XOQ5qOR(XOg(lO~P'@}OP(XOQ5qOR(XOg(lO~P'7wO_lO`lOalObkOflOi5POj5QOk4cOl!}OvlO#O>_O#ikO#jkOP#RaQ#RaR#Ra~P)ClO[lObkO#WVO#ikO#jkOP#RaQ#RaR#RaS#RaT#RaU#RaV#RaW#RaX#Rac#Raf#Rag#Rah#Ral#Ram#Ran#Rav#Ra!`#Ra!a#Ra!b#Ra!c#Ra!d#Ra!e#Ra!f#Ra!g#Ra!h#Ra!i#Ra!j#Ra!k#Ra!l#Ra!m#Ra!n#Ra!o#Ra!p#Ra!q#Ra!r#Ra!s#Ra!t#Ra!u#Ra!v#Ra#O#Ra#V#RaZ#Ra~P')aO[lObkOflO#O>_O#WVO#ikO#jkOP#RaQ#RaR#RaS#RaT#RaU#RaV#RaW#RaX#RaY#Rac#Rag#Rah#Ral#Ram#Ran#Rav#Ra!`#Ra!a#Ra!b#Ra!c#Ra!d#Ra!e#Ra!f#Ra!g#Ra!h#Ra!i#Ra!j#Ra!k#Ra!l#Ra!m#Ra!n#Ra!o#Ra!p#Ra!q#Ra!r#Ra!s#Ra!t#Ra!u#Ra!v#Ra$U#Ra~P')aO[lObkOflO#WVO#ikO#jkOP#RaQ#RaR#RaS#RaT#RaU#RaV#RaW#RaX#RaY#Rac#Rag#Rah#Ral#Ram#Ran#Rav#Ra!`#Ra!a#Ra!b#Ra!c#Ra!d#Ra!e#Ra!f#Ra!g#Ra!h#Ra!i#Ra!j#Ra!k#Ra!l#Ra!m#Ra!n#Ra!o#Ra!p#Ra!q#Ra!r#Ra!s#Ra!t#Ra!u#Ra!v#Ra#O#Ra$U#Ra~P')aO_lO`lOalOi5POj5QOk4cOo'qOpWOq'qOr3tOsWOt'qOuWOwWOx'qOy3tOz=OO{AvO|EWO}GgO!OWO!P'wO!Q4bO!R=qO!SBiO!TEyO!UHYO!V4bO!W'wO!XWO!Y'qO!Z3tO![=OO!]AvO!^EWO!_GgOP#RaQ#RaR#Ra~P)/aOQ#]O~P#5lOP(XOQ5qOR(XOg(lO!}$]a~P!)POP(XOQ5qOR(XOg(lOS$]aT$]aU$]aV$]aW$]aX$]aZ$]ac$]ah$]am$]an$]a!`$]a!a$]a!b$]a!c$]a!d$]a!e$]a!f$]a!g$]a!h$]a!i$]a!j$]a!k$]a!l$]a!m$]a!n$]a!o$]a!p$]a!q$]a!r$]a!s$]a!t$]a!u$]a!v$]a~P'.zOP(XOQ5qOR(XOg(lOS$]aT$]aU$]aV$]aW$]aX$]ac$]ah$]am$]an$]a!`$]a!a$]a!b$]a!c$]a!d$]a!e$]a!f$]a!g$]a!h$]a!i$]a!j$]a!k$]a!l$]a!m$]a!n$]a!o$]a!p$]a!q$]a!r$]a!s$]a!t$]a!u$]a!v$]a#V$]a~P'1yOP(XOQ5qOR(XOg(lOS$]aT$]aU$]aV$]aW$]aX$]aY$]ac$]ah$]am$]an$]a!`$]a!a$]a!b$]a!c$]a!d$]a!e$]a!f$]a!g$]a!h$]a!i$]a!j$]a!k$]a!l$]a!m$]a!n$]a!o$]a!p$]a!q$]a!r$]a!s$]a!t$]a!u$]a!v$]a$U$]a~P'4xOP(XOQ5qOR(XOg(lOS$]aT$]aU$]aV$]aW$]aX$]ac$]ah$]am$]an$]a!`$]a!a$]a!b$]a!c$]a!d$]a!e$]a!f$]a!g$]a!h$]a!i$]a!j$]a!k$]a!l$]a!m$]a!n$]a!o$]a!p$]a!q$]a!r$]a!s$]a!t$]a!u$]a!v$]a#V$]a~P'7wOP5oOQ!yOR5oOg6QO!}!za~OS!zaT!zaU!zaV!zaW!zaX!zaZ!zac!zaf!zah!zal!zam!zan!zav!za!`!za!a!za!b!za!c!za!d!za!e!za!f!za!g!za!h!za!i!za!j!za!k!za!l!za!m!za!n!za!o!za!p!za!q!za!r!za!s!za!t!za!u!za!v!za#O!za~OP(aOQ5wOR(aOg)SO~P*KnOS!zaT!zaU!zaV!zaW!zaX!zac!zaf!zah!zal!zam!zan!zav!za!`!za!a!za!b!za!c!za!d!za!e!za!f!za!g!za!h!za!i!za!j!za!k!za!l!za!m!za!n!za!o!za!p!za!q!za!r!za!s!za!t!za!u!za!v!za#O!za#V!za~OP(bOQ5zOR(bOg:oO~P*NhOS!zaT!zaU!zaV!zaW!zaX!zaY!zac!zah!zal!zam!zan!zav!za!`!za!a!za!b!za!c!za!d!za!e!za!f!za!g!za!h!za!i!za!j!za!k!za!l!za!m!za!n!za!o!za!p!za!q!za!r!za!s!za!t!za!u!za!v!za$U!za~OP(cOQ5{OR(cOg)VO~P+#bOW!zaX!zac!zah!zal!zam!zan!zav!za!`!za!a!za!b!za!c!za!d!za!e!za!f!za!g!za!h!za!i!za!j!za!k!za!l!za!m!za!n!za!o!za!p!za!q!za!r!za!s!za!t!za!u!za!v!za#O!za~OP(dOQ5|OR(dOg:pO$U!za~P+&XOP(fOQ6POR(fOg)XO[!zab!za#W!za#i!za#j!za~P*NhOP(XOQ5qOR(XOg(lO~P'1yO!}!za~P5bO[lO_lO`lOalObkOi5POj5QOk4cOo'qOpWOq'qOr3tOsWOt'qOuWOwWOx'qOy3tOz=OO{AvO|EWO}GgO!OWO!P'wO!Q4bO!R=qO!SBiO!TEyO!UHYO!V4bO!W'wO!XWO!Y'qO!Z3tO![=OO!]AvO!^EWO!_GgO#WVO#ikO#jkO#V!za~P*KnO[lO_lO`lOalObkOflOi5POj5QOk4cOo'qOpWOq'qOr3tOsWOt'qOuWOwWOx'qOy3tOz=OO{AvO|EWO}GgO!OWO!P'wO!Q4bO!R=qO!SBiO!TEyO!UHYO!V4bO!W'wO!XWO!Y'qO!Z3tO![=OO!]AvO!^EWO!_GgO#O>_O#WVO#ikO#jkO~P+#bO_lO`lOalOi5POj5QOk4cOo'qOpWOq'qOr3tOsWOt'qOuWOwWOx'qOy3tOz=OO{AvO|EWO}GgO!OWO!P'wO!Q4bO!R=qO!SBiO!TEyO!UHYO!V4bO!W'wO!XWO!Y'qO!Z3tO![=OO!]AvO!^EWO!_GgO[!zab!za#W!za#i!za#j!za~P*NhO[#Pi_#Pi_#Qi`#Pi`#Qia#Pia#Qib#Pif#Pii#Pii#Qij#Pij#Qik#Pik#Qil#Pio#Pio#Qip#Pip#Qiq#Piq#Qir#Pir#Qis#Pis#Qit#Pit#Qiu#Piu#Qiv#Piw#Piw#Qix#Pix#Qiy#Piy#Qiz#Piz#Qi{#Pi{#Qi|#Pi|#Qi}#Pi}#Qi!O#Pi!O#Qi!P#Pi!P#Qi!Q#Pi!Q#Qi!R#Pi!R#Qi!S#Pi!S#Qi!T#Pi!T#Qi!U#Pi!U#Qi!V#Pi!V#Qi!W#Pi!W#Qi!X#Pi!X#Qi!Y#Pi!Y#Qi!Z#Pi!Z#Qi![#Pi![#Qi!]#Pi!]#Qi!^#Pi!^#Qi!_#Pi!_#Qi#O#Pi#W#Pi#i#Pi#j#PiS#PiT#PiU#PiV#PiW#PiX#PiY#PiY#Qic#Pih#Pim#Pin#Pi!`#Pi!a#Pi!b#Pi!c#Pi!d#Pi!e#Pi!f#Pi!g#Pi!h#Pi!i#Pi!j#Pi!k#Pi!l#Pi!m#Pi!n#Pi!o#Pi!p#Pi!q#Pi!r#Pi!s#Pi!t#Pi!u#Pi!v#Pie#Pie#QiZ#PiZ#Qi~P$ XO[#Si_#Qi_#Si`#Qi`#Sia#Qia#Sib#Sif#Sii#Qii#Sij#Qij#Sik#Qik#Sil#Sio#Qio#Sip#Qip#Siq#Qiq#Sir#Qir#Sis#Qis#Sit#Qit#Siu#Qiu#Siv#Siw#Qiw#Six#Qix#Siy#Qiy#Siz#Qiz#Si{#Qi{#Si|#Qi|#Si}#Qi}#Si!O#Qi!O#Si!P#Qi!P#Si!Q#Qi!Q#Si!R#Qi!R#Si!S#Qi!S#Si!T#Qi!T#Si!U#Qi!U#Si!V#Qi!V#Si!W#Qi!W#Si!X#Qi!X#Si!Y#Qi!Y#Si!Z#Qi!Z#Si![#Qi![#Si!]#Qi!]#Si!^#Qi!^#Si!_#Qi!_#Si#O#Si#W#Si#i#Si#j#SiS#SiT#SiU#SiV#SiW#SiX#SiY#QiY#Sic#Sih#Sim#Sin#Si!`#Si!a#Si!b#Si!c#Si!d#Si!e#Si!f#Si!g#Si!h#Si!i#Si!j#Si!k#Si!l#Si!m#Si!n#Si!o#Si!p#Si!q#Si!r#Si!s#Si!t#Si!u#Si!v#Sie#Qie#SiZ#QiZ#Si~P$$yOP#QiP#SiQ#QiQ#SiR#QiR#SiS#QiT#QiU#QiV#QiW#QiX#Qi[#Si_#Si`#Sia#Sib#Sic#Qif#Qif#Sig#Qig#Sih#Qii#Sij#Sik#Sil#Qil#Sim#Qin#Qio#Sip#Siq#Sir#Sis#Sit#Siu#Siv#Qiv#Siw#Six#Siy#Siz#Si{#Si|#Si}#Si!O#Si!P#Si!Q#Si!R#Si!S#Si!T#Si!U#Si!V#Si!W#Si!X#Si!Y#Si!Z#Si![#Si!]#Si!^#Si!_#Si!`#Qi!a#Qi!b#Qi!c#Qi!d#Qi!e#Qi!f#Qi!g#Qi!h#Qi!i#Qi!j#Qi!k#Qi!l#Qi!m#Qi!n#Qi!o#Qi!p#Qi!q#Qi!r#Qi!s#Qi!t#Qi!u#Qi!v#Qi#O#Qi#O#Si#V#Qi#V#Si#W#Si#i#Si#j#Si~O[#Qib#Qi#W#Qi#i#Qi#j#Qi~P+BYOP#QiP#SiQ#QiQ#SiR#QiR#Si[#Si_#Si`#Sia#Sib#Sif#Sig#Qig#Sii#Sij#Sik#Sil#Sio#Sip#Siq#Sir#Sis#Sit#Siu#Siv#Siw#Six#Siy#Siz#Si{#Si|#Si}#Si!O#Si!P#Si!Q#Si!R#Si!S#Si!T#Si!U#Si!V#Si!W#Si!X#Si!Y#Si!Z#Si![#Si!]#Si!^#Si!_#Si#O#Si#V#Si#W#Si#i#Si#j#Si~OP(WOQ!yOR(WOg$Xa$U$Xa~O[$Xab$Xaf$Xag$Xal$Xav$Xa#O$Xa#W$Xa#i$Xa#j$XaS$XaT$XaU$XaV$XaW$XaX$Xac$Xah$Xam$Xan$Xa!`$Xa!a$Xa!b$Xa!c$Xa!d$Xa!e$Xa!f$Xa!g$Xa!h$Xa!i$Xa!j$Xa!k$Xa!l$Xa!m$Xa!n$Xa!o$Xa!p$Xa!q$Xa!r$Xa!s$Xa!t$Xa!u$Xa!v$Xa#V$Xa~OP(XOQ5qOR(XO_$Xa`$Xaa$Xai$Xaj$Xak$Xao$Xap$Xaq$Xar$Xas$Xat$Xau$Xaw$Xax$Xay$Xaz$Xa{$Xa|$Xa}$Xa!O$Xa!P$Xa!Q$Xa!R$Xa!S$Xa!T$Xa!U$Xa!V$Xa!W$Xa!X$Xa!Y$Xa!Z$Xa![$Xa!]$Xa!^$Xa!_$Xa$U$XaY$Xae$Xa!}$XaZ$Xa~P+LlOQ5rOS$XaT$XaU$XaV$XaW$XaX$XaZ$Xac$Xaf$Xag$Xah$Xal$Xam$Xan$Xav$Xa!`$Xa!a$Xa!b$Xa!c$Xa!d$Xa!e$Xa!f$Xa!g$Xa!h$Xa!i$Xa!j$Xa!k$Xa!l$Xa!m$Xa!n$Xa!o$Xa!p$Xa!q$Xa!r$Xa!s$Xa!t$Xa!u$Xa!v$Xa#O$Xa~OP(YOR(YO~P,$fOQ5sOS$XaT$XaU$XaV$XaW$XaX$Xac$Xaf$Xag$Xah$Xal$Xam$Xan$Xav$Xa!`$Xa!a$Xa!b$Xa!c$Xa!d$Xa!e$Xa!f$Xa!g$Xa!h$Xa!i$Xa!j$Xa!k$Xa!l$Xa!m$Xa!n$Xa!o$Xa!p$Xa!q$Xa!r$Xa!s$Xa!t$Xa!u$Xa!v$Xa#O$Xa#V$Xa~OP(ZOR(ZO~P,'`OQ5tOS$XaT$XaU$XaV$XaW$XaX$XaY$Xac$Xag$Xah$Xal$Xam$Xan$Xav$Xa!`$Xa!a$Xa!b$Xa!c$Xa!d$Xa!e$Xa!f$Xa!g$Xa!h$Xa!i$Xa!j$Xa!k$Xa!l$Xa!m$Xa!n$Xa!o$Xa!p$Xa!q$Xa!r$Xa!s$Xa!t$Xa!u$Xa!v$Xa$U$Xa~OP([OR([O~P,*YOQ5uOW$XaX$Xac$Xag$Xah$Xal$Xam$Xan$Xav$Xa!`$Xa!a$Xa!b$Xa!c$Xa!d$Xa!e$Xa!f$Xa!g$Xa!h$Xa!i$Xa!j$Xa!k$Xa!l$Xa!m$Xa!n$Xa!o$Xa!p$Xa!q$Xa!r$Xa!s$Xa!t$Xa!u$Xa!v$Xa#O$Xa$U$Xa~OP(]OR(]O~P,-POP(^OQ5vOR(^O~P+LlOQ5xOS$XaT$XaU$XaV$XaW$XaX$XaY$Xac$Xag$Xah$Xal$Xam$Xan$Xav$Xa!`$Xa!a$Xa!b$Xa!c$Xa!d$Xa!e$Xa!f$Xa!g$Xa!h$Xa!i$Xa!j$Xa!k$Xa!l$Xa!m$Xa!n$Xa!o$Xa!p$Xa!q$Xa!r$Xa!s$Xa!t$Xa!u$Xa!v$Xa#O$Xa$U$Xa~OP(_OR(_O~P,/wOQ5yO[$Xag$Xao$Xap$Xaq$Xar$Xas$Xat$Xau$Xaw$Xax$Xay$Xaz$Xa{$Xa|$Xa}$Xa!O$Xa!P$Xa!Q$Xa!R$Xa!S$Xa!T$Xa!U$Xa!V$Xa!W$Xa!X$Xa!Y$Xa!Z$Xa![$Xa!]$Xa!^$Xa!_$Xa#W$Xa~OP(`OR(`O~P,2qOP5oOQ!yOR5oOg$Xa!}$Xa#V$Xa$U$Xa~OP(aOR(aO~P,$fOP(bOR(bO~P,'`OP(cOR(cO~P,*YOP(dOR(dO~P,-POP(fOQ5vOR(fO~P+LlOP(gOR(gO~P,/wOP(eOR(eO~P,2qOS#QiS#^iT#QiT#^iU#QiU#^iV#QiV#^iW#QiX#Qi[#Qi[#^ib#Qib#^ic#Qif#Qif#^ih#Qil#Qim#Qin#Qiv#Qi!`#Qi!a#Qi!b#Qi!c#Qi!d#Qi!e#Qi!f#Qi!g#Qi!h#Qi!i#Qi!j#Qi!k#Qi!l#Qi!m#Qi!n#Qi!o#Qi!p#Qi!q#Qi!r#Qi!s#Qi!t#Qi!u#Qi!v#Qi#O#Qi#V#Qi#V#^i#W#Qi#W#^i#i#Qi#i#^i#j#Qi#j#^iZ#QiZ#^i~P$(|OP5oOQ!yOR5oOg#Ri!}#Ri#V#Ri$U#Ri~O[#Rib#Rif#Rig#Ril#Riv#Ri#O#Ri#W#Ri#i#Ri#j#RiS#RiT#RiU#RiV#RiW#RiX#Ric#Rih#Rim#Rin#Ri!`#Ri!a#Ri!b#Ri!c#Ri!d#Ri!e#Ri!f#Ri!g#Ri!h#Ri!i#Ri!j#Ri!k#Ri!l#Ri!m#Ri!n#Ri!o#Ri!p#Ri!q#Ri!r#Ri!s#Ri!t#Ri!u#Ri!v#Ri#V#Ri~OP(XOQ5qOR(XO_#Ri`#Ria#Rii#Rij#Rik#Rio#Rip#Riq#Rir#Ris#Rit#Riu#Riw#Rix#Riy#Riz#Ri{#Ri|#Ri}#Ri!O#Ri!P#Ri!Q#Ri!R#Ri!S#Ri!T#Ri!U#Ri!V#Ri!W#Ri!X#Ri!Y#Ri!Z#Ri![#Ri!]#Ri!^#Ri!_#Ri$U#RiY#Rie#Ri!}#RiZ#Ri~P,;hOP(YOR(YOS#RiT#RiU#RiV#RiW#RiX#RiZ#Ric#Rif#Rig#Rih#Ril#Rim#Rin#Riv#Ri!`#Ri!a#Ri!b#Ri!c#Ri!d#Ri!e#Ri!f#Ri!g#Ri!h#Ri!i#Ri!j#Ri!k#Ri!l#Ri!m#Ri!n#Ri!o#Ri!p#Ri!q#Ri!r#Ri!s#Ri!t#Ri!u#Ri!v#Ri#O#Ri~OQ5rO~P,AbOP(ZOR(ZOS#RiT#RiU#RiV#RiW#RiX#Ric#Rif#Rig#Rih#Ril#Rim#Rin#Riv#Ri!`#Ri!a#Ri!b#Ri!c#Ri!d#Ri!e#Ri!f#Ri!g#Ri!h#Ri!i#Ri!j#Ri!k#Ri!l#Ri!m#Ri!n#Ri!o#Ri!p#Ri!q#Ri!r#Ri!s#Ri!t#Ri!u#Ri!v#Ri#O#Ri#V#Ri~OQ5sO~P,D[OP([OR([OS#RiT#RiU#RiV#RiW#RiX#RiY#Ric#Rig#Rih#Ril#Rim#Rin#Riv#Ri!`#Ri!a#Ri!b#Ri!c#Ri!d#Ri!e#Ri!f#Ri!g#Ri!h#Ri!i#Ri!j#Ri!k#Ri!l#Ri!m#Ri!n#Ri!o#Ri!p#Ri!q#Ri!r#Ri!s#Ri!t#Ri!u#Ri!v#Ri$U#Ri~OQ5tO~P,GUOP(]OR(]OW#RiX#Ric#Rig#Rih#Ril#Rim#Rin#Riv#Ri!`#Ri!a#Ri!b#Ri!c#Ri!d#Ri!e#Ri!f#Ri!g#Ri!h#Ri!i#Ri!j#Ri!k#Ri!l#Ri!m#Ri!n#Ri!o#Ri!p#Ri!q#Ri!r#Ri!s#Ri!t#Ri!u#Ri!v#Ri#O#Ri$U#Ri~OQ5uO~P,I{OP(^OQ5vOR(^O~P,;hOP(_OR(_OS#RiT#RiU#RiV#RiW#RiX#RiY#Ric#Rig#Rih#Ril#Rim#Rin#Riv#Ri!`#Ri!a#Ri!b#Ri!c#Ri!d#Ri!e#Ri!f#Ri!g#Ri!h#Ri!i#Ri!j#Ri!k#Ri!l#Ri!m#Ri!n#Ri!o#Ri!p#Ri!q#Ri!r#Ri!s#Ri!t#Ri!u#Ri!v#Ri#O#Ri$U#Ri~OQ5xO~P,LsOP(`OR(`O[#Rig#Rio#Rip#Riq#Rir#Ris#Rit#Riu#Riw#Rix#Riy#Riz#Ri{#Ri|#Ri}#Ri!O#Ri!P#Ri!Q#Ri!R#Ri!S#Ri!T#Ri!U#Ri!V#Ri!W#Ri!X#Ri!Y#Ri!Z#Ri![#Ri!]#Ri!^#Ri!_#Ri#W#Ri~OQ5yO~P- mOP(aOR(aOS#RiT#RiU#RiV#RiW#RiX#RiZ#Ric#Rif#Rig#Rih#Ril#Rim#Rin#Riv#Ri!`#Ri!a#Ri!b#Ri!c#Ri!d#Ri!e#Ri!f#Ri!g#Ri!h#Ri!i#Ri!j#Ri!k#Ri!l#Ri!m#Ri!n#Ri!o#Ri!p#Ri!q#Ri!r#Ri!s#Ri!t#Ri!u#Ri!v#Ri#O#Ri~OQ5rO~P-$TOP(bOR(bOS#RiT#RiU#RiV#RiW#RiX#Ric#Rif#Rig#Rih#Ril#Rim#Rin#Riv#Ri!`#Ri!a#Ri!b#Ri!c#Ri!d#Ri!e#Ri!f#Ri!g#Ri!h#Ri!i#Ri!j#Ri!k#Ri!l#Ri!m#Ri!n#Ri!o#Ri!p#Ri!q#Ri!r#Ri!s#Ri!t#Ri!u#Ri!v#Ri#O#Ri#V#Ri~OQ5sO~P-&}OP(cOR(cOS#RiT#RiU#RiV#RiW#RiX#RiY#Ric#Rig#Rih#Ril#Rim#Rin#Riv#Ri!`#Ri!a#Ri!b#Ri!c#Ri!d#Ri!e#Ri!f#Ri!g#Ri!h#Ri!i#Ri!j#Ri!k#Ri!l#Ri!m#Ri!n#Ri!o#Ri!p#Ri!q#Ri!r#Ri!s#Ri!t#Ri!u#Ri!v#Ri$U#Ri~OQ5tO~P-)wOP(dOR(dOW#RiX#Ric#Rig#Rih#Ril#Rim#Rin#Riv#Ri!`#Ri!a#Ri!b#Ri!c#Ri!d#Ri!e#Ri!f#Ri!g#Ri!h#Ri!i#Ri!j#Ri!k#Ri!l#Ri!m#Ri!n#Ri!o#Ri!p#Ri!q#Ri!r#Ri!s#Ri!t#Ri!u#Ri!v#Ri#O#Ri$U#Ri~OQ5uO~P-,nOP(fOQ5vOR(fO~P,;hOP(gOR(gOS#RiT#RiU#RiV#RiW#RiX#RiY#Ric#Rig#Rih#Ril#Rim#Rin#Riv#Ri!`#Ri!a#Ri!b#Ri!c#Ri!d#Ri!e#Ri!f#Ri!g#Ri!h#Ri!i#Ri!j#Ri!k#Ri!l#Ri!m#Ri!n#Ri!o#Ri!p#Ri!q#Ri!r#Ri!s#Ri!t#Ri!u#Ri!v#Ri#O#Ri$U#Ri~OQ5xO~P-/fOP(eOR(eO[#Rig#Rio#Rip#Riq#Rir#Ris#Rit#Riu#Riw#Rix#Riy#Riz#Ri{#Ri|#Ri}#Ri!O#Ri!P#Ri!Q#Ri!R#Ri!S#Ri!T#Ri!U#Ri!V#Ri!W#Ri!X#Ri!Y#Ri!Z#Ri![#Ri!]#Ri!^#Ri!_#Ri#W#Ri~OQ5yO~P-2`O_lO`lOalObkOflOi5POj5QOk4cOl!}OvlO#O>_O#ikO#jkOP#RiQ#RiR#Ri~P- sO[lObkO#WVO#ikO#jkOP#RiQ#RiR#RiS#RiT#RiU#RiV#RiW#RiX#Ric#Rif#Rig#Rih#Ril#Rim#Rin#Riv#Ri!`#Ri!a#Ri!b#Ri!c#Ri!d#Ri!e#Ri!f#Ri!g#Ri!h#Ri!i#Ri!j#Ri!k#Ri!l#Ri!m#Ri!n#Ri!o#Ri!p#Ri!q#Ri!r#Ri!s#Ri!t#Ri!u#Ri!v#Ri#O#Ri#V#RiZ#Ri~P')aO[lObkOflO#O>_O#WVO#ikO#jkOP#RiQ#RiR#RiS#RiT#RiU#RiV#RiW#RiX#RiY#Ric#Rig#Rih#Ril#Rim#Rin#Riv#Ri!`#Ri!a#Ri!b#Ri!c#Ri!d#Ri!e#Ri!f#Ri!g#Ri!h#Ri!i#Ri!j#Ri!k#Ri!l#Ri!m#Ri!n#Ri!o#Ri!p#Ri!q#Ri!r#Ri!s#Ri!t#Ri!u#Ri!v#Ri$U#Ri~P')aO[lObkOflO#WVO#ikO#jkOP#RiQ#RiR#RiS#RiT#RiU#RiV#RiW#RiX#RiY#Ric#Rig#Rih#Ril#Rim#Rin#Riv#Ri!`#Ri!a#Ri!b#Ri!c#Ri!d#Ri!e#Ri!f#Ri!g#Ri!h#Ri!i#Ri!j#Ri!k#Ri!l#Ri!m#Ri!n#Ri!o#Ri!p#Ri!q#Ri!r#Ri!s#Ri!t#Ri!u#Ri!v#Ri#O#Ri$U#Ri~P')aO_lO`lOalOi5POj5QOk4cOo'qOpWOq'qOr3tOsWOt'qOuWOwWOx'qOy3tOz=OO{AvO|EWO}GgO!OWO!P'wO!Q4bO!R=qO!SBiO!TEyO!UHYO!V4bO!W'wO!XWO!Y'qO!Z3tO![=OO!]AvO!^EWO!_GgOP#RiQ#RiR#Ri~P,;hO_lO`lOalObkOflOi5POj5QOk4cO#O>_O#ikO#jkOP#UXQ#UXR#UXg#UX~Ol!}OvlO[#UXo#UXp#UXq#UXr#UXs#UXt#UXu#UXw#UXx#UXy#UXz#UX{#UX|#UX}#UX!O#UX!P#UX!Q#UX!R#UX!S#UX!T#UX!U#UX!V#UX!W#UX!X#UX!Y#UX!Z#UX![#UX!]#UX!^#UX!_#UX#W#UX~P-BZO[lObkO#WVO#ikO#jkOP#UXQ#UXR#UXS#UXT#UXU#UXV#UXW#UXX#UXc#UXf#UXg#UXh#UXl#UXm#UXn#UXv#UX!`#UX!a#UX!b#UX!c#UX!d#UX!e#UX!f#UX!g#UX!h#UX!i#UX!j#UX!k#UX!l#UX!m#UX!n#UX!o#UX!p#UX!q#UX!r#UX!s#UX!t#UX!u#UX!v#UX#O#UX#V#UXZ#UX~P')aOi5POj5QOk4cOo'qOq'qOr3tOt'qOx'qOy3tOz=OO{AvO|EWO}GgO!OWO!P'wO!Q4bO!R=qO!SBiO!TEyO!UHYO!V4bO!W'wO!Y'qO!Z3tO![=OO!]AvO!^EWO!_GgOl#UXv#UX~P$CaO[lObkOflO#WVO#ikO#jkOP#UXQ#UXR#UXS#UXT#UXU#UXV#UXW#UXX#UXY#UXc#UXg#UXh#UXl#UXm#UXn#UXv#UX!`#UX!a#UX!b#UX!c#UX!d#UX!e#UX!f#UX!g#UX!h#UX!i#UX!j#UX!k#UX!l#UX!m#UX!n#UX!o#UX!p#UX!q#UX!r#UX!s#UX!t#UX!u#UX!v#UX#O#UX$U#UX~P')aOP#UXQ#UXR#UXS#UXT#UXU#UXV#UXW#UXX#UX[#UXb#UXc#UXf#UXg#UXh#UXl#UXm#UXn#UXv#UX!`#UX!a#UX!b#UX!c#UX!d#UX!e#UX!f#UX!g#UX!h#UX!i#UX!j#UX!k#UX!l#UX!m#UX!n#UX!o#UX!p#UX!q#UX!r#UX!s#UX!t#UX!u#UX!v#UX#O#UX#V#UX#W#UX#i#UX#j#UX~P')aOP5oOQ!yOR5oOg6QO!}$[i~OS$[iT$[iU$[iV$[iW$[iX$[ic$[if$[ih$[il$[im$[in$[iv$[i!`$[i!a$[i!b$[i!c$[i!d$[i!e$[i!f$[i!g$[i!h$[i!i$[i!j$[i!k$[i!l$[i!m$[i!n$[i!o$[i!p$[i!q$[i!r$[i!s$[i!t$[i!u$[i!v$[i#O$[i~OP(aOQ5wOR(aOg)SOZ$[i~P.#jOP(bOQ5zOR(bOg:oO#V$[i~P.#jOP(cOQ5{OR(cOg)VO~P$ItOW$[iX$[ic$[ih$[il$[im$[in$[iv$[i!`$[i!a$[i!b$[i!c$[i!d$[i!e$[i!f$[i!g$[i!h$[i!i$[i!j$[i!k$[i!l$[i!m$[i!n$[i!o$[i!p$[i!q$[i!r$[i!s$[i!t$[i!u$[i!v$[i#O$[i~OP(dOQ5|OR(dOg:pO$U$[i~P.'XOP(fOQ6POR(fOg)XO[$[ib$[i#V$[i#W$[i#i$[i#j$[i~P.#jOP5oOQ!yOR5oOg6QO!}!zi~OS!ziT!ziU!ziV!ziW!ziX!ziZ!zic!zif!zih!zil!zim!zin!ziv!zi!`!zi!a!zi!b!zi!c!zi!d!zi!e!zi!f!zi!g!zi!h!zi!i!zi!j!zi!k!zi!l!zi!m!zi!n!zi!o!zi!p!zi!q!zi!r!zi!s!zi!t!zi!u!zi!v!zi#O!zi~OP(aOQ5wOR(aOg)SO~P.*wOS!ziT!ziU!ziV!ziW!ziX!zic!zif!zih!zil!zim!zin!ziv!zi!`!zi!a!zi!b!zi!c!zi!d!zi!e!zi!f!zi!g!zi!h!zi!i!zi!j!zi!k!zi!l!zi!m!zi!n!zi!o!zi!p!zi!q!zi!r!zi!s!zi!t!zi!u!zi!v!zi#O!zi#V!zi~OP(bOQ5zOR(bOg:oO~P.-qOS!ziT!ziU!ziV!ziW!ziX!ziY!zic!zih!zil!zim!zin!ziv!zi!`!zi!a!zi!b!zi!c!zi!d!zi!e!zi!f!zi!g!zi!h!zi!i!zi!j!zi!k!zi!l!zi!m!zi!n!zi!o!zi!p!zi!q!zi!r!zi!s!zi!t!zi!u!zi!v!zi$U!zi~OP(cOQ5{OR(cOg)VO~P.0kOW!ziX!zic!zih!zil!zim!zin!ziv!zi!`!zi!a!zi!b!zi!c!zi!d!zi!e!zi!f!zi!g!zi!h!zi!i!zi!j!zi!k!zi!l!zi!m!zi!n!zi!o!zi!p!zi!q!zi!r!zi!s!zi!t!zi!u!zi!v!zi#O!zi~OP(dOQ5|OR(dOg:pO$U!zi~P.3bOP(fOQ6POR(fOg)XO[!zib!zi#W!zi#i!zi#j!zi~P.-qO!}!zi~P5bO[lO_lO`lOalObkOi5POj5QOk4cOo'qOpWOq'qOr3tOsWOt'qOuWOwWOx'qOy3tOz=OO{AvO|EWO}GgO!OWO!P'wO!Q4bO!R=qO!SBiO!TEyO!UHYO!V4bO!W'wO!XWO!Y'qO!Z3tO![=OO!]AvO!^EWO!_GgO#WVO#ikO#jkO#V!zi~P.*wO[lO_lO`lOalObkOflOi5POj5QOk4cOo'qOpWOq'qOr3tOsWOt'qOuWOwWOx'qOy3tOz=OO{AvO|EWO}GgO!OWO!P'wO!Q4bO!R=qO!SBiO!TEyO!UHYO!V4bO!W'wO!XWO!Y'qO!Z3tO![=OO!]AvO!^EWO!_GgO#O>_O#WVO#ikO#jkO~P.0kO_lO`lOalOi5POj5QOk4cOo'qOpWOq'qOr3tOsWOt'qOuWOwWOx'qOy3tOz=OO{AvO|EWO}GgO!OWO!P'wO!Q4bO!R=qO!SBiO!TEyO!UHYO!V4bO!W'wO!XWO!Y'qO!Z3tO![=OO!]AvO!^EWO!_GgO[!zib!zi#W!zi#i!zi#j!zi~P.-qOP#lXQ#lXR#lX[#lX_#lX`#lXa#lXb#lXe#lXf#lXg#lXi#lXj#lXk#lXl#lXm#lXn#lXo#lXp#lXq#lXr#lXs#lXt#lXu#lXv#lXw#lXx#lXy#lXz#lX{#lX|#lX}#lX!O#lX!P#lX!Q#lX!R#lX!S#lX!T#lX!U#lX!V#lX!W#lX!X#lX!Y#lX!Z#lX![#lX!]#lX!^#lX!_#lX!`#lX!a#lX!b#lX!c#lX!d#lX!e#lX!f#lX!g#lX!h#lX!i#lX!j#lX!k#lX!l#lX!m#lX!n#lX!p#lX!q#lX!r#lX!s#lX!t#lX!u#lX!v#lX#O#lX#W#lX#i#lX#j#lX~O!}#rX~P.?ZOS#rXT#rXU#rXV#rXW#rXX#rXc#rXf#rXh#rXl#rXm#rXn#rXv#rX!`#rX!a#rX!b#rX!c#rX!d#rX!e#rX!f#rX!g#rX!h#rX!i#rX!j#rX!k#rX!l#rX!m#rX!n#rX!o#rX!p#rX!q#rX!r#rX!s#rX!t#rX!u#rX!v#rX#O#rX#V#rXZ#rX~P.?ZOS#rXT#rXU#rXV#rXW#rXX#rX[#rXb#rXc#rXf#rXh#rXl#rXm#rXn#rXv#rX!`#rX!a#rX!b#rX!c#rX!d#rX!e#rX!f#rX!g#rX!h#rX!i#rX!j#rX!k#rX!l#rX!m#rX!n#rX!o#rX!p#rX!q#rX!r#rX!s#rX!t#rX!u#rX!v#rX#O#rX#V#rX#W#rX#i#rX#j#rX~P.?ZOP!|XQ!|XR!|X[!|X_!|X`!|Xa!|Xb!|Xe!|Xf!|Xg!|Xi!|Xj!|Xk!|Xl!|Xm!|Xn!|Xo!|Xp!|Xq!|Xr!|Xs!|Xt!|Xu!|Xv!|Xw!|Xx!|Xy!|Xz!|X{!|X|!|X}!|X!O!|X!P!|X!Q!|X!R!|X!S!|X!T!|X!U!|X!V!|X!W!|X!X!|X!Y!|X!Z!|X![!|X!]!|X!^!|X!_!|X!`!|X!a!|X!b!|X!c!|X!d!|X!e!|X!f!|X!g!|X!h!|X!i!|X!j!|X!k!|X!l!|X!m!|X!n!|X!p!|X!q!|X!r!|X!s!|X!t!|X!u!|X!v!|X#O!|X#W!|X#i!|X#j!|X~O!}#rX~P.ItOS#rXT#rXU#rXV#rXW#rXX#rXc#rXf#rXh#rXl#rXm#rXn#rXv#rX!`#rX!a#rX!b#rX!c#rX!d#rX!e#rX!f#rX!g#rX!h#rX!i#rX!j#rX!k#rX!l#rX!m#rX!n#rX!o#rX!p#rX!q#rX!r#rX!s#rX!t#rX!u#rX!v#rX#O#rX#V#rXZ#rX~P.ItOS#rXT#rXU#rXV#rXW#rXX#rX[#rXb#rXc#rXf#rXh#rXl#rXm#rXn#rXv#rX!`#rX!a#rX!b#rX!c#rX!d#rX!e#rX!f#rX!g#rX!h#rX!i#rX!j#rX!k#rX!l#rX!m#rX!n#rX!o#rX!p#rX!q#rX!r#rX!s#rX!t#rX!u#rX!v#rX#O#rX#V#rX#W#rX#i#rX#j#rX~P.ItO[$Yib$Yif$Yig$Yil$Yiv$Yi#O$Yi#W$Yi#i$Yi#j$YiS$YiT$YiU$YiV$YiW$YiX$Yic$Yih$Yim$Yin$Yi!`$Yi!a$Yi!b$Yi!c$Yi!d$Yi!e$Yi!f$Yi!g$Yi!h$Yi!i$Yi!j$Yi!k$Yi!l$Yi!m$Yi!n$Yi!o$Yi!p$Yi!q$Yi!r$Yi!s$Yi!t$Yi!u$Yi!v$Yi#V$Yi~OP(XOQ5qOR(XO_$Yi`$Yia$Yii$Yij$Yik$Yio$Yip$Yiq$Yir$Yis$Yit$Yiu$Yiw$Yix$Yiy$Yiz$Yi{$Yi|$Yi}$Yi!O$Yi!P$Yi!Q$Yi!R$Yi!S$Yi!T$Yi!U$Yi!V$Yi!W$Yi!X$Yi!Y$Yi!Z$Yi![$Yi!]$Yi!^$Yi!_$Yi$U$YiY$Yie$Yi!}$YiZ$Yi~P/&_OP(YOR(YOS$YiT$YiU$YiV$YiW$YiX$YiZ$Yic$Yif$Yig$Yih$Yil$Yim$Yin$Yiv$Yi!`$Yi!a$Yi!b$Yi!c$Yi!d$Yi!e$Yi!f$Yi!g$Yi!h$Yi!i$Yi!j$Yi!k$Yi!l$Yi!m$Yi!n$Yi!o$Yi!p$Yi!q$Yi!r$Yi!s$Yi!t$Yi!u$Yi!v$Yi#O$Yi~OQ5rO~P/,XOP(ZOR(ZOS$YiT$YiU$YiV$YiW$YiX$Yic$Yif$Yig$Yih$Yil$Yim$Yin$Yiv$Yi!`$Yi!a$Yi!b$Yi!c$Yi!d$Yi!e$Yi!f$Yi!g$Yi!h$Yi!i$Yi!j$Yi!k$Yi!l$Yi!m$Yi!n$Yi!o$Yi!p$Yi!q$Yi!r$Yi!s$Yi!t$Yi!u$Yi!v$Yi#O$Yi#V$Yi~OQ5sO~P//ROP([OR([OS$YiT$YiU$YiV$YiW$YiX$YiY$Yic$Yig$Yih$Yil$Yim$Yin$Yiv$Yi!`$Yi!a$Yi!b$Yi!c$Yi!d$Yi!e$Yi!f$Yi!g$Yi!h$Yi!i$Yi!j$Yi!k$Yi!l$Yi!m$Yi!n$Yi!o$Yi!p$Yi!q$Yi!r$Yi!s$Yi!t$Yi!u$Yi!v$Yi$U$Yi~OQ5tO~P/1{OP(]OR(]OW$YiX$Yic$Yig$Yih$Yil$Yim$Yin$Yiv$Yi!`$Yi!a$Yi!b$Yi!c$Yi!d$Yi!e$Yi!f$Yi!g$Yi!h$Yi!i$Yi!j$Yi!k$Yi!l$Yi!m$Yi!n$Yi!o$Yi!p$Yi!q$Yi!r$Yi!s$Yi!t$Yi!u$Yi!v$Yi#O$Yi$U$Yi~OQ5uO~P/4rOP(^OQ5vOR(^O~P/&_OP(_OR(_OS$YiT$YiU$YiV$YiW$YiX$YiY$Yic$Yig$Yih$Yil$Yim$Yin$Yiv$Yi!`$Yi!a$Yi!b$Yi!c$Yi!d$Yi!e$Yi!f$Yi!g$Yi!h$Yi!i$Yi!j$Yi!k$Yi!l$Yi!m$Yi!n$Yi!o$Yi!p$Yi!q$Yi!r$Yi!s$Yi!t$Yi!u$Yi!v$Yi#O$Yi$U$Yi~OQ5xO~P/7jOP(`OR(`O[$Yig$Yio$Yip$Yiq$Yir$Yis$Yit$Yiu$Yiw$Yix$Yiy$Yiz$Yi{$Yi|$Yi}$Yi!O$Yi!P$Yi!Q$Yi!R$Yi!S$Yi!T$Yi!U$Yi!V$Yi!W$Yi!X$Yi!Y$Yi!Z$Yi![$Yi!]$Yi!^$Yi!_$Yi#W$Yi~OQ5yO~P/:dOP5oOQ!yOR5oOg#Rq!}#Rq#V#Rq$U#Rq~O[#Rqb#Rqf#Rqg#Rql#Rqv#Rq#O#Rq#W#Rq#i#Rq#j#RqS#RqT#RqU#RqV#RqW#RqX#Rqc#Rqh#Rqm#Rqn#Rq!`#Rq!a#Rq!b#Rq!c#Rq!d#Rq!e#Rq!f#Rq!g#Rq!h#Rq!i#Rq!j#Rq!k#Rq!l#Rq!m#Rq!n#Rq!o#Rq!p#Rq!q#Rq!r#Rq!s#Rq!t#Rq!u#Rq!v#Rq#V#Rq~OP(XOQ5qOR(XO_#Rq`#Rqa#Rqi#Rqj#Rqk#Rqo#Rqp#Rqq#Rqr#Rqs#Rqt#Rqu#Rqw#Rqx#Rqy#Rqz#Rq{#Rq|#Rq}#Rq!O#Rq!P#Rq!Q#Rq!R#Rq!S#Rq!T#Rq!U#Rq!V#Rq!W#Rq!X#Rq!Y#Rq!Z#Rq![#Rq!]#Rq!^#Rq!_#Rq$U#RqY#Rqe#Rq!}#RqZ#Rq~P/=cOP(YOR(YOS#RqT#RqU#RqV#RqW#RqX#RqZ#Rqc#Rqf#Rqg#Rqh#Rql#Rqm#Rqn#Rqv#Rq!`#Rq!a#Rq!b#Rq!c#Rq!d#Rq!e#Rq!f#Rq!g#Rq!h#Rq!i#Rq!j#Rq!k#Rq!l#Rq!m#Rq!n#Rq!o#Rq!p#Rq!q#Rq!r#Rq!s#Rq!t#Rq!u#Rq!v#Rq#O#Rq~OQ5rO~P/C]OP(ZOR(ZOS#RqT#RqU#RqV#RqW#RqX#Rqc#Rqf#Rqg#Rqh#Rql#Rqm#Rqn#Rqv#Rq!`#Rq!a#Rq!b#Rq!c#Rq!d#Rq!e#Rq!f#Rq!g#Rq!h#Rq!i#Rq!j#Rq!k#Rq!l#Rq!m#Rq!n#Rq!o#Rq!p#Rq!q#Rq!r#Rq!s#Rq!t#Rq!u#Rq!v#Rq#O#Rq#V#Rq~OQ5sO~P/FVOP([OR([OS#RqT#RqU#RqV#RqW#RqX#RqY#Rqc#Rqg#Rqh#Rql#Rqm#Rqn#Rqv#Rq!`#Rq!a#Rq!b#Rq!c#Rq!d#Rq!e#Rq!f#Rq!g#Rq!h#Rq!i#Rq!j#Rq!k#Rq!l#Rq!m#Rq!n#Rq!o#Rq!p#Rq!q#Rq!r#Rq!s#Rq!t#Rq!u#Rq!v#Rq$U#Rq~OQ5tO~P/IPOP(]OR(]OW#RqX#Rqc#Rqg#Rqh#Rql#Rqm#Rqn#Rqv#Rq!`#Rq!a#Rq!b#Rq!c#Rq!d#Rq!e#Rq!f#Rq!g#Rq!h#Rq!i#Rq!j#Rq!k#Rq!l#Rq!m#Rq!n#Rq!o#Rq!p#Rq!q#Rq!r#Rq!s#Rq!t#Rq!u#Rq!v#Rq#O#Rq$U#Rq~OQ5uO~P/KvOP(^OQ5vOR(^O~P/=cOP(_OR(_OS#RqT#RqU#RqV#RqW#RqX#RqY#Rqc#Rqg#Rqh#Rql#Rqm#Rqn#Rqv#Rq!`#Rq!a#Rq!b#Rq!c#Rq!d#Rq!e#Rq!f#Rq!g#Rq!h#Rq!i#Rq!j#Rq!k#Rq!l#Rq!m#Rq!n#Rq!o#Rq!p#Rq!q#Rq!r#Rq!s#Rq!t#Rq!u#Rq!v#Rq#O#Rq$U#Rq~OQ5xO~P/NnOP(`OR(`O[#Rqg#Rqo#Rqp#Rqq#Rqr#Rqs#Rqt#Rqu#Rqw#Rqx#Rqy#Rqz#Rq{#Rq|#Rq}#Rq!O#Rq!P#Rq!Q#Rq!R#Rq!S#Rq!T#Rq!U#Rq!V#Rq!W#Rq!X#Rq!Y#Rq!Z#Rq![#Rq!]#Rq!^#Rq!_#Rq#W#Rq~OQ5yO~P0#hOP(aOR(aOS#RqT#RqU#RqV#RqW#RqX#RqZ#Rqc#Rqf#Rqg#Rqh#Rql#Rqm#Rqn#Rqv#Rq!`#Rq!a#Rq!b#Rq!c#Rq!d#Rq!e#Rq!f#Rq!g#Rq!h#Rq!i#Rq!j#Rq!k#Rq!l#Rq!m#Rq!n#Rq!o#Rq!p#Rq!q#Rq!r#Rq!s#Rq!t#Rq!u#Rq!v#Rq#O#Rq~OQ5rO~P0&OOP(bOR(bOS#RqT#RqU#RqV#RqW#RqX#Rqc#Rqf#Rqg#Rqh#Rql#Rqm#Rqn#Rqv#Rq!`#Rq!a#Rq!b#Rq!c#Rq!d#Rq!e#Rq!f#Rq!g#Rq!h#Rq!i#Rq!j#Rq!k#Rq!l#Rq!m#Rq!n#Rq!o#Rq!p#Rq!q#Rq!r#Rq!s#Rq!t#Rq!u#Rq!v#Rq#O#Rq#V#Rq~OQ5sO~P0(xOP(cOR(cOS#RqT#RqU#RqV#RqW#RqX#RqY#Rqc#Rqg#Rqh#Rql#Rqm#Rqn#Rqv#Rq!`#Rq!a#Rq!b#Rq!c#Rq!d#Rq!e#Rq!f#Rq!g#Rq!h#Rq!i#Rq!j#Rq!k#Rq!l#Rq!m#Rq!n#Rq!o#Rq!p#Rq!q#Rq!r#Rq!s#Rq!t#Rq!u#Rq!v#Rq$U#Rq~OQ5tO~P0+rOP(dOR(dOW#RqX#Rqc#Rqg#Rqh#Rql#Rqm#Rqn#Rqv#Rq!`#Rq!a#Rq!b#Rq!c#Rq!d#Rq!e#Rq!f#Rq!g#Rq!h#Rq!i#Rq!j#Rq!k#Rq!l#Rq!m#Rq!n#Rq!o#Rq!p#Rq!q#Rq!r#Rq!s#Rq!t#Rq!u#Rq!v#Rq#O#Rq$U#Rq~OQ5uO~P0.iOP(fOQ5vOR(fO~P/=cOP(gOR(gOS#RqT#RqU#RqV#RqW#RqX#RqY#Rqc#Rqg#Rqh#Rql#Rqm#Rqn#Rqv#Rq!`#Rq!a#Rq!b#Rq!c#Rq!d#Rq!e#Rq!f#Rq!g#Rq!h#Rq!i#Rq!j#Rq!k#Rq!l#Rq!m#Rq!n#Rq!o#Rq!p#Rq!q#Rq!r#Rq!s#Rq!t#Rq!u#Rq!v#Rq#O#Rq$U#Rq~OQ5xO~P01aOP(eOR(eO[#Rqg#Rqo#Rqp#Rqq#Rqr#Rqs#Rqt#Rqu#Rqw#Rqx#Rqy#Rqz#Rq{#Rq|#Rq}#Rq!O#Rq!P#Rq!Q#Rq!R#Rq!S#Rq!T#Rq!U#Rq!V#Rq!W#Rq!X#Rq!Y#Rq!Z#Rq![#Rq!]#Rq!^#Rq!_#Rq#W#Rq~OQ5yO~P04ZO_lO`lOalObkOflOi5POj5QOk4cOl!}OvlO#O>_O#ikO#jkOP#RqQ#RqR#Rq~P0#nO[lObkO#WVO#ikO#jkOP#RqQ#RqR#RqS#RqT#RqU#RqV#RqW#RqX#Rqc#Rqf#Rqg#Rqh#Rql#Rqm#Rqn#Rqv#Rq!`#Rq!a#Rq!b#Rq!c#Rq!d#Rq!e#Rq!f#Rq!g#Rq!h#Rq!i#Rq!j#Rq!k#Rq!l#Rq!m#Rq!n#Rq!o#Rq!p#Rq!q#Rq!r#Rq!s#Rq!t#Rq!u#Rq!v#Rq#O#Rq#V#RqZ#Rq~P')aO[lObkOflO#O>_O#WVO#ikO#jkOP#RqQ#RqR#RqS#RqT#RqU#RqV#RqW#RqX#RqY#Rqc#Rqg#Rqh#Rql#Rqm#Rqn#Rqv#Rq!`#Rq!a#Rq!b#Rq!c#Rq!d#Rq!e#Rq!f#Rq!g#Rq!h#Rq!i#Rq!j#Rq!k#Rq!l#Rq!m#Rq!n#Rq!o#Rq!p#Rq!q#Rq!r#Rq!s#Rq!t#Rq!u#Rq!v#Rq$U#Rq~P')aO[lObkOflO#WVO#ikO#jkOP#RqQ#RqR#RqS#RqT#RqU#RqV#RqW#RqX#RqY#Rqc#Rqg#Rqh#Rql#Rqm#Rqn#Rqv#Rq!`#Rq!a#Rq!b#Rq!c#Rq!d#Rq!e#Rq!f#Rq!g#Rq!h#Rq!i#Rq!j#Rq!k#Rq!l#Rq!m#Rq!n#Rq!o#Rq!p#Rq!q#Rq!r#Rq!s#Rq!t#Rq!u#Rq!v#Rq#O#Rq$U#Rq~P')aO_lO`lOalOi5POj5QOk4cOo'qOpWOq'qOr3tOsWOt'qOuWOwWOx'qOy3tOz=OO{AvO|EWO}GgO!OWO!P'wO!Q4bO!R=qO!SBiO!TEyO!UHYO!V4bO!W'wO!XWO!Y'qO!Z3tO![=OO!]AvO!^EWO!_GgOP#RqQ#RqR#Rq~P/=cOP5oOQ!yOR5oOg6QO!}!zq~OS!zqT!zqU!zqV!zqW!zqX!zqZ!zqc!zqf!zqh!zql!zqm!zqn!zqv!zq!`!zq!a!zq!b!zq!c!zq!d!zq!e!zq!f!zq!g!zq!h!zq!i!zq!j!zq!k!zq!l!zq!m!zq!n!zq!o!zq!p!zq!q!zq!r!zq!s!zq!t!zq!u!zq!v!zq#O!zq~OP(aOQ5wOR(aOg)SO~P0DgOS!zqT!zqU!zqV!zqW!zqX!zqc!zqf!zqh!zql!zqm!zqn!zqv!zq!`!zq!a!zq!b!zq!c!zq!d!zq!e!zq!f!zq!g!zq!h!zq!i!zq!j!zq!k!zq!l!zq!m!zq!n!zq!o!zq!p!zq!q!zq!r!zq!s!zq!t!zq!u!zq!v!zq#O!zq#V!zq~OP(bOQ5zOR(bOg:oO~P0GaOS!zqT!zqU!zqV!zqW!zqX!zqY!zqc!zqh!zql!zqm!zqn!zqv!zq!`!zq!a!zq!b!zq!c!zq!d!zq!e!zq!f!zq!g!zq!h!zq!i!zq!j!zq!k!zq!l!zq!m!zq!n!zq!o!zq!p!zq!q!zq!r!zq!s!zq!t!zq!u!zq!v!zq$U!zq~OP(cOQ5{OR(cOg)VO~P0JZOW!zqX!zqc!zqh!zql!zqm!zqn!zqv!zq!`!zq!a!zq!b!zq!c!zq!d!zq!e!zq!f!zq!g!zq!h!zq!i!zq!j!zq!k!zq!l!zq!m!zq!n!zq!o!zq!p!zq!q!zq!r!zq!s!zq!t!zq!u!zq!v!zq#O!zq~OP(dOQ5|OR(dOg:pO$U!zq~P0MQOP(fOQ6POR(fOg)XO[!zqb!zq#W!zq#i!zq#j!zq~P0GaO!}!zq~P5bO[lO_lO`lOalObkOi5POj5QOk4cOo'qOpWOq'qOr3tOsWOt'qOuWOwWOx'qOy3tOz=OO{AvO|EWO}GgO!OWO!P'wO!Q4bO!R=qO!SBiO!TEyO!UHYO!V4bO!W'wO!XWO!Y'qO!Z3tO![=OO!]AvO!^EWO!_GgO#WVO#ikO#jkO#V!zq~P0DgO[lO_lO`lOalObkOflOi5POj5QOk4cOo'qOpWOq'qOr3tOsWOt'qOuWOwWOx'qOy3tOz=OO{AvO|EWO}GgO!OWO!P'wO!Q4bO!R=qO!SBiO!TEyO!UHYO!V4bO!W'wO!XWO!Y'qO!Z3tO![=OO!]AvO!^EWO!_GgO#O>_O#WVO#ikO#jkO~P0JZO_lO`lOalOi5POj5QOk4cOo'qOpWOq'qOr3tOsWOt'qOuWOwWOx'qOy3tOz=OO{AvO|EWO}GgO!OWO!P'wO!Q4bO!R=qO!SBiO!TEyO!UHYO!V4bO!W'wO!XWO!Y'qO!Z3tO![=OO!]AvO!^EWO!_GgO[!zqb!zq#W!zq#i!zq#j!zq~P0GaO!}#fa~P!9vOS#faT#faU#faV#faW#faX#fac#faf#fah#fal#fam#fan#fav#fa!`#fa!a#fa!b#fa!c#fa!d#fa!e#fa!f#fa!g#fa!h#fa!i#fa!j#fa!k#fa!l#fa!m#fa!n#fa!o#fa!p#fa!q#fa!r#fa!s#fa!t#fa!u#fa!v#fa#O#fa#V#faZ#fa~P!9vOS#faT#faU#faV#faW#faX#faY#fac#fah#fal#fam#fan#fav#fa!`#fa!a#fa!b#fa!c#fa!d#fa!e#fa!f#fa!g#fa!h#fa!i#fa!j#fa!k#fa!l#fa!m#fa!n#fa!o#fa!p#fa!q#fa!r#fa!s#fa!t#fa!u#fa!v#fa$U#fa~P!9vOS#faT#faU#faV#faW#faX#fa[#fab#fac#faf#fah#fal#fam#fan#fav#fa!`#fa!a#fa!b#fa!c#fa!d#fa!e#fa!f#fa!g#fa!h#fa!i#fa!j#fa!k#fa!l#fa!m#fa!n#fa!o#fa!p#fa!q#fa!r#fa!s#fa!t#fa!u#fa!v#fa#O#fa#V#fa#W#fa#i#fa#j#fa~P!9vOP5oOQ!yOR5oOg#Ry!}#Ry#V#Ry$U#Ry~O[#Ryb#Ryf#Ryg#Ryl#Ryv#Ry#O#Ry#W#Ry#i#Ry#j#RyS#RyT#RyU#RyV#RyW#RyX#Ryc#Ryh#Rym#Ryn#Ry!`#Ry!a#Ry!b#Ry!c#Ry!d#Ry!e#Ry!f#Ry!g#Ry!h#Ry!i#Ry!j#Ry!k#Ry!l#Ry!m#Ry!n#Ry!o#Ry!p#Ry!q#Ry!r#Ry!s#Ry!t#Ry!u#Ry!v#Ry#V#Ry~OP(XOQ5qOR(XO_#Ry`#Rya#Ryi#Ryj#Ryk#Ryo#Ryp#Ryq#Ryr#Rys#Ryt#Ryu#Ryw#Ryx#Ryy#Ryz#Ry{#Ry|#Ry}#Ry!O#Ry!P#Ry!Q#Ry!R#Ry!S#Ry!T#Ry!U#Ry!V#Ry!W#Ry!X#Ry!Y#Ry!Z#Ry![#Ry!]#Ry!^#Ry!_#Ry$U#RyY#Rye#Ry!}#RyZ#Ry~P13jOP(YOR(YOS#RyT#RyU#RyV#RyW#RyX#RyZ#Ryc#Ryf#Ryg#Ryh#Ryl#Rym#Ryn#Ryv#Ry!`#Ry!a#Ry!b#Ry!c#Ry!d#Ry!e#Ry!f#Ry!g#Ry!h#Ry!i#Ry!j#Ry!k#Ry!l#Ry!m#Ry!n#Ry!o#Ry!p#Ry!q#Ry!r#Ry!s#Ry!t#Ry!u#Ry!v#Ry#O#Ry~OQ5rO~P19dOP(ZOR(ZOS#RyT#RyU#RyV#RyW#RyX#Ryc#Ryf#Ryg#Ryh#Ryl#Rym#Ryn#Ryv#Ry!`#Ry!a#Ry!b#Ry!c#Ry!d#Ry!e#Ry!f#Ry!g#Ry!h#Ry!i#Ry!j#Ry!k#Ry!l#Ry!m#Ry!n#Ry!o#Ry!p#Ry!q#Ry!r#Ry!s#Ry!t#Ry!u#Ry!v#Ry#O#Ry#V#Ry~OQ5sO~P1<^OP([OR([OS#RyT#RyU#RyV#RyW#RyX#RyY#Ryc#Ryg#Ryh#Ryl#Rym#Ryn#Ryv#Ry!`#Ry!a#Ry!b#Ry!c#Ry!d#Ry!e#Ry!f#Ry!g#Ry!h#Ry!i#Ry!j#Ry!k#Ry!l#Ry!m#Ry!n#Ry!o#Ry!p#Ry!q#Ry!r#Ry!s#Ry!t#Ry!u#Ry!v#Ry$U#Ry~OQ5tO~P1?WOP(]OR(]OW#RyX#Ryc#Ryg#Ryh#Ryl#Rym#Ryn#Ryv#Ry!`#Ry!a#Ry!b#Ry!c#Ry!d#Ry!e#Ry!f#Ry!g#Ry!h#Ry!i#Ry!j#Ry!k#Ry!l#Ry!m#Ry!n#Ry!o#Ry!p#Ry!q#Ry!r#Ry!s#Ry!t#Ry!u#Ry!v#Ry#O#Ry$U#Ry~OQ5uO~P1A}OP(^OQ5vOR(^O~P13jOP(_OR(_OS#RyT#RyU#RyV#RyW#RyX#RyY#Ryc#Ryg#Ryh#Ryl#Rym#Ryn#Ryv#Ry!`#Ry!a#Ry!b#Ry!c#Ry!d#Ry!e#Ry!f#Ry!g#Ry!h#Ry!i#Ry!j#Ry!k#Ry!l#Ry!m#Ry!n#Ry!o#Ry!p#Ry!q#Ry!r#Ry!s#Ry!t#Ry!u#Ry!v#Ry#O#Ry$U#Ry~OQ5xO~P1DuOP(`OR(`O[#Ryg#Ryo#Ryp#Ryq#Ryr#Rys#Ryt#Ryu#Ryw#Ryx#Ryy#Ryz#Ry{#Ry|#Ry}#Ry!O#Ry!P#Ry!Q#Ry!R#Ry!S#Ry!T#Ry!U#Ry!V#Ry!W#Ry!X#Ry!Y#Ry!Z#Ry![#Ry!]#Ry!^#Ry!_#Ry#W#Ry~OQ5yO~P1GoOP(aOR(aOS#RyT#RyU#RyV#RyW#RyX#RyZ#Ryc#Ryf#Ryg#Ryh#Ryl#Rym#Ryn#Ryv#Ry!`#Ry!a#Ry!b#Ry!c#Ry!d#Ry!e#Ry!f#Ry!g#Ry!h#Ry!i#Ry!j#Ry!k#Ry!l#Ry!m#Ry!n#Ry!o#Ry!p#Ry!q#Ry!r#Ry!s#Ry!t#Ry!u#Ry!v#Ry#O#Ry~OQ5rO~P1JVOP(bOR(bOS#RyT#RyU#RyV#RyW#RyX#Ryc#Ryf#Ryg#Ryh#Ryl#Rym#Ryn#Ryv#Ry!`#Ry!a#Ry!b#Ry!c#Ry!d#Ry!e#Ry!f#Ry!g#Ry!h#Ry!i#Ry!j#Ry!k#Ry!l#Ry!m#Ry!n#Ry!o#Ry!p#Ry!q#Ry!r#Ry!s#Ry!t#Ry!u#Ry!v#Ry#O#Ry#V#Ry~OQ5sO~P1MPOP(cOR(cOS#RyT#RyU#RyV#RyW#RyX#RyY#Ryc#Ryg#Ryh#Ryl#Rym#Ryn#Ryv#Ry!`#Ry!a#Ry!b#Ry!c#Ry!d#Ry!e#Ry!f#Ry!g#Ry!h#Ry!i#Ry!j#Ry!k#Ry!l#Ry!m#Ry!n#Ry!o#Ry!p#Ry!q#Ry!r#Ry!s#Ry!t#Ry!u#Ry!v#Ry$U#Ry~OQ5tO~P2 yOP(dOR(dOW#RyX#Ryc#Ryg#Ryh#Ryl#Rym#Ryn#Ryv#Ry!`#Ry!a#Ry!b#Ry!c#Ry!d#Ry!e#Ry!f#Ry!g#Ry!h#Ry!i#Ry!j#Ry!k#Ry!l#Ry!m#Ry!n#Ry!o#Ry!p#Ry!q#Ry!r#Ry!s#Ry!t#Ry!u#Ry!v#Ry#O#Ry$U#Ry~OQ5uO~P2$pOP(fOQ5vOR(fO~P13jOP(gOR(gOS#RyT#RyU#RyV#RyW#RyX#RyY#Ryc#Ryg#Ryh#Ryl#Rym#Ryn#Ryv#Ry!`#Ry!a#Ry!b#Ry!c#Ry!d#Ry!e#Ry!f#Ry!g#Ry!h#Ry!i#Ry!j#Ry!k#Ry!l#Ry!m#Ry!n#Ry!o#Ry!p#Ry!q#Ry!r#Ry!s#Ry!t#Ry!u#Ry!v#Ry#O#Ry$U#Ry~OQ5xO~P2'hOP(eOR(eO[#Ryg#Ryo#Ryp#Ryq#Ryr#Rys#Ryt#Ryu#Ryw#Ryx#Ryy#Ryz#Ry{#Ry|#Ry}#Ry!O#Ry!P#Ry!Q#Ry!R#Ry!S#Ry!T#Ry!U#Ry!V#Ry!W#Ry!X#Ry!Y#Ry!Z#Ry![#Ry!]#Ry!^#Ry!_#Ry#W#Ry~OQ5yO~P2*bO_lO`lOalObkOflOi5POj5QOk4cOl!}OvlO#O>_O#ikO#jkOP#RyQ#RyR#Ry~P1GuO[lObkO#WVO#ikO#jkOP#RyQ#RyR#RyS#RyT#RyU#RyV#RyW#RyX#Ryc#Ryf#Ryg#Ryh#Ryl#Rym#Ryn#Ryv#Ry!`#Ry!a#Ry!b#Ry!c#Ry!d#Ry!e#Ry!f#Ry!g#Ry!h#Ry!i#Ry!j#Ry!k#Ry!l#Ry!m#Ry!n#Ry!o#Ry!p#Ry!q#Ry!r#Ry!s#Ry!t#Ry!u#Ry!v#Ry#O#Ry#V#RyZ#Ry~P')aO[lObkOflO#O>_O#WVO#ikO#jkOP#RyQ#RyR#RyS#RyT#RyU#RyV#RyW#RyX#RyY#Ryc#Ryg#Ryh#Ryl#Rym#Ryn#Ryv#Ry!`#Ry!a#Ry!b#Ry!c#Ry!d#Ry!e#Ry!f#Ry!g#Ry!h#Ry!i#Ry!j#Ry!k#Ry!l#Ry!m#Ry!n#Ry!o#Ry!p#Ry!q#Ry!r#Ry!s#Ry!t#Ry!u#Ry!v#Ry$U#Ry~P')aO[lObkOflO#WVO#ikO#jkOP#RyQ#RyR#RyS#RyT#RyU#RyV#RyW#RyX#RyY#Ryc#Ryg#Ryh#Ryl#Rym#Ryn#Ryv#Ry!`#Ry!a#Ry!b#Ry!c#Ry!d#Ry!e#Ry!f#Ry!g#Ry!h#Ry!i#Ry!j#Ry!k#Ry!l#Ry!m#Ry!n#Ry!o#Ry!p#Ry!q#Ry!r#Ry!s#Ry!t#Ry!u#Ry!v#Ry#O#Ry$U#Ry~P')aO_lO`lOalOi5POj5QOk4cOo'qOpWOq'qOr3tOsWOt'qOuWOwWOx'qOy3tOz=OO{AvO|EWO}GgO!OWO!P'wO!Q4bO!R=qO!SBiO!TEyO!UHYO!V4bO!W'wO!XWO!Y'qO!Z3tO![=OO!]AvO!^EWO!_GgOP#RyQ#RyR#Ry~P13jOP5oOQ!yOR5oOg6QO!}!zy~OS!zyT!zyU!zyV!zyW!zyX!zyZ!zyc!zyf!zyh!zyl!zym!zyn!zyv!zy!`!zy!a!zy!b!zy!c!zy!d!zy!e!zy!f!zy!g!zy!h!zy!i!zy!j!zy!k!zy!l!zy!m!zy!n!zy!o!zy!p!zy!q!zy!r!zy!s!zy!t!zy!u!zy!v!zy#O!zy~OP(aOQ5wOR(aOg)SO~P2:nOS!zyT!zyU!zyV!zyW!zyX!zyc!zyf!zyh!zyl!zym!zyn!zyv!zy!`!zy!a!zy!b!zy!c!zy!d!zy!e!zy!f!zy!g!zy!h!zy!i!zy!j!zy!k!zy!l!zy!m!zy!n!zy!o!zy!p!zy!q!zy!r!zy!s!zy!t!zy!u!zy!v!zy#O!zy#V!zy~OP(bOQ5zOR(bOg:oO~P2=hOS!zyT!zyU!zyV!zyW!zyX!zyY!zyc!zyh!zyl!zym!zyn!zyv!zy!`!zy!a!zy!b!zy!c!zy!d!zy!e!zy!f!zy!g!zy!h!zy!i!zy!j!zy!k!zy!l!zy!m!zy!n!zy!o!zy!p!zy!q!zy!r!zy!s!zy!t!zy!u!zy!v!zy$U!zy~OP(cOQ5{OR(cOg)VO~P2@bOW!zyX!zyc!zyh!zyl!zym!zyn!zyv!zy!`!zy!a!zy!b!zy!c!zy!d!zy!e!zy!f!zy!g!zy!h!zy!i!zy!j!zy!k!zy!l!zy!m!zy!n!zy!o!zy!p!zy!q!zy!r!zy!s!zy!t!zy!u!zy!v!zy#O!zy~OP(dOQ5|OR(dOg:pO$U!zy~P2CXOP(fOQ6POR(fOg)XO[!zyb!zy#W!zy#i!zy#j!zy~P2=hO!}!zy~P5bO[lO_lO`lOalObkOi5POj5QOk4cOo'qOpWOq'qOr3tOsWOt'qOuWOwWOx'qOy3tOz=OO{AvO|EWO}GgO!OWO!P'wO!Q4bO!R=qO!SBiO!TEyO!UHYO!V4bO!W'wO!XWO!Y'qO!Z3tO![=OO!]AvO!^EWO!_GgO#WVO#ikO#jkO#V!zy~P2:nO[lO_lO`lOalObkOflOi5POj5QOk4cOo'qOpWOq'qOr3tOsWOt'qOuWOwWOx'qOy3tOz=OO{AvO|EWO}GgO!OWO!P'wO!Q4bO!R=qO!SBiO!TEyO!UHYO!V4bO!W'wO!XWO!Y'qO!Z3tO![=OO!]AvO!^EWO!_GgO#O>_O#WVO#ikO#jkO~P2@bO_lO`lOalOi5POj5QOk4cOo'qOpWOq'qOr3tOsWOt'qOuWOwWOx'qOy3tOz=OO{AvO|EWO}GgO!OWO!P'wO!Q4bO!R=qO!SBiO!TEyO!UHYO!V4bO!W'wO!XWO!Y'qO!Z3tO![=OO!]AvO!^EWO!_GgO[!zyb!zy#W!zy#i!zy#j!zy~P2=hOP5oOQ!yOR5oOg#R!R!}#R!R#V#R!R$U#R!R~O[#R!Rb#R!Rf#R!Rg#R!Rl#R!Rv#R!R#O#R!R#W#R!R#i#R!R#j#R!RS#R!RT#R!RU#R!RV#R!RW#R!RX#R!Rc#R!Rh#R!Rm#R!Rn#R!R!`#R!R!a#R!R!b#R!R!c#R!R!d#R!R!e#R!R!f#R!R!g#R!R!h#R!R!i#R!R!j#R!R!k#R!R!l#R!R!m#R!R!n#R!R!o#R!R!p#R!R!q#R!R!r#R!R!s#R!R!t#R!R!u#R!R!v#R!R#V#R!R~OP(XOQ5qOR(XO_#R!R`#R!Ra#R!Ri#R!Rj#R!Rk#R!Ro#R!Rp#R!Rq#R!Rr#R!Rs#R!Rt#R!Ru#R!Rw#R!Rx#R!Ry#R!Rz#R!R{#R!R|#R!R}#R!R!O#R!R!P#R!R!Q#R!R!R#R!R!S#R!R!T#R!R!U#R!R!V#R!R!W#R!R!X#R!R!Y#R!R!Z#R!R![#R!R!]#R!R!^#R!R!_#R!R$U#R!RY#R!Re#R!R!}#R!RZ#R!R~P3 iOP(YOR(YOS#R!RT#R!RU#R!RV#R!RW#R!RX#R!RZ#R!Rc#R!Rf#R!Rg#R!Rh#R!Rl#R!Rm#R!Rn#R!Rv#R!R!`#R!R!a#R!R!b#R!R!c#R!R!d#R!R!e#R!R!f#R!R!g#R!R!h#R!R!i#R!R!j#R!R!k#R!R!l#R!R!m#R!R!n#R!R!o#R!R!p#R!R!q#R!R!r#R!R!s#R!R!t#R!R!u#R!R!v#R!R#O#R!R~OQ5rO~P3'cOP(ZOR(ZOS#R!RT#R!RU#R!RV#R!RW#R!RX#R!Rc#R!Rf#R!Rg#R!Rh#R!Rl#R!Rm#R!Rn#R!Rv#R!R!`#R!R!a#R!R!b#R!R!c#R!R!d#R!R!e#R!R!f#R!R!g#R!R!h#R!R!i#R!R!j#R!R!k#R!R!l#R!R!m#R!R!n#R!R!o#R!R!p#R!R!q#R!R!r#R!R!s#R!R!t#R!R!u#R!R!v#R!R#O#R!R#V#R!R~OQ5sO~P3*]OP([OR([OS#R!RT#R!RU#R!RV#R!RW#R!RX#R!RY#R!Rc#R!Rg#R!Rh#R!Rl#R!Rm#R!Rn#R!Rv#R!R!`#R!R!a#R!R!b#R!R!c#R!R!d#R!R!e#R!R!f#R!R!g#R!R!h#R!R!i#R!R!j#R!R!k#R!R!l#R!R!m#R!R!n#R!R!o#R!R!p#R!R!q#R!R!r#R!R!s#R!R!t#R!R!u#R!R!v#R!R$U#R!R~OQ5tO~P3-VOP(]OR(]OW#R!RX#R!Rc#R!Rg#R!Rh#R!Rl#R!Rm#R!Rn#R!Rv#R!R!`#R!R!a#R!R!b#R!R!c#R!R!d#R!R!e#R!R!f#R!R!g#R!R!h#R!R!i#R!R!j#R!R!k#R!R!l#R!R!m#R!R!n#R!R!o#R!R!p#R!R!q#R!R!r#R!R!s#R!R!t#R!R!u#R!R!v#R!R#O#R!R$U#R!R~OQ5uO~P3/|OP(^OQ5vOR(^O~P3 iOP(_OR(_OS#R!RT#R!RU#R!RV#R!RW#R!RX#R!RY#R!Rc#R!Rg#R!Rh#R!Rl#R!Rm#R!Rn#R!Rv#R!R!`#R!R!a#R!R!b#R!R!c#R!R!d#R!R!e#R!R!f#R!R!g#R!R!h#R!R!i#R!R!j#R!R!k#R!R!l#R!R!m#R!R!n#R!R!o#R!R!p#R!R!q#R!R!r#R!R!s#R!R!t#R!R!u#R!R!v#R!R#O#R!R$U#R!R~OQ5xO~P32tOP(`OR(`O[#R!Rg#R!Ro#R!Rp#R!Rq#R!Rr#R!Rs#R!Rt#R!Ru#R!Rw#R!Rx#R!Ry#R!Rz#R!R{#R!R|#R!R}#R!R!O#R!R!P#R!R!Q#R!R!R#R!R!S#R!R!T#R!R!U#R!R!V#R!R!W#R!R!X#R!R!Y#R!R!Z#R!R![#R!R!]#R!R!^#R!R!_#R!R#W#R!R~OQ5yO~P35nOP(aOR(aOS#R!RT#R!RU#R!RV#R!RW#R!RX#R!RZ#R!Rc#R!Rf#R!Rg#R!Rh#R!Rl#R!Rm#R!Rn#R!Rv#R!R!`#R!R!a#R!R!b#R!R!c#R!R!d#R!R!e#R!R!f#R!R!g#R!R!h#R!R!i#R!R!j#R!R!k#R!R!l#R!R!m#R!R!n#R!R!o#R!R!p#R!R!q#R!R!r#R!R!s#R!R!t#R!R!u#R!R!v#R!R#O#R!R~OQ5rO~P38UOP(bOR(bOS#R!RT#R!RU#R!RV#R!RW#R!RX#R!Rc#R!Rf#R!Rg#R!Rh#R!Rl#R!Rm#R!Rn#R!Rv#R!R!`#R!R!a#R!R!b#R!R!c#R!R!d#R!R!e#R!R!f#R!R!g#R!R!h#R!R!i#R!R!j#R!R!k#R!R!l#R!R!m#R!R!n#R!R!o#R!R!p#R!R!q#R!R!r#R!R!s#R!R!t#R!R!u#R!R!v#R!R#O#R!R#V#R!R~OQ5sO~P3;OOP(cOR(cOS#R!RT#R!RU#R!RV#R!RW#R!RX#R!RY#R!Rc#R!Rg#R!Rh#R!Rl#R!Rm#R!Rn#R!Rv#R!R!`#R!R!a#R!R!b#R!R!c#R!R!d#R!R!e#R!R!f#R!R!g#R!R!h#R!R!i#R!R!j#R!R!k#R!R!l#R!R!m#R!R!n#R!R!o#R!R!p#R!R!q#R!R!r#R!R!s#R!R!t#R!R!u#R!R!v#R!R$U#R!R~OQ5tO~P3=xOP(dOR(dOW#R!RX#R!Rc#R!Rg#R!Rh#R!Rl#R!Rm#R!Rn#R!Rv#R!R!`#R!R!a#R!R!b#R!R!c#R!R!d#R!R!e#R!R!f#R!R!g#R!R!h#R!R!i#R!R!j#R!R!k#R!R!l#R!R!m#R!R!n#R!R!o#R!R!p#R!R!q#R!R!r#R!R!s#R!R!t#R!R!u#R!R!v#R!R#O#R!R$U#R!R~OQ5uO~P3@oOP(fOQ5vOR(fO~P3 iOP(gOR(gOS#R!RT#R!RU#R!RV#R!RW#R!RX#R!RY#R!Rc#R!Rg#R!Rh#R!Rl#R!Rm#R!Rn#R!Rv#R!R!`#R!R!a#R!R!b#R!R!c#R!R!d#R!R!e#R!R!f#R!R!g#R!R!h#R!R!i#R!R!j#R!R!k#R!R!l#R!R!m#R!R!n#R!R!o#R!R!p#R!R!q#R!R!r#R!R!s#R!R!t#R!R!u#R!R!v#R!R#O#R!R$U#R!R~OQ5xO~P3CgOP(eOR(eO[#R!Rg#R!Ro#R!Rp#R!Rq#R!Rr#R!Rs#R!Rt#R!Ru#R!Rw#R!Rx#R!Ry#R!Rz#R!R{#R!R|#R!R}#R!R!O#R!R!P#R!R!Q#R!R!R#R!R!S#R!R!T#R!R!U#R!R!V#R!R!W#R!R!X#R!R!Y#R!R!Z#R!R![#R!R!]#R!R!^#R!R!_#R!R#W#R!R~OQ5yO~P3FaO_lO`lOalObkOflOi5POj5QOk4cOl!}OvlO#O>_O#ikO#jkOP#R!RQ#R!RR#R!R~P35tO[lObkO#WVO#ikO#jkOP#R!RQ#R!RR#R!RS#R!RT#R!RU#R!RV#R!RW#R!RX#R!Rc#R!Rf#R!Rg#R!Rh#R!Rl#R!Rm#R!Rn#R!Rv#R!R!`#R!R!a#R!R!b#R!R!c#R!R!d#R!R!e#R!R!f#R!R!g#R!R!h#R!R!i#R!R!j#R!R!k#R!R!l#R!R!m#R!R!n#R!R!o#R!R!p#R!R!q#R!R!r#R!R!s#R!R!t#R!R!u#R!R!v#R!R#O#R!R#V#R!RZ#R!R~P')aO[lObkOflO#O>_O#WVO#ikO#jkOP#R!RQ#R!RR#R!RS#R!RT#R!RU#R!RV#R!RW#R!RX#R!RY#R!Rc#R!Rg#R!Rh#R!Rl#R!Rm#R!Rn#R!Rv#R!R!`#R!R!a#R!R!b#R!R!c#R!R!d#R!R!e#R!R!f#R!R!g#R!R!h#R!R!i#R!R!j#R!R!k#R!R!l#R!R!m#R!R!n#R!R!o#R!R!p#R!R!q#R!R!r#R!R!s#R!R!t#R!R!u#R!R!v#R!R$U#R!R~P')aO[lObkOflO#WVO#ikO#jkOP#R!RQ#R!RR#R!RS#R!RT#R!RU#R!RV#R!RW#R!RX#R!RY#R!Rc#R!Rg#R!Rh#R!Rl#R!Rm#R!Rn#R!Rv#R!R!`#R!R!a#R!R!b#R!R!c#R!R!d#R!R!e#R!R!f#R!R!g#R!R!h#R!R!i#R!R!j#R!R!k#R!R!l#R!R!m#R!R!n#R!R!o#R!R!p#R!R!q#R!R!r#R!R!s#R!R!t#R!R!u#R!R!v#R!R#O#R!R$U#R!R~P')aO_lO`lOalOi5POj5QOk4cOo'qOpWOq'qOr3tOsWOt'qOuWOwWOx'qOy3tOz=OO{AvO|EWO}GgO!OWO!P'wO!Q4bO!R=qO!SBiO!TEyO!UHYO!V4bO!W'wO!XWO!Y'qO!Z3tO![=OO!]AvO!^EWO!_GgOP#R!RQ#R!RR#R!R~P3 iOP5oOQ!yOR5oOg6QO!}!z!R~OS!z!RT!z!RU!z!RV!z!RW!z!RX!z!RZ!z!Rc!z!Rf!z!Rh!z!Rl!z!Rm!z!Rn!z!Rv!z!R!`!z!R!a!z!R!b!z!R!c!z!R!d!z!R!e!z!R!f!z!R!g!z!R!h!z!R!i!z!R!j!z!R!k!z!R!l!z!R!m!z!R!n!z!R!o!z!R!p!z!R!q!z!R!r!z!R!s!z!R!t!z!R!u!z!R!v!z!R#O!z!R~OP(aOQ5wOR(aOg)SO~P4(mOS!z!RT!z!RU!z!RV!z!RW!z!RX!z!Rc!z!Rf!z!Rh!z!Rl!z!Rm!z!Rn!z!Rv!z!R!`!z!R!a!z!R!b!z!R!c!z!R!d!z!R!e!z!R!f!z!R!g!z!R!h!z!R!i!z!R!j!z!R!k!z!R!l!z!R!m!z!R!n!z!R!o!z!R!p!z!R!q!z!R!r!z!R!s!z!R!t!z!R!u!z!R!v!z!R#O!z!R#V!z!R~OP(bOQ5zOR(bOg:oO~P4+gOS!z!RT!z!RU!z!RV!z!RW!z!RX!z!RY!z!Rc!z!Rh!z!Rl!z!Rm!z!Rn!z!Rv!z!R!`!z!R!a!z!R!b!z!R!c!z!R!d!z!R!e!z!R!f!z!R!g!z!R!h!z!R!i!z!R!j!z!R!k!z!R!l!z!R!m!z!R!n!z!R!o!z!R!p!z!R!q!z!R!r!z!R!s!z!R!t!z!R!u!z!R!v!z!R$U!z!R~OP(cOQ5{OR(cOg)VO~P4.aOW!z!RX!z!Rc!z!Rh!z!Rl!z!Rm!z!Rn!z!Rv!z!R!`!z!R!a!z!R!b!z!R!c!z!R!d!z!R!e!z!R!f!z!R!g!z!R!h!z!R!i!z!R!j!z!R!k!z!R!l!z!R!m!z!R!n!z!R!o!z!R!p!z!R!q!z!R!r!z!R!s!z!R!t!z!R!u!z!R!v!z!R#O!z!R~OP(dOQ5|OR(dOg:pO$U!z!R~P41WOP(fOQ6POR(fOg)XO[!z!Rb!z!R#W!z!R#i!z!R#j!z!R~P4+gO!}!z!R~P5bO[lO_lO`lOalObkOi5POj5QOk4cOo'qOpWOq'qOr3tOsWOt'qOuWOwWOx'qOy3tOz=OO{AvO|EWO}GgO!OWO!P'wO!Q4bO!R=qO!SBiO!TEyO!UHYO!V4bO!W'wO!XWO!Y'qO!Z3tO![=OO!]AvO!^EWO!_GgO#WVO#ikO#jkO#V!z!R~P4(mO[lO_lO`lOalObkOflOi5POj5QOk4cOo'qOpWOq'qOr3tOsWOt'qOuWOwWOx'qOy3tOz=OO{AvO|EWO}GgO!OWO!P'wO!Q4bO!R=qO!SBiO!TEyO!UHYO!V4bO!W'wO!XWO!Y'qO!Z3tO![=OO!]AvO!^EWO!_GgO#O>_O#WVO#ikO#jkO~P4.aO_lO`lOalOi5POj5QOk4cOo'qOpWOq'qOr3tOsWOt'qOuWOwWOx'qOy3tOz=OO{AvO|EWO}GgO!OWO!P'wO!Q4bO!R=qO!SBiO!TEyO!UHYO!V4bO!W'wO!XWO!Y'qO!Z3tO![=OO!]AvO!^EWO!_GgO[!z!Rb!z!R#W!z!R#i!z!R#j!z!R~P4+gOP5oOQ!yOR5oOg#R!Z!}#R!Z#V#R!Z$U#R!Z~O[#R!Zb#R!Zf#R!Zg#R!Zl#R!Zv#R!Z#O#R!Z#W#R!Z#i#R!Z#j#R!ZS#R!ZT#R!ZU#R!ZV#R!ZW#R!ZX#R!Zc#R!Zh#R!Zm#R!Zn#R!Z!`#R!Z!a#R!Z!b#R!Z!c#R!Z!d#R!Z!e#R!Z!f#R!Z!g#R!Z!h#R!Z!i#R!Z!j#R!Z!k#R!Z!l#R!Z!m#R!Z!n#R!Z!o#R!Z!p#R!Z!q#R!Z!r#R!Z!s#R!Z!t#R!Z!u#R!Z!v#R!Z#V#R!Z~OP(XOQ5qOR(XO_#R!Z`#R!Za#R!Zi#R!Zj#R!Zk#R!Zo#R!Zp#R!Zq#R!Zr#R!Zs#R!Zt#R!Zu#R!Zw#R!Zx#R!Zy#R!Zz#R!Z{#R!Z|#R!Z}#R!Z!O#R!Z!P#R!Z!Q#R!Z!R#R!Z!S#R!Z!T#R!Z!U#R!Z!V#R!Z!W#R!Z!X#R!Z!Y#R!Z!Z#R!Z![#R!Z!]#R!Z!^#R!Z!_#R!Z$U#R!ZY#R!Ze#R!Z!}#R!ZZ#R!Z~P4=hOP(YOR(YOS#R!ZT#R!ZU#R!ZV#R!ZW#R!ZX#R!ZZ#R!Zc#R!Zf#R!Zg#R!Zh#R!Zl#R!Zm#R!Zn#R!Zv#R!Z!`#R!Z!a#R!Z!b#R!Z!c#R!Z!d#R!Z!e#R!Z!f#R!Z!g#R!Z!h#R!Z!i#R!Z!j#R!Z!k#R!Z!l#R!Z!m#R!Z!n#R!Z!o#R!Z!p#R!Z!q#R!Z!r#R!Z!s#R!Z!t#R!Z!u#R!Z!v#R!Z#O#R!Z~OQ5rO~P4CbOP(ZOR(ZOS#R!ZT#R!ZU#R!ZV#R!ZW#R!ZX#R!Zc#R!Zf#R!Zg#R!Zh#R!Zl#R!Zm#R!Zn#R!Zv#R!Z!`#R!Z!a#R!Z!b#R!Z!c#R!Z!d#R!Z!e#R!Z!f#R!Z!g#R!Z!h#R!Z!i#R!Z!j#R!Z!k#R!Z!l#R!Z!m#R!Z!n#R!Z!o#R!Z!p#R!Z!q#R!Z!r#R!Z!s#R!Z!t#R!Z!u#R!Z!v#R!Z#O#R!Z#V#R!Z~OQ5sO~P4F[OP([OR([OS#R!ZT#R!ZU#R!ZV#R!ZW#R!ZX#R!ZY#R!Zc#R!Zg#R!Zh#R!Zl#R!Zm#R!Zn#R!Zv#R!Z!`#R!Z!a#R!Z!b#R!Z!c#R!Z!d#R!Z!e#R!Z!f#R!Z!g#R!Z!h#R!Z!i#R!Z!j#R!Z!k#R!Z!l#R!Z!m#R!Z!n#R!Z!o#R!Z!p#R!Z!q#R!Z!r#R!Z!s#R!Z!t#R!Z!u#R!Z!v#R!Z$U#R!Z~OQ5tO~P4IUOP(]OR(]OW#R!ZX#R!Zc#R!Zg#R!Zh#R!Zl#R!Zm#R!Zn#R!Zv#R!Z!`#R!Z!a#R!Z!b#R!Z!c#R!Z!d#R!Z!e#R!Z!f#R!Z!g#R!Z!h#R!Z!i#R!Z!j#R!Z!k#R!Z!l#R!Z!m#R!Z!n#R!Z!o#R!Z!p#R!Z!q#R!Z!r#R!Z!s#R!Z!t#R!Z!u#R!Z!v#R!Z#O#R!Z$U#R!Z~OQ5uO~P4K{OP(^OQ5vOR(^O~P4=hOP(_OR(_OS#R!ZT#R!ZU#R!ZV#R!ZW#R!ZX#R!ZY#R!Zc#R!Zg#R!Zh#R!Zl#R!Zm#R!Zn#R!Zv#R!Z!`#R!Z!a#R!Z!b#R!Z!c#R!Z!d#R!Z!e#R!Z!f#R!Z!g#R!Z!h#R!Z!i#R!Z!j#R!Z!k#R!Z!l#R!Z!m#R!Z!n#R!Z!o#R!Z!p#R!Z!q#R!Z!r#R!Z!s#R!Z!t#R!Z!u#R!Z!v#R!Z#O#R!Z$U#R!Z~OQ5xO~P4NsOP(`OR(`O[#R!Zg#R!Zo#R!Zp#R!Zq#R!Zr#R!Zs#R!Zt#R!Zu#R!Zw#R!Zx#R!Zy#R!Zz#R!Z{#R!Z|#R!Z}#R!Z!O#R!Z!P#R!Z!Q#R!Z!R#R!Z!S#R!Z!T#R!Z!U#R!Z!V#R!Z!W#R!Z!X#R!Z!Y#R!Z!Z#R!Z![#R!Z!]#R!Z!^#R!Z!_#R!Z#W#R!Z~OQ5yO~P5#mOP(aOR(aOS#R!ZT#R!ZU#R!ZV#R!ZW#R!ZX#R!ZZ#R!Zc#R!Zf#R!Zg#R!Zh#R!Zl#R!Zm#R!Zn#R!Zv#R!Z!`#R!Z!a#R!Z!b#R!Z!c#R!Z!d#R!Z!e#R!Z!f#R!Z!g#R!Z!h#R!Z!i#R!Z!j#R!Z!k#R!Z!l#R!Z!m#R!Z!n#R!Z!o#R!Z!p#R!Z!q#R!Z!r#R!Z!s#R!Z!t#R!Z!u#R!Z!v#R!Z#O#R!Z~OQ5rO~P5&TOP(bOR(bOS#R!ZT#R!ZU#R!ZV#R!ZW#R!ZX#R!Zc#R!Zf#R!Zg#R!Zh#R!Zl#R!Zm#R!Zn#R!Zv#R!Z!`#R!Z!a#R!Z!b#R!Z!c#R!Z!d#R!Z!e#R!Z!f#R!Z!g#R!Z!h#R!Z!i#R!Z!j#R!Z!k#R!Z!l#R!Z!m#R!Z!n#R!Z!o#R!Z!p#R!Z!q#R!Z!r#R!Z!s#R!Z!t#R!Z!u#R!Z!v#R!Z#O#R!Z#V#R!Z~OQ5sO~P5(}OP(cOR(cOS#R!ZT#R!ZU#R!ZV#R!ZW#R!ZX#R!ZY#R!Zc#R!Zg#R!Zh#R!Zl#R!Zm#R!Zn#R!Zv#R!Z!`#R!Z!a#R!Z!b#R!Z!c#R!Z!d#R!Z!e#R!Z!f#R!Z!g#R!Z!h#R!Z!i#R!Z!j#R!Z!k#R!Z!l#R!Z!m#R!Z!n#R!Z!o#R!Z!p#R!Z!q#R!Z!r#R!Z!s#R!Z!t#R!Z!u#R!Z!v#R!Z$U#R!Z~OQ5tO~P5+wOP(dOR(dOW#R!ZX#R!Zc#R!Zg#R!Zh#R!Zl#R!Zm#R!Zn#R!Zv#R!Z!`#R!Z!a#R!Z!b#R!Z!c#R!Z!d#R!Z!e#R!Z!f#R!Z!g#R!Z!h#R!Z!i#R!Z!j#R!Z!k#R!Z!l#R!Z!m#R!Z!n#R!Z!o#R!Z!p#R!Z!q#R!Z!r#R!Z!s#R!Z!t#R!Z!u#R!Z!v#R!Z#O#R!Z$U#R!Z~OQ5uO~P5.nOP(fOQ5vOR(fO~P4=hOP(gOR(gOS#R!ZT#R!ZU#R!ZV#R!ZW#R!ZX#R!ZY#R!Zc#R!Zg#R!Zh#R!Zl#R!Zm#R!Zn#R!Zv#R!Z!`#R!Z!a#R!Z!b#R!Z!c#R!Z!d#R!Z!e#R!Z!f#R!Z!g#R!Z!h#R!Z!i#R!Z!j#R!Z!k#R!Z!l#R!Z!m#R!Z!n#R!Z!o#R!Z!p#R!Z!q#R!Z!r#R!Z!s#R!Z!t#R!Z!u#R!Z!v#R!Z#O#R!Z$U#R!Z~OQ5xO~P51fOP(eOR(eO[#R!Zg#R!Zo#R!Zp#R!Zq#R!Zr#R!Zs#R!Zt#R!Zu#R!Zw#R!Zx#R!Zy#R!Zz#R!Z{#R!Z|#R!Z}#R!Z!O#R!Z!P#R!Z!Q#R!Z!R#R!Z!S#R!Z!T#R!Z!U#R!Z!V#R!Z!W#R!Z!X#R!Z!Y#R!Z!Z#R!Z![#R!Z!]#R!Z!^#R!Z!_#R!Z#W#R!Z~OQ5yO~P54`O_lO`lOalObkOflOi5POj5QOk4cOl!}OvlO#O>_O#ikO#jkOP#R!ZQ#R!ZR#R!Z~P5#sO[lObkO#WVO#ikO#jkOP#R!ZQ#R!ZR#R!ZS#R!ZT#R!ZU#R!ZV#R!ZW#R!ZX#R!Zc#R!Zf#R!Zg#R!Zh#R!Zl#R!Zm#R!Zn#R!Zv#R!Z!`#R!Z!a#R!Z!b#R!Z!c#R!Z!d#R!Z!e#R!Z!f#R!Z!g#R!Z!h#R!Z!i#R!Z!j#R!Z!k#R!Z!l#R!Z!m#R!Z!n#R!Z!o#R!Z!p#R!Z!q#R!Z!r#R!Z!s#R!Z!t#R!Z!u#R!Z!v#R!Z#O#R!Z#V#R!ZZ#R!Z~P')aO[lObkOflO#O>_O#WVO#ikO#jkOP#R!ZQ#R!ZR#R!ZS#R!ZT#R!ZU#R!ZV#R!ZW#R!ZX#R!ZY#R!Zc#R!Zg#R!Zh#R!Zl#R!Zm#R!Zn#R!Zv#R!Z!`#R!Z!a#R!Z!b#R!Z!c#R!Z!d#R!Z!e#R!Z!f#R!Z!g#R!Z!h#R!Z!i#R!Z!j#R!Z!k#R!Z!l#R!Z!m#R!Z!n#R!Z!o#R!Z!p#R!Z!q#R!Z!r#R!Z!s#R!Z!t#R!Z!u#R!Z!v#R!Z$U#R!Z~P')aO[lObkOflO#WVO#ikO#jkOP#R!ZQ#R!ZR#R!ZS#R!ZT#R!ZU#R!ZV#R!ZW#R!ZX#R!ZY#R!Zc#R!Zg#R!Zh#R!Zl#R!Zm#R!Zn#R!Zv#R!Z!`#R!Z!a#R!Z!b#R!Z!c#R!Z!d#R!Z!e#R!Z!f#R!Z!g#R!Z!h#R!Z!i#R!Z!j#R!Z!k#R!Z!l#R!Z!m#R!Z!n#R!Z!o#R!Z!p#R!Z!q#R!Z!r#R!Z!s#R!Z!t#R!Z!u#R!Z!v#R!Z#O#R!Z$U#R!Z~P')aO_lO`lOalOi5POj5QOk4cOo'qOpWOq'qOr3tOsWOt'qOuWOwWOx'qOy3tOz=OO{AvO|EWO}GgO!OWO!P'wO!Q4bO!R=qO!SBiO!TEyO!UHYO!V4bO!W'wO!XWO!Y'qO!Z3tO![=OO!]AvO!^EWO!_GgOP#R!ZQ#R!ZR#R!Z~P4=hOP5oOQ!yOR5oOg6QO!}!z!Z~OS!z!ZT!z!ZU!z!ZV!z!ZW!z!ZX!z!ZZ!z!Zc!z!Zf!z!Zh!z!Zl!z!Zm!z!Zn!z!Zv!z!Z!`!z!Z!a!z!Z!b!z!Z!c!z!Z!d!z!Z!e!z!Z!f!z!Z!g!z!Z!h!z!Z!i!z!Z!j!z!Z!k!z!Z!l!z!Z!m!z!Z!n!z!Z!o!z!Z!p!z!Z!q!z!Z!r!z!Z!s!z!Z!t!z!Z!u!z!Z!v!z!Z#O!z!Z~OP(aOQ5wOR(aOg)SO~P5DlOS!z!ZT!z!ZU!z!ZV!z!ZW!z!ZX!z!Zc!z!Zf!z!Zh!z!Zl!z!Zm!z!Zn!z!Zv!z!Z!`!z!Z!a!z!Z!b!z!Z!c!z!Z!d!z!Z!e!z!Z!f!z!Z!g!z!Z!h!z!Z!i!z!Z!j!z!Z!k!z!Z!l!z!Z!m!z!Z!n!z!Z!o!z!Z!p!z!Z!q!z!Z!r!z!Z!s!z!Z!t!z!Z!u!z!Z!v!z!Z#O!z!Z#V!z!Z~OP(bOQ5zOR(bOg:oO~P5GfOS!z!ZT!z!ZU!z!ZV!z!ZW!z!ZX!z!ZY!z!Zc!z!Zh!z!Zl!z!Zm!z!Zn!z!Zv!z!Z!`!z!Z!a!z!Z!b!z!Z!c!z!Z!d!z!Z!e!z!Z!f!z!Z!g!z!Z!h!z!Z!i!z!Z!j!z!Z!k!z!Z!l!z!Z!m!z!Z!n!z!Z!o!z!Z!p!z!Z!q!z!Z!r!z!Z!s!z!Z!t!z!Z!u!z!Z!v!z!Z$U!z!Z~OP(cOQ5{OR(cOg)VO~P5J`OW!z!ZX!z!Zc!z!Zh!z!Zl!z!Zm!z!Zn!z!Zv!z!Z!`!z!Z!a!z!Z!b!z!Z!c!z!Z!d!z!Z!e!z!Z!f!z!Z!g!z!Z!h!z!Z!i!z!Z!j!z!Z!k!z!Z!l!z!Z!m!z!Z!n!z!Z!o!z!Z!p!z!Z!q!z!Z!r!z!Z!s!z!Z!t!z!Z!u!z!Z!v!z!Z#O!z!Z~OP(dOQ5|OR(dOg:pO$U!z!Z~P5MVOP(fOQ6POR(fOg)XO[!z!Zb!z!Z#W!z!Z#i!z!Z#j!z!Z~P5GfO!}!z!Z~P5bO[lO_lO`lOalObkOi5POj5QOk4cOo'qOpWOq'qOr3tOsWOt'qOuWOwWOx'qOy3tOz=OO{AvO|EWO}GgO!OWO!P'wO!Q4bO!R=qO!SBiO!TEyO!UHYO!V4bO!W'wO!XWO!Y'qO!Z3tO![=OO!]AvO!^EWO!_GgO#WVO#ikO#jkO#V!z!Z~P5DlO[lO_lO`lOalObkOflOi5POj5QOk4cOo'qOpWOq'qOr3tOsWOt'qOuWOwWOx'qOy3tOz=OO{AvO|EWO}GgO!OWO!P'wO!Q4bO!R=qO!SBiO!TEyO!UHYO!V4bO!W'wO!XWO!Y'qO!Z3tO![=OO!]AvO!^EWO!_GgO#O>_O#WVO#ikO#jkO~P5J`O_lO`lOalOi5POj5QOk4cOo'qOpWOq'qOr3tOsWOt'qOuWOwWOx'qOy3tOz=OO{AvO|EWO}GgO!OWO!P'wO!Q4bO!R=qO!SBiO!TEyO!UHYO!V4bO!W'wO!XWO!Y'qO!Z3tO![=OO!]AvO!^EWO!_GgO[!z!Zb!z!Z#W!z!Z#i!z!Z#j!z!Z~P5GfOP5oOQ!yOR5oOg6QO~OP(XOQ5qOR(XOg(lO~OP(aOQ5wOR(aOg)SO~OP(bOQ5zOR(bOg:oO~OP(cOQ5{OR(cOg)VO~OP(dOQ5|OR(dOg:pO~OP(fOQ6POR(fOg)XO~OP(gOQ6OOR(gOg)RO~O[lO_lO`lOalObkOflOi=tOj=yOkAlOl!}Oo3gOpWOq3gOrAjOsWOt3gOuWOvlOwWOx3gOyAjOzEOO{GaO|HqO}IQO!O'uO!P'zO!Q=mO!RBeO!SEuO!THUO!UHvO!V=mO!W'zO!XWO!Y3gO!ZAjO![EOO!]GaO!^HqO!_IQO#O>_O#WVO#ikO#jkO~OP#lXQ#lXR#lXg#lX!}#lX~P5bOP#lXQ#lXR#lXg#lX#V#lX~P5bO!}+UOP!{XQ!{XR!{Xg!{X~O!}+VOP!{XQ!{XR!{Xg!{X~O!}+WOP!{XQ!{XR!{Xg!{X~O!}+XOP!{XQ!{XR!{Xg!{X~O!}+YOP!{XQ!{XR!{Xg!{X~O!}+lO~OQ-RO~P#5lOQ-TO~P#5lOQ-QO~P#5lOQ-SO~P#5lOQ-UO~P#5lOP(XOQ5qOR(XOg(lOW$]aX$]ac$]ah$]am$]an$]a!`$]a!a$]a!b$]a!c$]a!d$]a!e$]a!f$]a!g$]a!h$]a!i$]a!j$]a!k$]a!l$]a!m$]a!n$]a!o$]a!p$]a!q$]a!r$]a!s$]a!t$]a!u$]a!v$]a$U$]a~P6-dOP(XOQ5qOR(XOg(lO~P6-dO[-lO#W8bO~P#FUO[-mO#W8cO~P#FUO[-nO#W8dO~P#FUO[-oO#W8eO~P#FUO#V/aO~P%*aO#V/bO~P%*aO#V/cO~P%*aO#V/dO~P%*aOQ5wO~P)5ZOQ5zO~P)8TOQ5{O~P):}OQ5|O~P)=tOP(^OQ6POR(^O~P)/aOQ6OO~P)@lOQ5}O~P)CfOQ5wO~P)E|OQ5zO~P)HvOQ5{O~P)KpOQ5|O~P)NgOP(fOQ6POR(fO~P)/aOQ6OO~P*#_OQ5}O~P*&XOQ5wO~P,AbOQ5zO~P,D[OQ5{O~P,GUOQ5|O~P,I{OP(^OQ6POR(^O~P,;hOQ6OO~P,LsOQ5}O~P- mOQ5wO~P-$TOQ5zO~P-&}OQ5{O~P-)wOQ5|O~P-,nOP(fOQ6POR(fO~P,;hOQ6OO~P-/fOQ5}O~P-2`OQ5wO~P/,XOQ5zO~P//ROQ5{O~P/1{OQ5|O~P/4rOP(^OQ6POR(^O~P/&_OQ6OO~P/7jOQ5}O~P/:dOQ5wO~P/C]OQ5zO~P/FVOQ5{O~P/IPOQ5|O~P/KvOP(^OQ6POR(^O~P/=cOQ6OO~P/NnOQ5}O~P0#hOQ5wO~P0&OOQ5zO~P0(xOQ5{O~P0+rOQ5|O~P0.iOP(fOQ6POR(fO~P/=cOQ6OO~P01aOQ5}O~P04ZOQ5wO~P19dOQ5zO~P1<^OQ5{O~P1?WOQ5|O~P1A}OP(^OQ6POR(^O~P13jOQ6OO~P1DuOQ5}O~P1GoOQ5wO~P1JVOQ5zO~P1MPOQ5{O~P2 yOQ5|O~P2$pOP(fOQ6POR(fO~P13jOQ6OO~P2'hOQ5}O~P2*bOQ5wO~P3'cOQ5zO~P3*]OQ5{O~P3-VOQ5|O~P3/|OP(^OQ6POR(^O~P3 iOQ6OO~P32tOQ5}O~P35nOQ5wO~P38UOQ5zO~P3;OOQ5{O~P3=xOQ5|O~P3@oOP(fOQ6POR(fO~P3 iOQ6OO~P3CgOQ5}O~P3FaOQ5wO~P4CbOQ5zO~P4F[OQ5{O~P4IUOQ5|O~P4K{OP(^OQ6POR(^O~P4=hOQ6OO~P4NsOQ5}O~P5#mOQ5wO~P5&TOQ5zO~P5(}OQ5{O~P5+wOQ5|O~P5.nOP(fOQ6POR(fO~P4=hOQ6OO~P51fOQ5}O~P54`O",
  goto: "*8W$aPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPP$b$e%d!BsPP#1v#Mh$;f%*m%*m%F_PP%IR&8g&8qP&9O&9g&9k&:O&:O&:O&:e&:k&:O&:q&;z'*`PP'F|(5[)$h)$h)@p)Aa)Aa)BQ$b)BX)BX)B]$b)B`)Bf)If)Iz)Jc)Jq)KQ)K`)Km)Ks)K})LTPPP)LZ)Ld*5v)@p)@p*6_*6x*7nR![OQ!UOQ!V!WQ!bPr!nV!j!v#[#x$a$h${%g%n%p%z&s8b8c8d8eQ#y!ZU#{!]>_>`Q%l#tX5p$f<z<{<|QXOS!|Z3iQ#O[Q#P]Q#Q^Q#R_Q#S`(Y#Tab|}!T#U#V#_#m#n#s$t$u%b%c&W&X&g&h&{&|'T'U'^'_'e'f'i'n'r's't'u'v'w'x'y'z'{'|(S(T(U(V*X*Y*Z*[*]*^*`*{*|*}+O,z,{,|,}-O-P-h-i-j-k.z.{.|.}/O/P/]/^/_/`0c0d0e0f0g0h0t0u0v0w1v1w1x1y1z1{2X2Y2Z2[2m2n2o2p2q2x2y2z2{5f5g5h5i6p6q6r6s6t6{6|6}7O7P7Z7[7]7^7_7`7a7b8Q8R8S8T8U8^8_8`8a9T9U9V9W9X9a9b9c9d:S:T:U:V:W:`:a:b:c:e:f:g:h:i:k:l:m:n>Z>[>]>^Q#VcQ#WdQ#XeQ#YfQ#ZgQ#^iS#`mqQ#gvQ#hwQ#ixQ#jyQ#kzQ#l{Q#n!OQ#o!PQ#p!QQ#q!RQ#r!SQ$O!`Q$m!yW$n!{#O)W*VQ$o#PQ$p#QQ$q#RQ$r#SQ$u#WQ$v#XQ$w#YQ$x#ZQ%T#`Q%]#hQ%^#iQ%_#jQ%`#kQ%a#lQ%c#oQ%d#pQ%e#qQ%f#rQ&R$mS&S$o,xQ&T$pQ&U$qQ&V$rQ&X$vQ&Y$wQ&Z$xQ&c%^Q&d%_Q&e%`Q&f%aQ&h%dQ&i%eQ&j%fS&x&T.xQ&y&UQ&z&VQ&|&YQ&}&ZQ'Q&dQ'R&eQ'S&fQ'U&iQ'V&jS'[&y0aQ']&zQ'_&}Q'c'RQ'd'SQ'f'VS'h']1tQ'm'dQ)Y3UQ)Z'qQ)[3sQ)]3rQ)^3pQ)_3nQ)`3mQ)a3kQ)b3hQ)c3`Q)d3]Q)e3YQ)f3WQ)g3[Q)h3bQ)i3cQ)k3tQ)l3uQ)m3vQ)n3wQ)o3xQ)p3yQ)q3zQ)r3{Q)s3|Q)t3}Q)u4OQ)v4PQ)w4QQ)x4RQ)y4SQ)z4TQ){4UQ)|4VQ)}4WQ*O4XQ*P4YQ*Q4ZQ*R4[Q*S4]Q*T4^Q*U4_Q*V4`Q*W4aQ*^4bQ*_5PS*a+S5RQ*b+RS*c+Q5SQ*d+PS*e+T5TQ*p'}Q*q(OQ*r(PQ*s(QQ*t5`Q*u(RQ*v5aQ*w5bQ*x5cQ*y5dQ*z5eQ+Z(WQ+[(XQ+](YQ+^(ZQ+_([Q+`(]Q+a(^Q+b(_Q+c(`Q+d5oQ+e(aQ+f(bQ+g(cQ+h(dQ+i(fQ+j(gS+k%Q(eQ+m5qQ+n5rQ+o5sQ+p5tQ+q5uQ+r5vQ+s5wQ+t5xQ+u5yQ+v5z^+w%R-Q-R-S-T-U5}Q+x5{Q+y5|Q+z6PQ+{6OS+|6Q6RS+}(l)kS,O(m)lS,P(n)mS,Q(o)nS,R(p)oS,S(q)pS,T(s)rS,U(t)sS,V(x)wS,W(z)yS,X(|){S,Y(})|S,Z)Q*PS,[)T*SS,])U*TQ,^6SQ,_6TQ,`6UQ,a6VQ,b6WQ,c6XQ,d6YQ,e6ZQ,f6[Q,g6]Q,h6^Q,i6_Q,j6`Q,k6aQ,l6bQ,m6cQ,n6dQ,o6eQ,p6fQ,q6gQ,r6hQ,s6iQ,t6jQ,u6kQ,v6lQ,w6mQ,x6nQ,y6oQ-P6uQ-V*aQ-W*bQ-X*cQ-Y*dQ-Z7QQ-[*eQ-]*vQ-^*wQ-_*xQ-`*yQ-a7TQ-b*zQ-c7UQ-d7VQ-e7WQ-f7XQ-g7YQ-t+mQ-u+nQ-v+oQ-w+pQ-x+qQ-y+rQ-z+tQ-{+uQ-|7cQ-},^Q.O,_Q.P,`Q.Q,aQ.R,bQ.S,cQ.T,eQ.U,fQ.V,jQ.W,lQ.X,nQ.Y,oQ.Z,rQ.[,uQ.],vQ.^7dQ._7eQ.`7fQ.a7gQ.b7hQ.c7iQ.d7jQ.e7kQ.f7lQ.g7mQ.h7nQ.i7oQ.j7pQ.k7qQ.l7rQ.m7sQ.n7tQ.o7uQ.p7vQ.q7wQ.r7xQ.s7yQ.t7zQ.u7{Q.v7|Q.w7}Q.x8OQ.y8PQ/P8VQ/Q-cQ/R-dQ/S-eQ/T-fQ/U8WQ/V-gQ/W8XQ/X8YQ/Y8ZQ/Z8[Q/[8]Q/e8fQ/f.^Q/g._Q/h.`Q/i.aQ/j.bQ/k.cQ/l.eQ/m.fQ/n.jQ/o.lQ/p.nQ/q.oQ/r.rQ/s.uQ/t.vQ/u8gQ/v8hQ/w8iQ/x8jQ/y8kQ/z8lQ/{8mQ/|8nQ/}8oQ0O8pQ0P8qQ0Q8rQ0R8sQ0S8tQ0T8uQ0U8vQ0V8wQ0W8xQ0X8yQ0Y8zQ0Z8{Q0[8|Q0]8}Q0^9OQ0_9PQ0`9QQ0a9RQ0b9SQ0h9YQ0i/WQ0j/XQ0k/YQ0l/ZQ0m9ZQ0n/[Q0o9[Q0p9]Q0q9^Q0r9_Q0s9`Q0x9eQ0y/uQ0z/vQ0{/wQ0|/xQ0}/yQ1O/zQ1P/|Q1Q/}Q1R0RQ1S0TQ1T0VQ1U0WQ1V0ZQ1W0^Q1X0_Q1Y9fQ1Z9gQ1[9hQ1]9iQ1^9jQ1_9kQ1`9lQ1a9mQ1b9nQ1c9oQ1d9pQ1e9qQ1f9rQ1g9sQ1h9tQ1i9uQ1j9vQ1k9wQ1l9xQ1m9yQ1n9zQ1o9{Q1p9|Q1q9}Q1r:OQ1s:PQ1t:QQ1u:RQ1{:XQ1|0oQ1}0pQ2O0qQ2P0rQ2Q:YQ2R0sQ2S:ZQ2T:[Q2U:]Q2V:^Q2W:_Q2]:dQ2^1YQ2_1ZQ2`1[Q2a1]Q2b1^Q2c1_Q2d1aQ2e1bQ2f1fQ2g1hQ2h1jQ2i1kQ2j1nQ2k1qQ2l1rQ2r2SQ2s2TQ2t2UQ2u2VQ2v:jQ2w2Wh2|PV!]!j$f*f*k<z<{<|>_>`j2}#[$a$}%g%{'O'P'a'b8b8c8d8eS3O*g*lS3P*h*mS3Q*i*nS3R7R7SS3S*j*oS3T#c#eQ6R<}Q6S=OQ6T=PQ6U=QQ6V=RQ6W=SQ6X=TQ6Y=UQ6Z=VQ6[=WQ6]=XQ6^=YQ6_=ZQ6`=[Q6a=]Q6b=^Q6c=_Q6d=`Q6e=aQ6f=bQ6g=cQ6h=dQ6i=eQ6j=fQ6k=gQ6l=hQ6m=iQ6n=jQ6o=kQ6p=lQ6q=mQ6r=nQ6s=oQ6t=pQ6u=qQ6v=sQ6w=tQ6x=uQ6y=vQ6z=wQ7Q#uQ7T>PQ7U>QQ7V>RQ7W>SQ7X>TQ7Y>UQ7Z>VQ7[>WQ7]>XQ7^>YQ7c>aQ7d>bQ7e>cQ7f>dQ7g>eQ7h>fQ7i>gQ7j>hQ7k>iQ7l>jQ7m>kQ7n>lQ7o>mQ7p>nQ7q>oQ7r>pQ7s>qQ7t>rQ7u>sQ7v>tQ7w>uQ7x>vQ7y>wQ7z>xQ7{>yQ7|>zQ7}>{Q8O>|Q8P>}Q8Q?OQ8R?PQ8S?QQ8T?RQ8U?SQ8V?TQ8W?UQ8X?VQ8Y?WQ8Z?XQ8[?YQ8]?ZQ8^?[Q8_?]Q8`?^Q8a?_Q8f?`Q8g?aQ8h?bQ8i?cQ8j?dQ8k?eQ8l?fQ8m?gQ8n?hQ8o?iQ8p?jQ8q?kQ8r?lQ8s?mQ8t?nQ8u?oQ8v?pQ8w?qQ8x?rQ8y?sQ8z?tQ8{?uQ8|?vQ8}?wQ9O?xQ9P?yQ9Q?zQ9R?{Q9S?|Q9T?}Q9U@OQ9V@PQ9W@QQ9X@RQ9Y@SQ9Z@TQ9[@UQ9]@VQ9^@WQ9_@XQ9`@YQ9a@ZQ9b@[Q9c@]Q9d@^Q9e@_Q9f@`Q9g@aQ9h@bQ9i@cQ9j@dQ9k@eQ9l@fQ9m@gQ9n@hQ9o@iQ9p@jQ9q@kQ9r@lQ9s@mQ9t@nQ9u@oQ9v@pQ9w@qQ9x@rQ9y@sQ9z@tQ9{@uQ9|@vQ9}@wQ:O@xQ:P@yQ:Q@zQ:R@{Q:S@|Q:T@}Q:UAOQ:VAPQ:WAQQ:XARQ:YASQ:ZATQ:[AUQ:]AVQ:^AWQ:_AXQ:`AYQ:aAZQ:bA[Q:cA]Q:dA^Q:eA_Q:fA`Q:gAaQ:hAbQ:iAcQ:jAdQ:kAeQ:lAfQ:mAgQ:nAhQ:q3lQ:r3eQ:s3aQ:t3^Q:u3ZQ:v3VQ:w3XQ:x3_Q:y3dQ:z3fQ:{3gQ:|3jQ:}3oQ;O3qQ;PAiQ;QAjS;R(r)qS;S(u)tS;T(w)vS;U(y)xS;V({)zS;W)O)}S;X)P*OS;Y)S*RS;Z:o;PS;[)V*US;]:p;QS;^)X*WS;_)R*QS;`(v)uQ;aAmQ;bAnQ;c+sQ;d+vQ;e+xQ;f+yQ;g+zQ;h+{Q;i+wQ;j,dQ;k,gQ;l,iQ;m,kQ;n,mQ;o,pQ;p,qQ;q,tQ;r;aQ;s,wQ;t;bQ;u,yQ;v,sQ;w,hQ;xAoQ;yApQ;z.dQ;{.gQ;|.iQ;}.kQ<O.mQ<P.pQ<Q.qQ<R.tQ<S;xQ<T.wQ<U;yQ<V.yQ<W.sQ<X.hQ<YAqQ<ZArQ<[/{Q<]0OQ<^0QQ<_0SQ<`0UQ<a0XQ<b0YQ<c0]Q<d<YQ<e0`Q<f<ZQ<g0bQ<h0[Q<i0PQ<jAsQ<kAtQ<l1`Q<m1cQ<n1eQ<o1gQ<p1iQ<q1lQ<r1mQ<s1pQ<t<jQ<u1sQ<v<kQ<w1uQ<x1oQ<y1dQ>aAuQ>bAvQ>cAwQ>dAxQ>eAyQ>fAzQ>gA{Q>hA|Q>iA}Q>jBOQ>kBPQ>lBQQ>mBRQ>nBSQ>oBTQ>pBUQ>qBVQ>rBWQ>sBXQ>tBYQ>uBZQ>vB[Q>wB]Q>xB^Q>yB_Q>zB`Q>{BaQ>|BbQ>}BcQ?OBdQ?PBeQ?QBfQ?RBgQ?SBhQ?TBiQ?UBjQ?VBkQ?WBlQ?XBmQ?YBnQ?ZBoQ?[BpQ?]BqQ?^BrQ?_BsQ?`BtQ?aBuQ?bBvQ?cBwQ?dBxQ?eByQ?fBzQ?gB{Q?hB|Q?iB}Q?jCOQ?kCPQ?lCQQ?mCRQ?nCSQ?oCTQ?pCUQ?qCVQ?rCWQ?sCXQ?tCYQ?uCZQ?vC[Q?wC]Q?xC^Q?yC_Q?zC`Q?{CaQ?|CbQ?}CcQ@OCdQ@PCeQ@QCfQ@RCgQ@SChQ@TCiQ@UCjQ@VCkQ@WClQ@XCmQ@YCnQ@ZCoQ@[CpQ@]CqQ@^CrQ@_CsQ@`CtQ@aCuQ@bCvQ@cCwQ@dCxQ@eCyQ@fCzQ@gC{Q@hC|Q@iC}Q@jDOQ@kDPQ@lDQQ@mDRQ@nDSQ@oDTQ@pDUQ@qDVQ@rDWQ@sDXQ@tDYQ@uDZQ@vD[Q@wD]Q@xD^Q@yD_Q@zD`Q@{DaQ@|DbQ@}DcQAODdQAPDeQAQDfQARDgQASDhQATDiQAUDjQAVDkQAWDlQAXDmQAYDnQAZDoQA[DpQA]DqQA^DrQA_DsQA`DtQAaDuQAbDvQAcDwQAdDxQAeDyQAfDzQAgD{QAhD|QAmD}QAnEOQAoEPQApEQQAqERQArESQAsETQAtEUQBtEVQBuEWQBvEXQBwEYQBxEZQByE[QBzE]QB{E^QB|E_QB}E`QCOEaQCPEbQCQEcQCREdQCSEeQCTEfQCUEgQCVEhQCWEiQCXEjQCYEkQCZElQC[EmQC]EnQC^EoQC_EpQC`EqQCaErQCbEsQCcEtQCdEuQCeEvQCfEwQCgExQChEyQCiEzQCjE{QCkE|QClE}QCmFOQCnFPQCoFQQCpFRQCqFSQCrFTQCsFUQCtFVQCuFWQCvFXQCwFYQCxFZQCyF[QCzF]QC{F^QC|F_QC}F`QDOFaQDPFbQDQFcQDRFdQDSFeQDTFfQDUFgQDVFhQDWFiQDXFjQDYFkQDZFlQD[FmQD]FnQD^FoQD_FpQD`FqQDaFrQDbFsQDcFtQDdFuQDeFvQDfFwQDgFxQDhFyQDiFzQDjF{QDkF|QDlF}QDmGOQDnGPQDoGQQDpGRQDqGSQDrGTQDsGUQDtGVQDuGWQDvGXQDwGYQDxGZQDyG[QDzG]QD{G^QD|G_QEPG`QEQGaQERGbQESGcQETGdQEUGeQFUGfQFVGgQFWGhQFXGiQFYGjQFZGkQF[GlQF]GmQF^GnQF_GoQF`GpQFaGqQFbGrQFcGsQFdGtQFeGuQFfGvQFgGwQFhGxQFiGyQFjGzQFkG{QFlG|QFmG}QFnHOQFoHPQFpHQQFqHRQFrHSQFsHTQFtHUQFuHVQFvHWQFwHXQFxHYQFyHZQFzH[QF{H]QF|H^QF}H_QGOH`QGPHaQGQHbQGRHcQGSHdQGTHeQGUHfQGVHgQGWHhQGXHiQGYHjQGZHkQG[HlQG]HmQG^HnQG_HoQGbHpQGcHqQGdHrQGeHsQHeHtQHfHuQHgHvQHhHwQHiHxQHjHyQHkHzQHlH{QHmH|QHnH}QHoIOQHrIPRHsIQQoO!*ppZ[]^_`abcdefgimqvwxyz{|}!O!P!Q!R!S!T!`!y!{#O#P#Q#R#S#U#V#W#X#Y#Z#_#`#h#i#j#k#l#m#n#o#p#q#r#s#u$m$o$p$q$r$t$u$v$w$x$}%Q%R%^%_%`%a%b%c%d%e%f%{&T&U&V&W&X&Y&Z&d&e&f&g&h&i&j&y&z&{&|&}'R'S'T'U'V']'^'_'d'e'f'i'n'q'r's't'u'v'w'x'y'z'{'|'}(O(P(Q(R(S(T(U(V(W(X(Y(Z([(](^(_(`(a(b(c(d(e(f(g(l(m(n(o(p(q(r(s(t(u(v(w(x(y(z({(|(})O)P)Q)R)S)T)U)V)W)X)k)l)m)n)o)p)q)r)s)t)u)v)w)x)y)z){)|)}*O*P*Q*R*S*T*U*V*W*X*Y*Z*[*]*^*`*a*b*c*d*e*v*w*x*y*z*{*|*}+O+P+Q+R+S+T+m+n+o+p+q+r+s+t+u+v+w+x+y+z+{,^,_,`,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,{,|,}-O-P-Q-R-S-T-U-c-d-e-f-g-h-i-j-k.^._.`.a.b.c.d.e.f.g.h.i.j.k.l.m.n.o.p.q.r.s.t.u.v.w.x.y.z.{.|.}/O/P/W/X/Y/Z/[/]/^/_/`/u/v/w/x/y/z/{/|/}0O0P0Q0R0S0T0U0V0W0X0Y0Z0[0]0^0_0`0a0b0c0d0e0f0g0h0o0p0q0r0s0t0u0v0w1Y1Z1[1]1^1_1`1a1b1c1d1e1f1g1h1i1j1k1l1m1n1o1p1q1r1s1t1u1v1w1x1y1z1{2S2T2U2V2W2X2Y2Z2[2m2n2o2p2q2x2y2z2{3U3V3W3X3Y3Z3[3]3^3_3`3a3b3c3d3e3f3g3h3i3j3k3l3m3n3o3p3q3r3s3t3u3v3w3x3y3z3{3|3}4O4P4Q4R4S4T4U4V4W4X4Y4Z4[4]4^4_4`4a4b5P5R5S5T5`5a5b5c5d5e5f5g5h5i5o5q5r5s5t5u5v5w5x5y5z5{5|5}6O6P6Q6R6S6T6U6V6W6X6Y6Z6[6]6^6_6`6a6b6c6d6e6f6g6h6i6j6k6l6m6n6o6p6q6r6s6t6u6{6|6}7O7P7Q7T7U7V7W7X7Y7Z7[7]7^7_7`7a7b7c7d7e7f7g7h7i7j7k7l7m7n7o7p7q7r7s7t7u7v7w7x7y7z7{7|7}8O8P8Q8R8S8T8U8V8W8X8Y8Z8[8]8^8_8`8a8f8g8h8i8j8k8l8m8n8o8p8q8r8s8t8u8v8w8x8y8z8{8|8}9O9P9Q9R9S9T9U9V9W9X9Y9Z9[9]9^9_9`9a9b9c9d9e9f9g9h9i9j9k9l9m9n9o9p9q9r9s9t9u9v9w9x9y9z9{9|9}:O:P:Q:R:S:T:U:V:W:X:Y:Z:[:]:^:_:`:a:b:c:d:e:f:g:h:i:j:k:l:m:n:o:p;P;Q;a;b;x;y<Y<Z<j<k<}=O=P=Q=R=S=T=U=V=W=X=Y=Z=[=]=^=_=`=a=b=c=d=e=f=g=h=i=j=k=l=m=n=o=p=q=s=t=u=v=w>P>Q>R>S>T>U>V>W>X>Y>Z>[>]>^>a>b>c>d>e>f>g>h>i>j>k>l>m>n>o>p>q>r>s>t>u>v>w>x>y>z>{>|>}?O?P?Q?R?S?T?U?V?W?X?Y?Z?[?]?^?_?`?a?b?c?d?e?f?g?h?i?j?k?l?m?n?o?p?q?r?s?t?u?v?w?x?y?z?{?|?}@O@P@Q@R@S@T@U@V@W@X@Y@Z@[@]@^@_@`@a@b@c@d@e@f@g@h@i@j@k@l@m@n@o@p@q@r@s@t@u@v@w@x@y@z@{@|@}AOAPAQARASATAUAVAWAXAYAZA[A]A^A_A`AaAbAcAdAeAfAgAhAiAjAmAnAoApAqArAsAtAuAvAwAxAyAzA{A|A}BOBPBQBRBSBTBUBVBWBXBYBZB[B]B^B_B`BaBbBcBdBeBfBgBhBiBjBkBlBmBnBoBpBqBrBsBtBuBvBwBxByBzB{B|B}COCPCQCRCSCTCUCVCWCXCYCZC[C]C^C_C`CaCbCcCdCeCfCgChCiCjCkClCmCnCoCpCqCrCsCtCuCvCwCxCyCzC{C|C}DODPDQDRDSDTDUDVDWDXDYDZD[D]D^D_D`DaDbDcDdDeDfDgDhDiDjDkDlDmDnDoDpDqDrDsDtDuDvDwDxDyDzD{D|D}EOEPEQERESETEUEVEWEXEYEZE[E]E^E_E`EaEbEcEdEeEfEgEhEiEjEkElEmEnEoEpEqErEsEtEuEvEwExEyEzE{E|E}FOFPFQFRFSFTFUFVFWFXFYFZF[F]F^F_F`FaFbFcFdFeFfFgFhFiFjFkFlFmFnFoFpFqFrFsFtFuFvFwFxFyFzF{F|F}GOGPGQGRGSGTGUGVGWGXGYGZG[G]G^G_G`GaGbGcGdGeGfGgGhGiGjGkGlGmGnGoGpGqGrGsGtGuGvGwGxGyGzG{G|G}HOHPHQHRHSHTHUHVHWHXHYHZH[H]H^H_H`HaHbHcHdHeHfHgHhHiHjHkHlHmHnHoHpHqHrHsHtHuHvHwHxHyHzH{H|H}IOIPIQ[!^P!]<z<{<|>`S!xV!jQ%P#[t%U#c#e'O'P'a'b*f*g*h*i*j*k*l*m*n*o7R7SQ%}$aQ&P$fY&n%g8b8c8d8eR5j>_!*_nOPVZ[]^_`abcdefgimqvwxyz{}!O!P!Q!R!S!T!]!`!j!y!{#O#P#Q#R#S#U#V#W#X#Y#Z#[#_#`#c#e#h#i#j#k#l#n#o#p#q#r#s#u$a$f$m$o$p$q$r$t$u$v$w$x$}%Q%R%^%_%`%a%c%d%e%f%g%{&T&U&V&W&X&Y&Z&d&e&f&h&i&j&y&z&{&|&}'O'P'R'S'U'V']'^'_'a'b'd'f'i'q'r't'w'x'y'z'{'|'}(O(P(Q(R(S(U(W(X(Y(Z([(](^(_(`(a(b(c(d(e(f(g(l(m(n(o(p(q(r(s(t(u(v(w(x(y(z({(|(})O)P)Q)R)S)T)U)V)W)X)k)l)m)n)o)p)q)r)s)t)u)v)w)x)y)z){)|)}*O*P*Q*R*S*T*U*V*W*X*Z*^*`*a*b*c*d*e*f*g*h*i*j*k*l*m*n*o*v*w*x*y*z*{*}+P+Q+R+S+T+m+n+o+p+q+r+s+t+u+v+w+x+y+z+{,^,_,`,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,|-P-Q-S-c-d-e-f-g-h-j.^._.`.a.b.c.d.e.f.g.h.i.j.k.l.m.n.o.p.q.r.s.t.u.v.w.x.y.z.|/P/W/X/Y/Z/[/]/_/u/v/w/x/y/z/{/|/}0O0P0Q0R0S0T0U0V0W0X0Y0Z0[0]0^0_0`0a0b0c0e0h0o0p0q0r0s0t0v1Y1Z1[1]1^1_1`1a1b1c1d1e1f1g1h1i1j1k1l1m1n1o1p1q1r1s1t1u1v1x1{2S2T2U2V2W2X2Z2m2o2x2z3U3V3W3X3Y3Z3[3]3^3_3`3a3b3c3d3e3f3g3h3i3j3k3l3m3n3o3p3q3r3s3t3u3v3w3x3y3z3{3|3}4O4P4Q4R4S4T4U4V4W4X4Y4Z4[4]4^4_4`4a4b5P5R5S5T5`5a5b5c5d5e5f5g5h5i5o5q5r5s5t5u5v5w5x5y5z5{5|5}6O6P6Q6R6S6T6U6V6W6X6Y6Z6[6]6^6_6`6a6b6c6d6e6f6g6h6i6j6k6l6m6n6o6p6q6r6s6t6u6{6|6}7O7P7Q7R7S7T7U7V7W7X7Y7Z7[7]7^7_7`7a7b7c7d7e7f7g7h7i7j7k7l7m7n7o7p7q7r7s7t7u7v7w7x7y7z7{7|7}8O8P8Q8R8S8T8U8V8W8X8Y8Z8[8]8^8_8`8a8b8c8d8e8f8g8h8i8j8k8l8m8n8o8p8q8r8s8t8u8v8w8x8y8z8{8|8}9O9P9Q9R9S9T9U9V9W9X9Y9Z9[9]9^9_9`9a9b9c9d9e9f9g9h9i9j9k9l9m9n9o9p9q9r9s9t9u9v9w9x9y9z9{9|9}:O:P:Q:R:S:T:U:V:W:X:Y:Z:[:]:^:_:`:a:b:c:d:e:f:g:h:i:j:k:l:m:n:o:p;P;Q;a;b;x;y<Y<Z<j<k<z<{<|<}=O=P=Q=R=S=T=U=V=W=X=Y=Z=[=]=^=_=`=a=b=c=d=e=f=g=h=i=j=k=l=m=n=o=p=q=s=t=u=v=w>P>Q>R>S>T>U>V>W>X>Y>Z>[>]>^>_>`>a>b>c>d>e>f>g>h>i>j>k>l>m>n>o>p>q>r>s>t>u>v>w>x>y>z>{>|>}?O?P?Q?R?S?T?U?V?W?X?Y?Z?[?]?^?_?`?a?b?c?d?e?f?g?h?i?j?k?l?m?n?o?p?q?r?s?t?u?v?w?x?y?z?{?|?}@O@P@Q@R@S@T@U@V@W@X@Y@Z@[@]@^@_@`@a@b@c@d@e@f@g@h@i@j@k@l@m@n@o@p@q@r@s@t@u@v@w@x@y@z@{@|@}AOAPAQARASATAUAVAWAXAYAZA[A]A^A_A`AaAbAcAdAeAfAgAhAiAjAmAnAoApAqArAsAtAuAvAwAxAyAzA{A|A}BOBPBQBRBSBTBUBVBWBXBYBZB[B]B^B_B`BaBbBcBdBeBfBgBhBiBjBkBlBmBnBoBpBqBrBsBtBuBvBwBxByBzB{B|B}COCPCQCRCSCTCUCVCWCXCYCZC[C]C^C_C`CaCbCcCdCeCfCgChCiCjCkClCmCnCoCpCqCrCsCtCuCvCwCxCyCzC{C|C}DODPDQDRDSDTDUDVDWDXDYDZD[D]D^D_D`DaDbDcDdDeDfDgDhDiDjDkDlDmDnDoDpDqDrDsDtDuDvDwDxDyDzD{D|D}EOEPEQERESETEUEVEWEXEYEZE[E]E^E_E`EaEbEcEdEeEfEgEhEiEjEkElEmEnEoEpEqErEsEtEuEvEwExEyEzE{E|E}FOFPFQFRFSFTFUFVFWFXFYFZF[F]F^F_F`FaFbFcFdFeFfFgFhFiFjFkFlFmFnFoFpFqFrFsFtFuFvFwFxFyFzF{F|F}GOGPGQGRGSGTGUGVGWGXGYGZG[G]G^G_G`GaGbGcGdGeGfGgGhGiGjGkGlGmGnGoGpGqGrGsGtGuGvGwGxGyGzG{G|G}HOHPHQHRHSHTHUHVHWHXHYHZH[H]H^H_H`HaHbHcHdHeHfHgHhHiHjHkHlHmHnHoHpHqHrHsHtHuHvHwHxHyHzH{H|H}IOIPIQ!)znOPZ[]^_`abcdefgimqvwxyz{}!O!P!Q!R!S!T!]!`!y!{#O#P#Q#R#S#U#V#W#X#Y#Z#_#`#c#e#h#i#j#k#l#n#o#p#q#r#s#u$f$m$o$p$q$r$t$u$v$w$x$}%Q%R%^%_%`%a%c%d%e%f%{&T&U&V&W&X&Y&Z&d&e&f&h&i&j&y&z&{&|&}'O'P'R'S'U'V']'^'_'a'b'd'f'i'q'r't'w'x'y'z'{'|'}(O(P(Q(R(S(U(W(X(Y(Z([(](^(_(`(a(b(c(d(e(f(g(l(m(n(o(p(q(r(s(t(u(v(w(x(y(z({(|(})O)P)Q)R)S)T)U)V)W)X)k)l)m)n)o)p)q)r)s)t)u)v)w)x)y)z){)|)}*O*P*Q*R*S*T*U*V*W*X*Z*^*`*a*b*c*d*e*f*g*h*i*j*k*l*m*n*o*v*w*x*y*z*{*}+P+Q+R+S+T+m+n+o+p+q+r+s+t+u+v+w+x+y+z+{,^,_,`,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,|-P-Q-S-c-d-e-f-g-h-j.^._.`.a.b.c.d.e.f.g.h.i.j.k.l.m.n.o.p.q.r.s.t.u.v.w.x.y.z.|/P/W/X/Y/Z/[/]/_/u/v/w/x/y/z/{/|/}0O0P0Q0R0S0T0U0V0W0X0Y0Z0[0]0^0_0`0a0b0c0e0h0o0p0q0r0s0t0v1Y1Z1[1]1^1_1`1a1b1c1d1e1f1g1h1i1j1k1l1m1n1o1p1q1r1s1t1u1v1x1{2S2T2U2V2W2X2Z2m2o2x2z3U3V3W3X3Y3Z3[3]3^3_3`3a3b3c3d3e3f3g3h3i3j3k3l3m3n3o3p3q3r3s3t3u3v3w3x3y3z3{3|3}4O4P4Q4R4S4T4U4V4W4X4Y4Z4[4]4^4_4`4a4b5P5R5S5T5`5a5b5c5d5e5f5g5h5i5o5q5r5s5t5u5v5w5x5y5z5{5|5}6O6P6Q6R6S6T6U6V6W6X6Y6Z6[6]6^6_6`6a6b6c6d6e6f6g6h6i6j6k6l6m6n6o6p6q6r6s6t6u6{6|6}7O7P7Q7R7S7T7U7V7W7X7Y7Z7[7]7^7_7`7a7b7c7d7e7f7g7h7i7j7k7l7m7n7o7p7q7r7s7t7u7v7w7x7y7z7{7|7}8O8P8Q8R8S8T8U8V8W8X8Y8Z8[8]8^8_8`8a8f8g8h8i8j8k8l8m8n8o8p8q8r8s8t8u8v8w8x8y8z8{8|8}9O9P9Q9R9S9T9U9V9W9X9Y9Z9[9]9^9_9`9a9b9c9d9e9f9g9h9i9j9k9l9m9n9o9p9q9r9s9t9u9v9w9x9y9z9{9|9}:O:P:Q:R:S:T:U:V:W:X:Y:Z:[:]:^:_:`:a:b:c:d:e:f:g:h:i:j:k:l:m:n:o:p;P;Q;a;b;x;y<Y<Z<j<k<z<{<|<}=O=P=Q=R=S=T=U=V=W=X=Y=Z=[=]=^=_=`=a=b=c=d=e=f=g=h=i=j=k=l=m=n=o=p=q=s=t=u=v=w>P>Q>R>S>T>U>V>W>X>Y>Z>[>]>^>_>`>a>b>c>d>e>f>g>h>i>j>k>l>m>n>o>p>q>r>s>t>u>v>w>x>y>z>{>|>}?O?P?Q?R?S?T?U?V?W?X?Y?Z?[?]?^?_?`?a?b?c?d?e?f?g?h?i?j?k?l?m?n?o?p?q?r?s?t?u?v?w?x?y?z?{?|?}@O@P@Q@R@S@T@U@V@W@X@Y@Z@[@]@^@_@`@a@b@c@d@e@f@g@h@i@j@k@l@m@n@o@p@q@r@s@t@u@v@w@x@y@z@{@|@}AOAPAQARASATAUAVAWAXAYAZA[A]A^A_A`AaAbAcAdAeAfAgAhAiAjAmAnAoApAqArAsAtAuAvAwAxAyAzA{A|A}BOBPBQBRBSBTBUBVBWBXBYBZB[B]B^B_B`BaBbBcBdBeBfBgBhBiBjBkBlBmBnBoBpBqBrBsBtBuBvBwBxByBzB{B|B}COCPCQCRCSCTCUCVCWCXCYCZC[C]C^C_C`CaCbCcCdCeCfCgChCiCjCkClCmCnCoCpCqCrCsCtCuCvCwCxCyCzC{C|C}DODPDQDRDSDTDUDVDWDXDYDZD[D]D^D_D`DaDbDcDdDeDfDgDhDiDjDkDlDmDnDoDpDqDrDsDtDuDvDwDxDyDzD{D|D}EOEPEQERESETEUEVEWEXEYEZE[E]E^E_E`EaEbEcEdEeEfEgEhEiEjEkElEmEnEoEpEqErEsEtEuEvEwExEyEzE{E|E}FOFPFQFRFSFTFUFVFWFXFYFZF[F]F^F_F`FaFbFcFdFeFfFgFhFiFjFkFlFmFnFoFpFqFrFsFtFuFvFwFxFyFzF{F|F}GOGPGQGRGSGTGUGVGWGXGYGZG[G]G^G_G`GaGbGcGdGeGfGgGhGiGjGkGlGmGnGoGpGqGrGsGtGuGvGwGxGyGzG{G|G}HOHPHQHRHSHTHUHVHWHXHYHZH[H]H^H_H`HaHbHcHdHeHfHgHhHiHjHkHlHmHnHoHpHqHrHsHtHuHvHwHxHyHzH{H|H}IOIPIQ`!n!v#x$h${%n%p%z&sc!oV!j#[$a%g8b8c8d8eQoO!*lpZ[]^_`abcdefgimqvwxyz{|}!O!P!Q!R!S!T!`!y!{#O#P#Q#R#S#U#V#W#X#Y#Z#_#`#h#i#j#k#l#m#n#o#p#q#r#s#u$m$o$p$q$r$t$u$v$w$x%Q%R%^%_%`%a%b%c%d%e%f&T&U&V&W&X&Y&Z&d&e&f&g&h&i&j&y&z&{&|&}'R'S'T'U'V']'^'_'d'e'f'i'n'q'r's't'u'v'w'x'y'z'{'|'}(O(P(Q(R(S(T(U(V(W(X(Y(Z([(](^(_(`(a(b(c(d(e(f(g(l(m(n(o(p(q(r(s(t(u(v(w(x(y(z({(|(})O)P)Q)R)S)T)U)V)W)X)k)l)m)n)o)p)q)r)s)t)u)v)w)x)y)z){)|)}*O*P*Q*R*S*T*U*V*W*X*Y*Z*[*]*^*`*a*b*c*d*e*v*w*x*y*z*{*|*}+O+P+Q+R+S+T+m+n+o+p+q+r+s+t+u+v+w+x+y+z+{,^,_,`,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,{,|,}-O-P-Q-R-S-T-U-c-d-e-f-g-h-i-j-k.^._.`.a.b.c.d.e.f.g.h.i.j.k.l.m.n.o.p.q.r.s.t.u.v.w.x.y.z.{.|.}/O/P/W/X/Y/Z/[/]/^/_/`/u/v/w/x/y/z/{/|/}0O0P0Q0R0S0T0U0V0W0X0Y0Z0[0]0^0_0`0a0b0c0d0e0f0g0h0o0p0q0r0s0t0u0v0w1Y1Z1[1]1^1_1`1a1b1c1d1e1f1g1h1i1j1k1l1m1n1o1p1q1r1s1t1u1v1w1x1y1z1{2S2T2U2V2W2X2Y2Z2[2m2n2o2p2q2x2y2z2{3U3V3W3X3Y3Z3[3]3^3_3`3a3b3c3d3e3f3g3h3i3j3k3l3m3n3o3p3q3r3s3t3u3v3w3x3y3z3{3|3}4O4P4Q4R4S4T4U4V4W4X4Y4Z4[4]4^4_4`4a4b5P5R5S5T5`5a5b5c5d5e5f5g5h5i5o5q5r5s5t5u5v5w5x5y5z5{5|5}6O6P6Q6R6S6T6U6V6W6X6Y6Z6[6]6^6_6`6a6b6c6d6e6f6g6h6i6j6k6l6m6n6o6p6q6r6s6t6u6{6|6}7O7P7Q7T7U7V7W7X7Y7Z7[7]7^7_7`7a7b7c7d7e7f7g7h7i7j7k7l7m7n7o7p7q7r7s7t7u7v7w7x7y7z7{7|7}8O8P8Q8R8S8T8U8V8W8X8Y8Z8[8]8^8_8`8a8f8g8h8i8j8k8l8m8n8o8p8q8r8s8t8u8v8w8x8y8z8{8|8}9O9P9Q9R9S9T9U9V9W9X9Y9Z9[9]9^9_9`9a9b9c9d9e9f9g9h9i9j9k9l9m9n9o9p9q9r9s9t9u9v9w9x9y9z9{9|9}:O:P:Q:R:S:T:U:V:W:X:Y:Z:[:]:^:_:`:a:b:c:d:e:f:g:h:i:j:k:l:m:n:o:p;P;Q;a;b;x;y<Y<Z<j<k<}=O=P=Q=R=S=T=U=V=W=X=Y=Z=[=]=^=_=`=a=b=c=d=e=f=g=h=i=j=k=l=m=n=o=p=q=s=t=u=v=w>P>Q>R>S>T>U>V>W>X>Y>Z>[>]>^>a>b>c>d>e>f>g>h>i>j>k>l>m>n>o>p>q>r>s>t>u>v>w>x>y>z>{>|>}?O?P?Q?R?S?T?U?V?W?X?Y?Z?[?]?^?_?`?a?b?c?d?e?f?g?h?i?j?k?l?m?n?o?p?q?r?s?t?u?v?w?x?y?z?{?|?}@O@P@Q@R@S@T@U@V@W@X@Y@Z@[@]@^@_@`@a@b@c@d@e@f@g@h@i@j@k@l@m@n@o@p@q@r@s@t@u@v@w@x@y@z@{@|@}AOAPAQARASATAUAVAWAXAYAZA[A]A^A_A`AaAbAcAdAeAfAgAhAiAjAmAnAoApAqArAsAtAuAvAwAxAyAzA{A|A}BOBPBQBRBSBTBUBVBWBXBYBZB[B]B^B_B`BaBbBcBdBeBfBgBhBiBjBkBlBmBnBoBpBqBrBsBtBuBvBwBxByBzB{B|B}COCPCQCRCSCTCUCVCWCXCYCZC[C]C^C_C`CaCbCcCdCeCfCgChCiCjCkClCmCnCoCpCqCrCsCtCuCvCwCxCyCzC{C|C}DODPDQDRDSDTDUDVDWDXDYDZD[D]D^D_D`DaDbDcDdDeDfDgDhDiDjDkDlDmDnDoDpDqDrDsDtDuDvDwDxDyDzD{D|D}EOEPEQERESETEUEVEWEXEYEZE[E]E^E_E`EaEbEcEdEeEfEgEhEiEjEkElEmEnEoEpEqErEsEtEuEvEwExEyEzE{E|E}FOFPFQFRFSFTFUFVFWFXFYFZF[F]F^F_F`FaFbFcFdFeFfFgFhFiFjFkFlFmFnFoFpFqFrFsFtFuFvFwFxFyFzF{F|F}GOGPGQGRGSGTGUGVGWGXGYGZG[G]G^G_G`GaGbGcGdGeGfGgGhGiGjGkGlGmGnGoGpGqGrGsGtGuGvGwGxGyGzG{G|G}HOHPHQHRHSHTHUHVHWHXHYHZH[H]H^H_H`HaHbHcHdHeHfHgHhHiHjHkHlHmHnHoHpHqHrHsHtHuHvHwHxHyHzH{H|H}IOIPIQU!_P!]<zS!xV!jW$|#[$a$}%{t%U#c#e'O'P'a'b*f*g*h*i*j*k*l*m*n*o7R7SQ&P$fY&l%g8b8c8d8eQ5k>_Q5l<{Q5m>`R5n<|!*_WOPVZ[]^_`abcdefgimqvwxyz{}!O!P!Q!R!S!T!]!`!j!y!{#O#P#Q#R#S#U#V#W#X#Y#Z#[#_#`#c#e#h#i#j#k#l#n#o#p#q#r#s#u$a$f$m$o$p$q$r$t$u$v$w$x$}%Q%R%^%_%`%a%c%d%e%f%g%{&T&U&V&W&X&Y&Z&d&e&f&h&i&j&y&z&{&|&}'O'P'R'S'U'V']'^'_'a'b'd'f'i'q'r't'w'x'y'z'{'|'}(O(P(Q(R(S(U(W(X(Y(Z([(](^(_(`(a(b(c(d(e(f(g(l(m(n(o(p(q(r(s(t(u(v(w(x(y(z({(|(})O)P)Q)R)S)T)U)V)W)X)k)l)m)n)o)p)q)r)s)t)u)v)w)x)y)z){)|)}*O*P*Q*R*S*T*U*V*W*X*Z*^*`*a*b*c*d*e*f*g*h*i*j*k*l*m*n*o*v*w*x*y*z*{*}+P+Q+R+S+T+m+n+o+p+q+r+s+t+u+v+w+x+y+z+{,^,_,`,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,|-P-Q-S-c-d-e-f-g-h-j.^._.`.a.b.c.d.e.f.g.h.i.j.k.l.m.n.o.p.q.r.s.t.u.v.w.x.y.z.|/P/W/X/Y/Z/[/]/_/u/v/w/x/y/z/{/|/}0O0P0Q0R0S0T0U0V0W0X0Y0Z0[0]0^0_0`0a0b0c0e0h0o0p0q0r0s0t0v1Y1Z1[1]1^1_1`1a1b1c1d1e1f1g1h1i1j1k1l1m1n1o1p1q1r1s1t1u1v1x1{2S2T2U2V2W2X2Z2m2o2x2z3U3V3W3X3Y3Z3[3]3^3_3`3a3b3c3d3e3f3g3h3i3j3k3l3m3n3o3p3q3r3s3t3u3v3w3x3y3z3{3|3}4O4P4Q4R4S4T4U4V4W4X4Y4Z4[4]4^4_4`4a4b5P5R5S5T5`5a5b5c5d5e5f5g5h5i5o5q5r5s5t5u5v5w5x5y5z5{5|5}6O6P6Q6R6S6T6U6V6W6X6Y6Z6[6]6^6_6`6a6b6c6d6e6f6g6h6i6j6k6l6m6n6o6p6q6r6s6t6u6{6|6}7O7P7Q7R7S7T7U7V7W7X7Y7Z7[7]7^7_7`7a7b7c7d7e7f7g7h7i7j7k7l7m7n7o7p7q7r7s7t7u7v7w7x7y7z7{7|7}8O8P8Q8R8S8T8U8V8W8X8Y8Z8[8]8^8_8`8a8b8c8d8e8f8g8h8i8j8k8l8m8n8o8p8q8r8s8t8u8v8w8x8y8z8{8|8}9O9P9Q9R9S9T9U9V9W9X9Y9Z9[9]9^9_9`9a9b9c9d9e9f9g9h9i9j9k9l9m9n9o9p9q9r9s9t9u9v9w9x9y9z9{9|9}:O:P:Q:R:S:T:U:V:W:X:Y:Z:[:]:^:_:`:a:b:c:d:e:f:g:h:i:j:k:l:m:n:o:p;P;Q;a;b;x;y<Y<Z<j<k<z<{<|<}=O=P=Q=R=S=T=U=V=W=X=Y=Z=[=]=^=_=`=a=b=c=d=e=f=g=h=i=j=k=l=m=n=o=p=q=s=t=u=v=w>P>Q>R>S>T>U>V>W>X>Y>Z>[>]>^>_>`>a>b>c>d>e>f>g>h>i>j>k>l>m>n>o>p>q>r>s>t>u>v>w>x>y>z>{>|>}?O?P?Q?R?S?T?U?V?W?X?Y?Z?[?]?^?_?`?a?b?c?d?e?f?g?h?i?j?k?l?m?n?o?p?q?r?s?t?u?v?w?x?y?z?{?|?}@O@P@Q@R@S@T@U@V@W@X@Y@Z@[@]@^@_@`@a@b@c@d@e@f@g@h@i@j@k@l@m@n@o@p@q@r@s@t@u@v@w@x@y@z@{@|@}AOAPAQARASATAUAVAWAXAYAZA[A]A^A_A`AaAbAcAdAeAfAgAhAiAjAmAnAoApAqArAsAtAuAvAwAxAyAzA{A|A}BOBPBQBRBSBTBUBVBWBXBYBZB[B]B^B_B`BaBbBcBdBeBfBgBhBiBjBkBlBmBnBoBpBqBrBsBtBuBvBwBxByBzB{B|B}COCPCQCRCSCTCUCVCWCXCYCZC[C]C^C_C`CaCbCcCdCeCfCgChCiCjCkClCmCnCoCpCqCrCsCtCuCvCwCxCyCzC{C|C}DODPDQDRDSDTDUDVDWDXDYDZD[D]D^D_D`DaDbDcDdDeDfDgDhDiDjDkDlDmDnDoDpDqDrDsDtDuDvDwDxDyDzD{D|D}EOEPEQERESETEUEVEWEXEYEZE[E]E^E_E`EaEbEcEdEeEfEgEhEiEjEkElEmEnEoEpEqErEsEtEuEvEwExEyEzE{E|E}FOFPFQFRFSFTFUFVFWFXFYFZF[F]F^F_F`FaFbFcFdFeFfFgFhFiFjFkFlFmFnFoFpFqFrFsFtFuFvFwFxFyFzF{F|F}GOGPGQGRGSGTGUGVGWGXGYGZG[G]G^G_G`GaGbGcGdGeGfGgGhGiGjGkGlGmGnGoGpGqGrGsGtGuGvGwGxGyGzG{G|G}HOHPHQHRHSHTHUHVHWHXHYHZH[H]H^H_H`HaHbHcHdHeHfHgHhHiHjHkHlHmHnHoHpHqHrHsHtHuHvHwHxHyHzH{H|H}IOIPIQQ!{hQ#_j^%S#^*_6v6w6x6y6zQ(l4cQ(m4dQ(n4eQ(o4fQ(p4gQ(q4hQ(r4iQ(s4jQ(t4kQ(u4lQ(v4mQ(w4nQ(x4oQ(y4pQ(z4qQ({4rQ(|4sQ(}4tQ)O4uQ)P4vQ)Q4wQ)R4xQ)S4yQ)T4zQ)U4{Q)V4|Q)W4}Q)X5OQ*`5QQ6Q=rQ6{=xQ6|=yQ6}=zQ7O={Q7P=|Q:oAkR:pAl!+QnOPVZ[]^_`abcdefgimqvwxyz{|}!O!P!Q!R!S!T!]!`!j!y!{#O#P#Q#R#S#U#V#W#X#Y#Z#[#_#`#c#e#h#i#j#k#l#m#n#o#p#q#r#u$a$f$m$o$p$q$r$t$u$v$w$x$}%Q%R%^%_%`%a%b%c%d%e%f%g%{&T&U&V&W&X&Y&Z&d&e&f&g&h&i&j&y&z&{&|&}'O'P'R'S'T'U'V']'^'_'a'b'd'e'f'i'n'q's't'u'w'x'y'z'{'|'}(O(P(Q(R(S(T(U(W(X(Y(Z([(](^(_(`(a(b(c(d(e(f(g(l(m(n(o(p(q(r(s(t(u(v(w(x(y(z({(|(})O)P)Q)R)S)T)U)V)W)X)k)l)m)n)o)p)q)r)s)t)u)v)w)x)y)z){)|)}*O*P*Q*R*S*T*U*V*W*Y*Z*[*^*`*a*b*c*d*e*f*g*h*i*j*k*l*m*n*o*v*w*x*y*z*{*|*}+P+Q+R+S+T+m+n+o+p+q+r+s+t+u+v+w+x+y+z+{,^,_,`,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,{,|,}-P-R-S-T-c-d-e-f-g-h-i-j.^._.`.a.b.c.d.e.f.g.h.i.j.k.l.m.n.o.p.q.r.s.t.u.v.w.x.y.{.|.}/P/W/X/Y/Z/[/]/^/_/u/v/w/x/y/z/{/|/}0O0P0Q0R0S0T0U0V0W0X0Y0Z0[0]0^0_0`0a0b0d0e0f0h0o0p0q0r0s0t0u0v1Y1Z1[1]1^1_1`1a1b1c1d1e1f1g1h1i1j1k1l1m1n1o1p1q1r1s1t1u1w1x1y1{2S2T2U2V2W2X2Y2Z2n2o2p2x2y2z3U3V3W3X3Y3Z3[3]3^3_3`3a3b3c3d3e3f3g3h3i3j3k3l3m3n3o3p3q3r3s3t3u3v3w3x3y3z3{3|3}4O4P4Q4R4S4T4U4V4W4X4Y4Z4[4]4^4_4`4a4b5P5R5S5T5`5a5b5c5d5e5f5g5h5i5o5q5r5s5t5u5v5w5x5y5z5{5|5}6O6P6Q6R6S6T6U6V6W6X6Y6Z6[6]6^6_6`6a6b6c6d6e6f6g6h6i6j6k6l6m6n6o6p6q6r6s6t6u6{6|6}7O7P7Q7R7S7T7U7V7W7X7Y7Z7[7]7^7c7d7e7f7g7h7i7j7k7l7m7n7o7p7q7r7s7t7u7v7w7x7y7z7{7|7}8O8P8Q8R8S8T8U8V8W8X8Y8Z8[8]8^8_8`8a8b8c8d8e8f8g8h8i8j8k8l8m8n8o8p8q8r8s8t8u8v8w8x8y8z8{8|8}9O9P9Q9R9S9T9U9V9W9X9Y9Z9[9]9^9_9`9a9b9c9d9e9f9g9h9i9j9k9l9m9n9o9p9q9r9s9t9u9v9w9x9y9z9{9|9}:O:P:Q:R:S:T:U:V:W:X:Y:Z:[:]:^:_:`:a:b:c:d:e:f:g:h:i:j:k:l:m:n:o:p;P;Q;a;b;x;y<Y<Z<j<k<z<{<|<}=O=P=Q=R=S=T=U=V=W=X=Y=Z=[=]=^=_=`=a=b=c=d=e=f=g=h=i=j=k=l=m=n=o=p=q=s=t=u=v=w>P>Q>R>S>T>U>V>W>X>Y>Z>[>]>^>_>`>a>b>c>d>e>f>g>h>i>j>k>l>m>n>o>p>q>r>s>t>u>v>w>x>y>z>{>|>}?O?P?Q?R?S?T?U?V?W?X?Y?Z?[?]?^?_?`?a?b?c?d?e?f?g?h?i?j?k?l?m?n?o?p?q?r?s?t?u?v?w?x?y?z?{?|?}@O@P@Q@R@S@T@U@V@W@X@Y@Z@[@]@^@_@`@a@b@c@d@e@f@g@h@i@j@k@l@m@n@o@p@q@r@s@t@u@v@w@x@y@z@{@|@}AOAPAQARASATAUAVAWAXAYAZA[A]A^A_A`AaAbAcAdAeAfAgAhAiAjAmAnAoApAqArAsAtAuAvAwAxAyAzA{A|A}BOBPBQBRBSBTBUBVBWBXBYBZB[B]B^B_B`BaBbBcBdBeBfBgBhBiBjBkBlBmBnBoBpBqBrBsBtBuBvBwBxByBzB{B|B}COCPCQCRCSCTCUCVCWCXCYCZC[C]C^C_C`CaCbCcCdCeCfCgChCiCjCkClCmCnCoCpCqCrCsCtCuCvCwCxCyCzC{C|C}DODPDQDRDSDTDUDVDWDXDYDZD[D]D^D_D`DaDbDcDdDeDfDgDhDiDjDkDlDmDnDoDpDqDrDsDtDuDvDwDxDyDzD{D|D}EOEPEQERESETEUEVEWEXEYEZE[E]E^E_E`EaEbEcEdEeEfEgEhEiEjEkElEmEnEoEpEqErEsEtEuEvEwExEyEzE{E|E}FOFPFQFRFSFTFUFVFWFXFYFZF[F]F^F_F`FaFbFcFdFeFfFgFhFiFjFkFlFmFnFoFpFqFrFsFtFuFvFwFxFyFzF{F|F}GOGPGQGRGSGTGUGVGWGXGYGZG[G]G^G_G`GaGbGcGdGeGfGgGhGiGjGkGlGmGnGoGpGqGrGsGtGuGvGwGxGyGzG{G|G}HOHPHQHRHSHTHUHVHWHXHYHZH[H]H^H_H`HaHbHcHdHeHfHgHhHiHjHkHlHmHnHoHpHqHrHsHtHuHvHwHxHyHzH{H|H}IOIPIQ#O#]hj#^*_4c4d4e4f4g4h4i4j4k4l4m4n4o4p4q4r4s4t4u4v4w4x4y4z4{4|4}5O5Q6v6w6x6y6z=r=x=y=z={=|AkAlQ%i#sQ-p7_Q-q7`Q-r7aR-s7ba!pV!j#[%g8b8c8d8e`!kV!j#[%g8b8c8d8eR%p#xW!uV!j!v$h`$z#[#x$a${%n%p%z&sZ&k%g8b8c8d8eS!VO!Ws!nV!j!v#[#x$a$h${%g%n%p%z&s8b8c8d8ewUOV!Z!j!v#[#x$a$h${%g%n%p%z&s8b8c8d8eQ$X!eR%y$`Q%v$XR&u%y#O#]hj#^*_4c4d4e4f4g4h4i4j4k4l4m4n4o4p4q4r4s4t4u4v4w4x4y4z4{4|4}5O5Q6v6w6x6y6z=r=x=y=z={=|AkAlZ%j#s7_7`7a7b!*|nOPZ[]^_`abcdefgimqvwxyz{|}!O!P!Q!R!S!T!]!`!y!{#O#P#Q#R#S#U#V#W#X#Y#Z#[#_#`#c#e#h#i#j#k#l#m#n#o#p#q#r#s#u$a$f$m$o$p$q$r$t$u$v$w$x$}%Q%R%^%_%`%a%b%c%d%e%f%{&T&U&V&W&X&Y&Z&d&e&f&g&h&i&j&y&z&{&|&}'O'P'R'S'T'U'V']'^'_'a'b'd'e'f'i'n'q's't'u'w'x'y'z'{'|'}(O(P(Q(R(S(T(U(W(X(Y(Z([(](^(_(`(a(b(c(d(e(f(g(l(m(n(o(p(q(r(s(t(u(v(w(x(y(z({(|(})O)P)Q)R)S)T)U)V)W)X)k)l)m)n)o)p)q)r)s)t)u)v)w)x)y)z){)|)}*O*P*Q*R*S*T*U*V*W*Y*Z*[*^*`*a*b*c*d*e*f*g*h*i*j*k*l*m*n*o*v*w*x*y*z*{*|*}+P+Q+R+S+T+m+n+o+p+q+r+s+t+u+v+w+x+y+z+{,^,_,`,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,{,|,}-P-R-S-T-c-d-e-f-g-h-i-j.^._.`.a.b.c.d.e.f.g.h.i.j.k.l.m.n.o.p.q.r.s.t.u.v.w.x.y.{.|.}/P/W/X/Y/Z/[/]/^/_/u/v/w/x/y/z/{/|/}0O0P0Q0R0S0T0U0V0W0X0Y0Z0[0]0^0_0`0a0b0d0e0f0h0o0p0q0r0s0t0u0v1Y1Z1[1]1^1_1`1a1b1c1d1e1f1g1h1i1j1k1l1m1n1o1p1q1r1s1t1u1w1x1y1{2S2T2U2V2W2X2Y2Z2n2o2p2x2y2z3U3V3W3X3Y3Z3[3]3^3_3`3a3b3c3d3e3f3g3h3i3j3k3l3m3n3o3p3q3r3s3t3u3v3w3x3y3z3{3|3}4O4P4Q4R4S4T4U4V4W4X4Y4Z4[4]4^4_4`4a4b5P5R5S5T5`5a5b5c5d5e5f5g5h5i5o5q5r5s5t5u5v5w5x5y5z5{5|5}6O6P6Q6R6S6T6U6V6W6X6Y6Z6[6]6^6_6`6a6b6c6d6e6f6g6h6i6j6k6l6m6n6o6p6q6r6s6t6u6{6|6}7O7P7Q7R7S7T7U7V7W7X7Y7Z7[7]7^7_7`7a7b7c7d7e7f7g7h7i7j7k7l7m7n7o7p7q7r7s7t7u7v7w7x7y7z7{7|7}8O8P8Q8R8S8T8U8V8W8X8Y8Z8[8]8^8_8`8a8f8g8h8i8j8k8l8m8n8o8p8q8r8s8t8u8v8w8x8y8z8{8|8}9O9P9Q9R9S9T9U9V9W9X9Y9Z9[9]9^9_9`9a9b9c9d9e9f9g9h9i9j9k9l9m9n9o9p9q9r9s9t9u9v9w9x9y9z9{9|9}:O:P:Q:R:S:T:U:V:W:X:Y:Z:[:]:^:_:`:a:b:c:d:e:f:g:h:i:j:k:l:m:n:o:p;P;Q;a;b;x;y<Y<Z<j<k<z<{<|<}=O=P=Q=R=S=T=U=V=W=X=Y=Z=[=]=^=_=`=a=b=c=d=e=f=g=h=i=j=k=l=m=n=o=p=q=s=t=u=v=w>P>Q>R>S>T>U>V>W>X>Y>Z>[>]>^>_>`>a>b>c>d>e>f>g>h>i>j>k>l>m>n>o>p>q>r>s>t>u>v>w>x>y>z>{>|>}?O?P?Q?R?S?T?U?V?W?X?Y?Z?[?]?^?_?`?a?b?c?d?e?f?g?h?i?j?k?l?m?n?o?p?q?r?s?t?u?v?w?x?y?z?{?|?}@O@P@Q@R@S@T@U@V@W@X@Y@Z@[@]@^@_@`@a@b@c@d@e@f@g@h@i@j@k@l@m@n@o@p@q@r@s@t@u@v@w@x@y@z@{@|@}AOAPAQARASATAUAVAWAXAYAZA[A]A^A_A`AaAbAcAdAeAfAgAhAiAjAmAnAoApAqArAsAtAuAvAwAxAyAzA{A|A}BOBPBQBRBSBTBUBVBWBXBYBZB[B]B^B_B`BaBbBcBdBeBfBgBhBiBjBkBlBmBnBoBpBqBrBsBtBuBvBwBxByBzB{B|B}COCPCQCRCSCTCUCVCWCXCYCZC[C]C^C_C`CaCbCcCdCeCfCgChCiCjCkClCmCnCoCpCqCrCsCtCuCvCwCxCyCzC{C|C}DODPDQDRDSDTDUDVDWDXDYDZD[D]D^D_D`DaDbDcDdDeDfDgDhDiDjDkDlDmDnDoDpDqDrDsDtDuDvDwDxDyDzD{D|D}EOEPEQERESETEUEVEWEXEYEZE[E]E^E_E`EaEbEcEdEeEfEgEhEiEjEkElEmEnEoEpEqErEsEtEuEvEwExEyEzE{E|E}FOFPFQFRFSFTFUFVFWFXFYFZF[F]F^F_F`FaFbFcFdFeFfFgFhFiFjFkFlFmFnFoFpFqFrFsFtFuFvFwFxFyFzF{F|F}GOGPGQGRGSGTGUGVGWGXGYGZG[G]G^G_G`GaGbGcGdGeGfGgGhGiGjGkGlGmGnGoGpGqGrGsGtGuGvGwGxGyGzG{G|G}HOHPHQHRHSHTHUHVHWHXHYHZH[H]H^H_H`HaHbHcHdHeHfHgHhHiHjHkHlHmHnHoHpHqHrHsHtHuHvHwHxHyHzH{H|H}IOIPIQ^!qV!j%g8b8c8d8eQ!u!vS$b!r$dR&Q$h!+^nOPZ[]^_`abcdefgimqvwxyz{|}!O!P!Q!R!S!T!]!`!y!{#O#P#Q#R#S#U#V#W#X#Y#Z#[#_#`#c#e#h#i#j#k#l#m#n#o#p#q#r#s#u$a$f$m$o$p$q$r$t$u$v$w$x$}%Q%R%^%_%`%a%b%c%d%e%f%{&T&U&V&W&X&Y&Z&d&e&f&g&h&i&j&y&z&{&|&}'O'P'R'S'T'U'V']'^'_'a'b'd'e'f'i'n'q'r's't'u'w'x'y'z'{'|'}(O(P(Q(R(S(T(U(W(X(Y(Z([(](^(_(`(a(b(c(d(e(f(g(l(m(n(o(p(q(r(s(t(u(v(w(x(y(z({(|(})O)P)Q)R)S)T)U)V)W)X)k)l)m)n)o)p)q)r)s)t)u)v)w)x)y)z){)|)}*O*P*Q*R*S*T*U*V*W*X*Y*Z*[*^*`*a*b*c*d*e*f*g*h*i*j*k*l*m*n*o*v*w*x*y*z*{*|*}+P+Q+R+S+T+m+n+o+p+q+r+s+t+u+v+w+x+y+z+{,^,_,`,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,{,|,}-P-Q-R-S-T-c-d-e-f-g-h-i-j.^._.`.a.b.c.d.e.f.g.h.i.j.k.l.m.n.o.p.q.r.s.t.u.v.w.x.y.z.{.|.}/P/W/X/Y/Z/[/]/^/_/u/v/w/x/y/z/{/|/}0O0P0Q0R0S0T0U0V0W0X0Y0Z0[0]0^0_0`0a0b0c0d0e0f0h0o0p0q0r0s0t0u0v1Y1Z1[1]1^1_1`1a1b1c1d1e1f1g1h1i1j1k1l1m1n1o1p1q1r1s1t1u1v1w1x1y1{2S2T2U2V2W2X2Y2Z2m2n2o2p2x2y2z3U3V3W3X3Y3Z3[3]3^3_3`3a3b3c3d3e3f3g3h3i3j3k3l3m3n3o3p3q3r3s3t3u3v3w3x3y3z3{3|3}4O4P4Q4R4S4T4U4V4W4X4Y4Z4[4]4^4_4`4a4b5P5R5S5T5`5a5b5c5d5e5f5g5h5i5o5q5r5s5t5u5v5w5x5y5z5{5|5}6O6P6Q6R6S6T6U6V6W6X6Y6Z6[6]6^6_6`6a6b6c6d6e6f6g6h6i6j6k6l6m6n6o6p6q6r6s6t6u6{6|6}7O7P7Q7R7S7T7U7V7W7X7Y7Z7[7]7^7_7`7a7b7c7d7e7f7g7h7i7j7k7l7m7n7o7p7q7r7s7t7u7v7w7x7y7z7{7|7}8O8P8Q8R8S8T8U8V8W8X8Y8Z8[8]8^8_8`8a8f8g8h8i8j8k8l8m8n8o8p8q8r8s8t8u8v8w8x8y8z8{8|8}9O9P9Q9R9S9T9U9V9W9X9Y9Z9[9]9^9_9`9a9b9c9d9e9f9g9h9i9j9k9l9m9n9o9p9q9r9s9t9u9v9w9x9y9z9{9|9}:O:P:Q:R:S:T:U:V:W:X:Y:Z:[:]:^:_:`:a:b:c:d:e:f:g:h:i:j:k:l:m:n:o:p;P;Q;a;b;x;y<Y<Z<j<k<z<{<|<}=O=P=Q=R=S=T=U=V=W=X=Y=Z=[=]=^=_=`=a=b=c=d=e=f=g=h=i=j=k=l=m=n=o=p=q=s=t=u=v=w>P>Q>R>S>T>U>V>W>X>Y>Z>[>]>^>_>`>a>b>c>d>e>f>g>h>i>j>k>l>m>n>o>p>q>r>s>t>u>v>w>x>y>z>{>|>}?O?P?Q?R?S?T?U?V?W?X?Y?Z?[?]?^?_?`?a?b?c?d?e?f?g?h?i?j?k?l?m?n?o?p?q?r?s?t?u?v?w?x?y?z?{?|?}@O@P@Q@R@S@T@U@V@W@X@Y@Z@[@]@^@_@`@a@b@c@d@e@f@g@h@i@j@k@l@m@n@o@p@q@r@s@t@u@v@w@x@y@z@{@|@}AOAPAQARASATAUAVAWAXAYAZA[A]A^A_A`AaAbAcAdAeAfAgAhAiAjAmAnAoApAqArAsAtAuAvAwAxAyAzA{A|A}BOBPBQBRBSBTBUBVBWBXBYBZB[B]B^B_B`BaBbBcBdBeBfBgBhBiBjBkBlBmBnBoBpBqBrBsBtBuBvBwBxByBzB{B|B}COCPCQCRCSCTCUCVCWCXCYCZC[C]C^C_C`CaCbCcCdCeCfCgChCiCjCkClCmCnCoCpCqCrCsCtCuCvCwCxCyCzC{C|C}DODPDQDRDSDTDUDVDWDXDYDZD[D]D^D_D`DaDbDcDdDeDfDgDhDiDjDkDlDmDnDoDpDqDrDsDtDuDvDwDxDyDzD{D|D}EOEPEQERESETEUEVEWEXEYEZE[E]E^E_E`EaEbEcEdEeEfEgEhEiEjEkElEmEnEoEpEqErEsEtEuEvEwExEyEzE{E|E}FOFPFQFRFSFTFUFVFWFXFYFZF[F]F^F_F`FaFbFcFdFeFfFgFhFiFjFkFlFmFnFoFpFqFrFsFtFuFvFwFxFyFzF{F|F}GOGPGQGRGSGTGUGVGWGXGYGZG[G]G^G_G`GaGbGcGdGeGfGgGhGiGjGkGlGmGnGoGpGqGrGsGtGuGvGwGxGyGzG{G|G}HOHPHQHRHSHTHUHVHWHXHYHZH[H]H^H_H`HaHbHcHdHeHfHgHhHiHjHkHlHmHnHoHpHqHrHsHtHuHvHwHxHyHzH{H|H}IOIPIQ^!qV!j%g8b8c8d8eQ!u!vS$b!r$dR&Q$h!*|nOPZ[]^_`abcdefgimqvwxyz{|}!O!P!Q!R!S!T!]!`!y!{#O#P#Q#R#S#U#V#W#X#Y#Z#[#_#`#c#e#h#i#j#k#l#m#n#o#p#q#r#s#u$a$f$m$o$p$q$r$t$u$v$w$x$}%Q%R%^%_%`%a%b%c%d%e%f%{&T&U&V&W&X&Y&Z&d&e&f&g&h&i&j&y&z&{&|&}'O'P'R'S'T'U'V']'^'_'a'b'd'e'f'i'n'q's't'u'w'x'y'z'{'|'}(O(P(Q(R(S(T(U(W(X(Y(Z([(](^(_(`(a(b(c(d(e(f(g(l(m(n(o(p(q(r(s(t(u(v(w(x(y(z({(|(})O)P)Q)R)S)T)U)V)W)X)k)l)m)n)o)p)q)r)s)t)u)v)w)x)y)z){)|)}*O*P*Q*R*S*T*U*V*W*Y*Z*[*^*`*a*b*c*d*e*f*g*h*i*j*k*l*m*n*o*v*w*x*y*z*{*|*}+P+Q+R+S+T+m+n+o+p+q+r+s+t+u+v+w+x+y+z+{,^,_,`,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,{,|,}-P-R-S-T-c-d-e-f-g-h-i-j.^._.`.a.b.c.d.e.f.g.h.i.j.k.l.m.n.o.p.q.r.s.t.u.v.w.x.y.{.|.}/P/W/X/Y/Z/[/]/^/_/u/v/w/x/y/z/{/|/}0O0P0Q0R0S0T0U0V0W0X0Y0Z0[0]0^0_0`0a0b0d0e0f0h0o0p0q0r0s0t0u0v1Y1Z1[1]1^1_1`1a1b1c1d1e1f1g1h1i1j1k1l1m1n1o1p1q1r1s1t1u1w1x1y1{2S2T2U2V2W2X2Y2Z2n2o2p2x2y2z3U3V3W3X3Y3Z3[3]3^3_3`3a3b3c3d3e3f3g3h3i3j3k3l3m3n3o3p3q3r3s3t3u3v3w3x3y3z3{3|3}4O4P4Q4R4S4T4U4V4W4X4Y4Z4[4]4^4_4`4a4b5P5R5S5T5`5a5b5c5d5e5f5g5h5i5o5q5r5s5t5u5v5w5x5y5z5{5|5}6O6P6Q6R6S6T6U6V6W6X6Y6Z6[6]6^6_6`6a6b6c6d6e6f6g6h6i6j6k6l6m6n6o6p6q6r6s6t6u6{6|6}7O7P7Q7R7S7T7U7V7W7X7Y7Z7[7]7^7_7`7a7b7c7d7e7f7g7h7i7j7k7l7m7n7o7p7q7r7s7t7u7v7w7x7y7z7{7|7}8O8P8Q8R8S8T8U8V8W8X8Y8Z8[8]8^8_8`8a8f8g8h8i8j8k8l8m8n8o8p8q8r8s8t8u8v8w8x8y8z8{8|8}9O9P9Q9R9S9T9U9V9W9X9Y9Z9[9]9^9_9`9a9b9c9d9e9f9g9h9i9j9k9l9m9n9o9p9q9r9s9t9u9v9w9x9y9z9{9|9}:O:P:Q:R:S:T:U:V:W:X:Y:Z:[:]:^:_:`:a:b:c:d:e:f:g:h:i:j:k:l:m:n:o:p;P;Q;a;b;x;y<Y<Z<j<k<z<{<|<}=O=P=Q=R=S=T=U=V=W=X=Y=Z=[=]=^=_=`=a=b=c=d=e=f=g=h=i=j=k=l=m=n=o=p=q=s=t=u=v=w>P>Q>R>S>T>U>V>W>X>Y>Z>[>]>^>_>`>a>b>c>d>e>f>g>h>i>j>k>l>m>n>o>p>q>r>s>t>u>v>w>x>y>z>{>|>}?O?P?Q?R?S?T?U?V?W?X?Y?Z?[?]?^?_?`?a?b?c?d?e?f?g?h?i?j?k?l?m?n?o?p?q?r?s?t?u?v?w?x?y?z?{?|?}@O@P@Q@R@S@T@U@V@W@X@Y@Z@[@]@^@_@`@a@b@c@d@e@f@g@h@i@j@k@l@m@n@o@p@q@r@s@t@u@v@w@x@y@z@{@|@}AOAPAQARASATAUAVAWAXAYAZA[A]A^A_A`AaAbAcAdAeAfAgAhAiAjAmAnAoApAqArAsAtAuAvAwAxAyAzA{A|A}BOBPBQBRBSBTBUBVBWBXBYBZB[B]B^B_B`BaBbBcBdBeBfBgBhBiBjBkBlBmBnBoBpBqBrBsBtBuBvBwBxByBzB{B|B}COCPCQCRCSCTCUCVCWCXCYCZC[C]C^C_C`CaCbCcCdCeCfCgChCiCjCkClCmCnCoCpCqCrCsCtCuCvCwCxCyCzC{C|C}DODPDQDRDSDTDUDVDWDXDYDZD[D]D^D_D`DaDbDcDdDeDfDgDhDiDjDkDlDmDnDoDpDqDrDsDtDuDvDwDxDyDzD{D|D}EOEPEQERESETEUEVEWEXEYEZE[E]E^E_E`EaEbEcEdEeEfEgEhEiEjEkElEmEnEoEpEqErEsEtEuEvEwExEyEzE{E|E}FOFPFQFRFSFTFUFVFWFXFYFZF[F]F^F_F`FaFbFcFdFeFfFgFhFiFjFkFlFmFnFoFpFqFrFsFtFuFvFwFxFyFzF{F|F}GOGPGQGRGSGTGUGVGWGXGYGZG[G]G^G_G`GaGbGcGdGeGfGgGhGiGjGkGlGmGnGoGpGqGrGsGtGuGvGwGxGyGzG{G|G}HOHPHQHRHSHTHUHVHWHXHYHZH[H]H^H_H`HaHbHcHdHeHfHgHhHiHjHkHlHmHnHoHpHqHrHsHtHuHvHwHxHyHzH{H|H}IOIPIQ^!tV!j%g8b8c8d8eT!u!v$h!+|nOPZ[]^_`abcdefgimqvwxyz{|}!O!P!Q!R!S!T!]!`!y!{#O#P#Q#R#S#U#V#W#X#Y#Z#[#_#`#c#e#h#i#j#k#l#m#n#o#p#q#r#s#u$a$f$m$o$p$q$r$t$u$v$w$x$}%Q%R%^%_%`%a%b%c%d%e%f%{&T&U&V&W&X&Y&Z&d&e&f&g&h&i&j&y&z&{&|&}'O'P'R'S'T'U'V']'^'_'a'b'd'e'f'i'n'q'r's't'u'v'w'x'y'z'{'|'}(O(P(Q(R(S(T(U(V(W(X(Y(Z([(](^(_(`(a(b(c(d(e(f(g(l(m(n(o(p(q(r(s(t(u(v(w(x(y(z({(|(})O)P)Q)R)S)T)U)V)W)X)k)l)m)n)o)p)q)r)s)t)u)v)w)x)y)z){)|)}*O*P*Q*R*S*T*U*V*W*X*Y*Z*[*]*^*`*a*b*c*d*e*f*g*h*i*j*k*l*m*n*o*v*w*x*y*z*{*|*}+O+P+Q+R+S+T+m+n+o+p+q+r+s+t+u+v+w+x+y+z+{,^,_,`,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,{,|,}-O-P-Q-R-S-T-U-c-d-e-f-g-h-i-j-k.^._.`.a.b.c.d.e.f.g.h.i.j.k.l.m.n.o.p.q.r.s.t.u.v.w.x.y.z.{.|.}/O/P/W/X/Y/Z/[/]/^/_/`/u/v/w/x/y/z/{/|/}0O0P0Q0R0S0T0U0V0W0X0Y0Z0[0]0^0_0`0a0b0c0d0e0f0g0h0o0p0q0r0s0t0u0v0w1Y1Z1[1]1^1_1`1a1b1c1d1e1f1g1h1i1j1k1l1m1n1o1p1q1r1s1t1u1v1w1x1y1z1{2S2T2U2V2W2X2Y2Z2[2m2n2o2p2q2x2y2z2{3U3V3W3X3Y3Z3[3]3^3_3`3a3b3c3d3e3f3g3h3i3j3k3l3m3n3o3p3q3r3s3t3u3v3w3x3y3z3{3|3}4O4P4Q4R4S4T4U4V4W4X4Y4Z4[4]4^4_4`4a4b5P5R5S5T5`5a5b5c5d5e5f5g5h5i5o5q5r5s5t5u5v5w5x5y5z5{5|5}6O6P6Q6R6S6T6U6V6W6X6Y6Z6[6]6^6_6`6a6b6c6d6e6f6g6h6i6j6k6l6m6n6o6p6q6r6s6t6u6{6|6}7O7P7Q7R7S7T7U7V7W7X7Y7Z7[7]7^7_7`7a7b7c7d7e7f7g7h7i7j7k7l7m7n7o7p7q7r7s7t7u7v7w7x7y7z7{7|7}8O8P8Q8R8S8T8U8V8W8X8Y8Z8[8]8^8_8`8a8f8g8h8i8j8k8l8m8n8o8p8q8r8s8t8u8v8w8x8y8z8{8|8}9O9P9Q9R9S9T9U9V9W9X9Y9Z9[9]9^9_9`9a9b9c9d9e9f9g9h9i9j9k9l9m9n9o9p9q9r9s9t9u9v9w9x9y9z9{9|9}:O:P:Q:R:S:T:U:V:W:X:Y:Z:[:]:^:_:`:a:b:c:d:e:f:g:h:i:j:k:l:m:n:o:p;P;Q;a;b;x;y<Y<Z<j<k<z<{<|<}=O=P=Q=R=S=T=U=V=W=X=Y=Z=[=]=^=_=`=a=b=c=d=e=f=g=h=i=j=k=l=m=n=o=p=q=s=t=u=v=w>P>Q>R>S>T>U>V>W>X>Y>Z>[>]>^>_>`>a>b>c>d>e>f>g>h>i>j>k>l>m>n>o>p>q>r>s>t>u>v>w>x>y>z>{>|>}?O?P?Q?R?S?T?U?V?W?X?Y?Z?[?]?^?_?`?a?b?c?d?e?f?g?h?i?j?k?l?m?n?o?p?q?r?s?t?u?v?w?x?y?z?{?|?}@O@P@Q@R@S@T@U@V@W@X@Y@Z@[@]@^@_@`@a@b@c@d@e@f@g@h@i@j@k@l@m@n@o@p@q@r@s@t@u@v@w@x@y@z@{@|@}AOAPAQARASATAUAVAWAXAYAZA[A]A^A_A`AaAbAcAdAeAfAgAhAiAjAmAnAoApAqArAsAtAuAvAwAxAyAzA{A|A}BOBPBQBRBSBTBUBVBWBXBYBZB[B]B^B_B`BaBbBcBdBeBfBgBhBiBjBkBlBmBnBoBpBqBrBsBtBuBvBwBxByBzB{B|B}COCPCQCRCSCTCUCVCWCXCYCZC[C]C^C_C`CaCbCcCdCeCfCgChCiCjCkClCmCnCoCpCqCrCsCtCuCvCwCxCyCzC{C|C}DODPDQDRDSDTDUDVDWDXDYDZD[D]D^D_D`DaDbDcDdDeDfDgDhDiDjDkDlDmDnDoDpDqDrDsDtDuDvDwDxDyDzD{D|D}EOEPEQERESETEUEVEWEXEYEZE[E]E^E_E`EaEbEcEdEeEfEgEhEiEjEkElEmEnEoEpEqErEsEtEuEvEwExEyEzE{E|E}FOFPFQFRFSFTFUFVFWFXFYFZF[F]F^F_F`FaFbFcFdFeFfFgFhFiFjFkFlFmFnFoFpFqFrFsFtFuFvFwFxFyFzF{F|F}GOGPGQGRGSGTGUGVGWGXGYGZG[G]G^G_G`GaGbGcGdGeGfGgGhGiGjGkGlGmGnGoGpGqGrGsGtGuGvGwGxGyGzG{G|G}HOHPHQHRHSHTHUHVHWHXHYHZH[H]H^H_H`HaHbHcHdHeHfHgHhHiHjHkHlHmHnHoHpHqHrHsHtHuHvHwHxHyHzH{H|H}IOIPIQ^!wV!j%g8b8c8d8eQ#esS%Z#f%[Q*k5ZQ*l5[Q*m5]Q*n5^Q*o5_R7S>O!+]pOPVZ[]^_`abcdefgimqvwxyz{|}!O!P!Q!R!S!T!]!`!j!y!{#O#P#Q#R#S#U#V#W#X#Y#Z#[#_#`#c#e#h#i#j#k#l#m#n#o#p#q#r#s#u$a$f$m$o$p$q$r$t$u$v$w$x$}%Q%R%^%_%`%a%b%c%d%e%f%g%{&T&U&V&W&X&Y&Z&d&e&f&g&h&i&j&y&z&{&|&}'O'P'R'S'T'U'V']'^'_'a'b'd'e'f'i'n'q's't'u'w'x'y'z'{'|'}(O(P(Q(R(S(T(U(W(X(Y(Z([(](^(_(`(a(b(c(d(e(f(g(l(m(n(o(p(q(r(s(t(u(v(w(x(y(z({(|(})O)P)Q)R)S)T)U)V)W)X)k)l)m)n)o)p)q)r)s)t)u)v)w)x)y)z){)|)}*O*P*Q*R*S*T*U*V*W*Y*Z*[*^*`*a*b*c*d*e*f*g*h*i*j*k*l*m*n*o*v*w*x*y*z*{*|*}+P+Q+R+S+T+m+n+o+p+q+r+s+t+u+v+w+x+y+z+{,^,_,`,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,{,|,}-P-R-S-T-c-d-e-f-g-h-i-j.^._.`.a.b.c.d.e.f.g.h.i.j.k.l.m.n.o.p.q.r.s.t.u.v.w.x.y.{.|.}/P/W/X/Y/Z/[/]/^/_/u/v/w/x/y/z/{/|/}0O0P0Q0R0S0T0U0V0W0X0Y0Z0[0]0^0_0`0a0b0d0e0f0h0o0p0q0r0s0t0u0v1Y1Z1[1]1^1_1`1a1b1c1d1e1f1g1h1i1j1k1l1m1n1o1p1q1r1s1t1u1w1x1y1{2S2T2U2V2W2X2Y2Z2n2o2p2x2y2z3U3V3W3X3Y3Z3[3]3^3_3`3a3b3c3d3e3f3g3h3i3j3k3l3m3n3o3p3q3r3s3t3u3v3w3x3y3z3{3|3}4O4P4Q4R4S4T4U4V4W4X4Y4Z4[4]4^4_4`4a4b5P5R5S5T5`5a5b5c5d5e5f5g5h5i5o5q5r5s5t5u5v5w5x5y5z5{5|5}6O6P6Q6R6S6T6U6V6W6X6Y6Z6[6]6^6_6`6a6b6c6d6e6f6g6h6i6j6k6l6m6n6o6p6q6r6s6t6u6{6|6}7O7P7Q7R7S7T7U7V7W7X7Y7Z7[7]7^7_7`7a7b7c7d7e7f7g7h7i7j7k7l7m7n7o7p7q7r7s7t7u7v7w7x7y7z7{7|7}8O8P8Q8R8S8T8U8V8W8X8Y8Z8[8]8^8_8`8a8b8c8d8e8f8g8h8i8j8k8l8m8n8o8p8q8r8s8t8u8v8w8x8y8z8{8|8}9O9P9Q9R9S9T9U9V9W9X9Y9Z9[9]9^9_9`9a9b9c9d9e9f9g9h9i9j9k9l9m9n9o9p9q9r9s9t9u9v9w9x9y9z9{9|9}:O:P:Q:R:S:T:U:V:W:X:Y:Z:[:]:^:_:`:a:b:c:d:e:f:g:h:i:j:k:l:m:n:o:p;P;Q;a;b;x;y<Y<Z<j<k<z<{<|<}=O=P=Q=R=S=T=U=V=W=X=Y=Z=[=]=^=_=`=a=b=c=d=e=f=g=h=i=j=k=l=m=n=o=p=q=s=t=u=v=w>P>Q>R>S>T>U>V>W>X>Y>Z>[>]>^>_>`>a>b>c>d>e>f>g>h>i>j>k>l>m>n>o>p>q>r>s>t>u>v>w>x>y>z>{>|>}?O?P?Q?R?S?T?U?V?W?X?Y?Z?[?]?^?_?`?a?b?c?d?e?f?g?h?i?j?k?l?m?n?o?p?q?r?s?t?u?v?w?x?y?z?{?|?}@O@P@Q@R@S@T@U@V@W@X@Y@Z@[@]@^@_@`@a@b@c@d@e@f@g@h@i@j@k@l@m@n@o@p@q@r@s@t@u@v@w@x@y@z@{@|@}AOAPAQARASATAUAVAWAXAYAZA[A]A^A_A`AaAbAcAdAeAfAgAhAiAjAmAnAoApAqArAsAtAuAvAwAxAyAzA{A|A}BOBPBQBRBSBTBUBVBWBXBYBZB[B]B^B_B`BaBbBcBdBeBfBgBhBiBjBkBlBmBnBoBpBqBrBsBtBuBvBwBxByBzB{B|B}COCPCQCRCSCTCUCVCWCXCYCZC[C]C^C_C`CaCbCcCdCeCfCgChCiCjCkClCmCnCoCpCqCrCsCtCuCvCwCxCyCzC{C|C}DODPDQDRDSDTDUDVDWDXDYDZD[D]D^D_D`DaDbDcDdDeDfDgDhDiDjDkDlDmDnDoDpDqDrDsDtDuDvDwDxDyDzD{D|D}EOEPEQERESETEUEVEWEXEYEZE[E]E^E_E`EaEbEcEdEeEfEgEhEiEjEkElEmEnEoEpEqErEsEtEuEvEwExEyEzE{E|E}FOFPFQFRFSFTFUFVFWFXFYFZF[F]F^F_F`FaFbFcFdFeFfFgFhFiFjFkFlFmFnFoFpFqFrFsFtFuFvFwFxFyFzF{F|F}GOGPGQGRGSGTGUGVGWGXGYGZG[G]G^G_G`GaGbGcGdGeGfGgGhGiGjGkGlGmGnGoGpGqGrGsGtGuGvGwGxGyGzG{G|G}HOHPHQHRHSHTHUHVHWHXHYHZH[H]H^H_H`HaHbHcHdHeHfHgHhHiHjHkHlHmHnHoHpHqHrHsHtHuHvHwHxHyHzH{H|H}IOIPIQ!]uOPV!W!Z!]!j!v#[#t#x$a$f$h${%g%n%p%z&s8b8c8d8e<z<{<|>_>`!]tOPV!W!Z!]!j!v#[#t#x$a$f$h${%g%n%p%z&s8b8c8d8e<z<{<|>_>`Z%k#s7_7`7a7bT!YO!ZR#x!XQ!WOR#v!WQ!z'wS#UabS#m|}Q#s!T$S$s#U#m#s$t%b&W&g&{'T'^'e'i'n*X*Y*Z*[*]*{*|*}+O,z,{,|,}-O-h-i-j-k.z.{.|.}/O/]/^/_/`0c0d0e0f0g0t0u0v0w1v1w1x1y1z2X2Y2Z2[2m2n2o2p2q2x2y2z2{7_7`7a7bS$t#V#_S%S*^*`Q%b#nQ&W$uQ&g%cQ&w-PQ&{&XQ'T&hQ'Z/PQ'^&|Q'e'UQ'g0hQ'i'_Q'n'fQ'o1{S*X'r'{S*Y's'xS*Z't'|S*['u'zS*]'v'yS*{(S5fS*|(T5gS*}(U5hS+O(V5iS,z6r6}S,{6p6{S,|6s7OS,}6q6|S-O6t7PQ-h7ZQ-i7[Q-j7]Q-k7^Q.z8SQ.{8QQ.|8TQ.}8RQ/O8UQ/]8^Q/^8_Q/_8`Q/`8aQ0c9VQ0d9TQ0e9WQ0f9UQ0g9XQ0t9aQ0u9bQ0v9cQ0w9dQ1v:UQ1w:SQ1x:VQ1y:TQ1z:WQ2X:`Q2Y:aQ2Z:bQ2[:cQ2m:gQ2n:eQ2o:hQ2p:fQ2q:iQ2x:kQ2y:lQ2z:mQ2{:nQ7_>ZQ7`>[Q7a>]R7b>^^!iV#[%g8b8c8d8eU$]!i$^&pQ$^!jR&p%m[${#[%g8b8c8d8eQ%n#xQ%z$aW&[${%n%z&sR&s%pQ$S!cQ$U!dQ$Y!fV%r$S$U$Y[$}#[%g8b8c8d8eQ%{$aT&^$}%{b!rV!j$d$h%g8b8c8d8eR$c!r`!vV!j$h%g8b8c8d8eR$i!vQ%X#dR&_%XQ'a'OQ'b'PT'j'a'bQ%[#fR&a%[Q!ZOR#z!Z^!aP!]<z<{<|>_>`! q!zX!|#O#P#Q#R#S#T#V#W#X#Y#Z#^#`#g#h#i#j#k#l#n#o#p#q#r$O$m$n$o$p$q$r$u$v$w$x%T%]%^%_%`%a%c%d%e%f&R&S&T&U&V&X&Y&Z&c&d&e&f&h&i&j&x&y&z&|&}'Q'R'S'U'V'[']'_'c'd'f'h'm)Y)Z)[)])^)_)`)a)b)c)d)e)f)g)h)i)k)l)m)n)o)p)q)r)s)t)u)v)w)x)y)z){)|)}*O*P*Q*R*S*T*U*V*W*^*_*a*b*c*d*e*p*q*r*s*t*u*v*w*x*y*z+Z+[+]+^+_+`+a+b+c+d+e+f+g+h+i+j+k+m+n+o+p+q+r+s+t+u+v+w+x+y+z+{+|+},O,P,Q,R,S,T,U,V,W,X,Y,Z,[,],^,_,`,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y-P-V-W-X-Y-Z-[-]-^-_-`-a-b-c-d-e-f-g-t-u-v-w-x-y-z-{-|-}.O.P.Q.R.S.T.U.V.W.X.Y.Z.[.].^._.`.a.b.c.d.e.f.g.h.i.j.k.l.m.n.o.p.q.r.s.t.u.v.w.x.y/P/Q/R/S/T/U/V/W/X/Y/Z/[/e/f/g/h/i/j/k/l/m/n/o/p/q/r/s/t/u/v/w/x/y/z/{/|/}0O0P0Q0R0S0T0U0V0W0X0Y0Z0[0]0^0_0`0a0b0h0i0j0k0l0m0n0o0p0q0r0s0x0y0z0{0|0}1O1P1Q1R1S1T1U1V1W1X1Y1Z1[1]1^1_1`1a1b1c1d1e1f1g1h1i1j1k1l1m1n1o1p1q1r1s1t1u1{1|1}2O2P2Q2R2S2T2U2V2W2]2^2_2`2a2b2c2d2e2f2g2h2i2j2k2l2r2s2t2u2v2w2|2}3O3P3Q3R3S3T6R6S6T6U6V6W6X6Y6Z6[6]6^6_6`6a6b6c6d6e6f6g6h6i6j6k6l6m6n6o6p6q6r6s6t6u6v6w6x6y6z7Q7T7U7V7W7X7Y7Z7[7]7^7c7d7e7f7g7h7i7j7k7l7m7n7o7p7q7r7s7t7u7v7w7x7y7z7{7|7}8O8P8Q8R8S8T8U8V8W8X8Y8Z8[8]8^8_8`8a8f8g8h8i8j8k8l8m8n8o8p8q8r8s8t8u8v8w8x8y8z8{8|8}9O9P9Q9R9S9T9U9V9W9X9Y9Z9[9]9^9_9`9a9b9c9d9e9f9g9h9i9j9k9l9m9n9o9p9q9r9s9t9u9v9w9x9y9z9{9|9}:O:P:Q:R:S:T:U:V:W:X:Y:Z:[:]:^:_:`:a:b:c:d:e:f:g:h:i:j:k:l:m:n:q:r:s:t:u:v:w:x:y:z:{:|:};O;P;Q;R;S;T;U;V;W;X;Y;Z;[;];^;_;`;a;b;c;d;e;f;g;h;i;j;k;l;m;n;o;p;q;r;s;t;u;v;w;x;y;z;{;|;}<O<P<Q<R<S<T<U<V<W<X<Y<Z<[<]<^<_<`<a<b<c<d<e<f<g<h<i<j<k<l<m<n<o<p<q<r<s<t<u<v<w<x<y>a>b>c>d>e>f>g>h>i>j>k>l>m>n>o>p>q>r>s>t>u>v>w>x>y>z>{>|>}?O?P?Q?R?S?T?U?V?W?X?Y?Z?[?]?^?_?`?a?b?c?d?e?f?g?h?i?j?k?l?m?n?o?p?q?r?s?t?u?v?w?x?y?z?{?|?}@O@P@Q@R@S@T@U@V@W@X@Y@Z@[@]@^@_@`@a@b@c@d@e@f@g@h@i@j@k@l@m@n@o@p@q@r@s@t@u@v@w@x@y@z@{@|@}AOAPAQARASATAUAVAWAXAYAZA[A]A^A_A`AaAbAcAdAeAfAgAhAmAnAoApAqArAsAtBtBuBvBwBxByBzB{B|B}COCPCQCRCSCTCUCVCWCXCYCZC[C]C^C_C`CaCbCcCdCeCfCgChCiCjCkClCmCnCoCpCqCrCsCtCuCvCwCxCyCzC{C|C}DODPDQDRDSDTDUDVDWDXDYDZD[D]D^D_D`DaDbDcDdDeDfDgDhDiDjDkDlDmDnDoDpDqDrDsDtDuDvDwDxDyDzD{D|EPEQERESETEUFUFVFWFXFYFZF[F]F^F_F`FaFbFcFdFeFfFgFhFiFjFkFlFmFnFoFpFqFrFsFtFuFvFwFxFyFzF{F|F}GOGPGQGRGSGTGUGVGWGXGYGZG[G]G^G_GbGcGdGeHeHfHgHhHiHjHkHlHmHnHoHrHsS!YO!Zs!lV!j!v#[#x$a$h${%g%n%p%z&s8b8c8d8eQ#crS%W#d%XQ*f5UQ*g5VQ*h5WQ*i5XQ*j5YR7R=}b#br#d%X5U5V5W5X5Y=}Q#esS%Z#f%[Q*k5ZQ*l5[Q*m5]Q*n5^Q*o5_R7S>O^%V#c*f*g*h*i*j7R^%Y#e*k*l*m*n*o7SX'`'O'P'a'b",
  nodeNames: "\u26A0 ReporterLeft1Args ReporterLeft2Args ReporterLeft1ArgsOpt GlobalStr ExtensionStr BreedStr Own Set Let To End Identifier Command Reporter TurtleVar PatchVar LinkVar Constant Unsupported SpecialReporter SpecialCommand BreedToken AndOr APCommand APReporterFlip APReporterVar APReporter UnsupportedPrim SpecialCommandCreateTurtle SpecialCommandCreateLink SpecialReporter1ArgsBoth SpecialReporter0ArgsLink SpecialReporter1ArgsLink SpecialReporter2ArgsTurtle SpecialReporter0ArgsTurtle SpecialReporter1ArgsTurtle SpecialReporter0ArgsLinkP SpecialCommandCreateTurtlePossible Reporter0Args Reporter1Args Reporter2Args Reporter3Args Reporter4Args Reporter5Args Reporter6Args Reporter0ArgsVar Reporter1ArgsVar Reporter2ArgsVar Reporter3ArgsVar Reporter4ArgsVar Reporter5ArgsVar Reporter6ArgsVar Reporter2ArgsVar0 Reporter1ArgsVar0 SpecialReporter0Args SpecialReporter1Args SpecialReporter2Args SpecialReporter3Args SpecialReporter4Args SpecialReporter5Args SpecialReporter6Args Command0Args Command1Args Command2Args Command3Args Command4Args Command5Args Command6Args Command0ArgsVar Command1ArgsVar Command2ArgsVar Command3ArgsVar Command4ArgsVar Command5ArgsVar Command6ArgsVar Command3ArgsVar2 Command1_2ArgsOpt SpecialCommand0Args SpecialCommand1Args SpecialCommand2Args SpecialCommand3Args SpecialCommand4Args SpecialCommand5Args SpecialCommand6Args LineComment Program Embedded CommandStatement Arg Value CloseParen OpenParen Parenthetical WorseParentheticals ReporterStatement Parenthetical Parenthetical Reporters CloseBracket OpenBracket AnonymousProcedure AnonArguments Arguments Arrow ProcedureContent Parenthetical Error Extensions Globals Breed BreedPlural BreedSingular BreedsOwn ShortAnonymousProcedure List Literal Numeric String CodeBlock VariableName ReporterBlock Property VariableDeclaration NewVariableDeclaration SetVariable Commands Normal Misplaced Procedure ProcedureName OneLineReporter",
  maxTerm: 154,
  context: contextTracker,
  nodeProps: [
    ["openedBy", 91, "OpenParen", 99, "OpenBracket"],
    ["closedBy", 92, "CloseParen", 100, "CloseBracket"]
  ],
  skippedNodes: [0, 13, 14, 20, 85],
  repeatNodeCount: 12,
  tokenData: "&d~R]XYzYZz]^zpqzrs!]xy#yyz$O}!O$T!O!P$a!Q![%^!]!^%q!}#O&Y#P#Q&_~!PS$W~XYzYZz]^zpqz~!`VOr!]rs!us#O!]#O#P!z#P;'S!];'S;=`#s<%lO!]~!zO#j~~!}RO;'S!];'S;=`#W;=`O!]~#ZWOr!]rs!us#O!]#O#P!z#P;'S!];'S;=`#s;=`<%l!]<%lO!]~#vP;=`<%l!]~$OO#O~~$TO!}~~$WR!O!P$a!Q![%^!`!a%l~$dP!Q![$g~$lQ#i~!Q![$g#X#Y$r~$uR{|%O}!O%O!Q![%U~%RP!Q![%U~%ZP#i~!Q![%U~%cR#i~!O!P$g!Q![%^#X#Y$r~%qO#[~~%vS!w~OY%qZ;'S%q;'S;=`&S<%lO%q~&VP;=`<%l%q~&_O#W~~&dO#V~",
  tokenizers: [0, keyword2],
  topRules: { "Program": [0, 86] },
  dynamicPrecedences: { "94": -2, "119": -1 },
  specialized: [{ term: 14, get: (value, stack) => specializeReporter(value, stack) << 1, external: specializeReporter }, { term: 20, get: (value, stack) => specializeSpecialReporter(value, stack) << 1, external: specializeSpecialReporter }, { term: 13, get: (value, stack) => specializeCommand(value, stack) << 1, external: specializeCommand }, { term: 21, get: (value, stack) => specializeSpecialCommand(value, stack) << 1, external: specializeSpecialCommand }],
  tokenPrec: 0
});

// src/lang/netlogo.ts
import {
  LRLanguage,
  LanguageSupport,
  delimitedIndent,
  indentNodeProp,
  foldNodeProp,
  foldInside,
  ParseContext
} from "@codemirror/language";

// src/lang/services/auto-completion.ts
import { syntaxTree as syntaxTree8 } from "@codemirror/language";

// src/lang/utils/check-identifier.ts
var getCheckContext = function(view, lintContext, preprocessContext) {
  var state = view.state;
  return {
    state,
    preprocessState: preprocessContext,
    parseState: lintContext,
    breedNames: lintContext.GetBreedNames(),
    breedVars: lintContext.GetBreedVariables()
  };
};
var acceptableIdentifiers = [
  "Unrecognized",
  "NewVariableDeclaration",
  "ProcedureName",
  "Arguments",
  "AnonArguments",
  "Globals",
  "BreedSingular",
  "BreedPlural",
  "BreedsOwn",
  "Extensions"
];
var checkValidIdentifier = function(Node, value, context) {
  var _a;
  value = value.toLowerCase();
  if (acceptableIdentifiers.includes(((_a = Node.parent) == null ? void 0 : _a.name) ?? "")) return true;
  if (context.parseState.Globals.has(value) || context.parseState.WidgetGlobals.has(value) || context.parseState.Procedures.has(value) || context.preprocessState.Commands.has(value) || context.preprocessState.Reporters.has(value))
    return true;
  if (context.breedNames.includes(value) || context.breedVars.includes(value)) return true;
  let procedureVars = getLocalVariables(Node, context.state, context.parseState);
  return procedureVars.includes(value);
};
var getLocalVariables = function(Node, State, parseState) {
  let procedureVars = [];
  let procedure = null;
  var procedureName = getParentProcedure(State, Node);
  if (procedureName) procedure = parseState.Procedures.get(procedureName.toLowerCase());
  if (!procedure && !procedureName && State.field(stateExtension).RecognizedMode != "Model") {
    for (var p of parseState.Procedures.values()) {
      if (p.EditorID == State.field(stateExtension).EditorID) procedure = p;
    }
  }
  if (!procedure) return procedureVars;
  procedure.Variables.map((variable) => {
    if (variable.CreationPos < Node.from) procedureVars.push(variable.Name);
  });
  gatherAnonymousVariables(procedure.AnonymousProcedures, Node, procedureVars);
  gatherAnonymousVariables(procedure.CodeBlocks, Node, procedureVars);
  if (procedure.Arguments) procedureVars.push(...procedure.Arguments);
  return procedureVars;
};
var gatherAnonymousVariables = function(Group, Node, Vars) {
  Group.map((anonProc) => {
    if (Node.from >= anonProc.PositionStart && Node.to <= anonProc.PositionEnd) {
      anonProc.Variables.map((Var) => {
        if (Var.CreationPos < Node.from) Vars.push(Var.Name);
      });
      Vars.push(...anonProc.Arguments);
      gatherAnonymousVariables(anonProc.CodeBlocks, Node, Vars);
      gatherAnonymousVariables(anonProc.AnonymousProcedures, Node, Vars);
    }
  });
};
function checkUndefinedBreed(diagnostics, context, view, noderef) {
  let value = getCodeName(view.state, noderef);
  let info = MatchBreed(value, context, true);
  if (!info.Valid && info.Plural) {
    if (!checkUnrecognizedWithSuggestions(diagnostics, view, noderef)) {
      let diagnostic = getDiagnostic(view, noderef, "Unrecognized breed name _", "error", info.Plural);
      if (typeof info.Type !== "undefined") addBreedAction(diagnostic, info.Type, info.Plural, info.Singular);
      diagnostics.push(diagnostic);
    }
    return true;
  } else if (!info.Valid && info.Tag != 0) {
    let diagnostic = getDiagnostic(view, noderef, "Invalid breed type _", "error");
    diagnostics.push(diagnostic);
    return true;
  } else return false;
}
var UnrecognizedSuggestions = {
  else: "ifelse",
  "%": "mod",
  "{": "[",
  "}": "]",
  "create-patch": "ask patch 0 0",
  "create-patches": "ask patches",
  "create-link": "create-link-with",
  "create-links": "create-links-with",
  "set-patch-color": "set pcolor",
  "set-world-size": "resize-world",
  return: "report"
};
function checkUnrecognizedWithSuggestions(diagnostics, view, node) {
  var value = getCodeName(view.state, node);
  if (UnrecognizedSuggestions.hasOwnProperty(value)) {
    let diagnostic = getDiagnostic(
      view,
      node,
      "Unrecognized identifier with replacement _",
      "error",
      value,
      UnrecognizedSuggestions[value]
    );
    AddReplaceAction(diagnostic, UnrecognizedSuggestions[value]);
    diagnostics.push(diagnostic);
    return true;
  }
  return false;
}

// src/lang/services/auto-completion.ts
var AutoCompletion = class {
  /** Constructor: Create a new auto completion service. */
  constructor(Editor) {
    /** BuiltinVariables: The completion list of built-in variables. */
    this.BuiltinVariables = this.KeywordsToCompletions(
      [...turtleVars, ...patchVars, ...linkVars],
      "Variable-Builtin"
    );
    /** SharedIdentifiers: Shared built-in completions. */
    this.SharedIdentifiers = [
      { label: "end", type: "Directive" },
      ...this.BuiltinVariables,
      ...this.KeywordsToCompletions(constants, "Constant")
    ];
    /** LastExtensions: Cached extension list. */
    this.LastExtensions = "$NIL$";
    /** LastPrimitives: Cached primitive list. */
    this.LastPrimitives = [];
    /** ParentMaps: Maps of keywords to parents.  */
    this.ParentMaps = {
      Extensions: this.KeywordsToCompletions(PrimitiveManager.GetExtensions(), "Extension"),
      // Extensions
      Program: this.KeywordsToCompletions(directives, "Directive"),
      // Directives
      Globals: [],
      // Names of global variables
      BreedsOwn: [],
      // Names of breed variables
      Breed: [],
      // Names of breeds
      ProcedureName: [],
      // Names of procedures
      Arguments: []
      // Arguments of procedures
      /* VariableName: this.KeywordsToCompletions(
        [...turtleVars, ...patchVars, ...linkVars],
        'Variable-Builtin'
      ), // Built-in variable names*/
      // Temporary fix
    };
    /** ParentTypes: Types of keywords.  */
    this.ParentTypes = Object.keys(this.ParentMaps);
    this.Editor = Editor;
  }
  /** KeywordsToCompletions: Transform keywords to completions. */
  KeywordsToCompletions(Keywords, Type) {
    return Keywords.map(function(x) {
      return { label: x, type: Type };
    });
  }
  /** GetParentKeywords: Get keywords of a certain type. */
  GetParentKeywords(Type, State) {
    let results = this.ParentMaps[Type];
    switch (Type) {
      case "Extensions":
        results = results.filter((ext) => !State.Extensions.has(ext.label));
        break;
      case "VariableName":
        results = results.concat(
          this.KeywordsToCompletions([...State.Globals.keys(), ...State.WidgetGlobals.keys()], "Variable")
        );
        break;
      case "Program":
        results = results.concat(
          this.KeywordsToCompletions(
            [...State.Breeds.values()].map((breed) => breed.Plural + "-own"),
            "Directive"
          )
        );
        break;
    }
    return results;
  }
  /** getBreedCommands: Get breed commands. */
  getBreedCommands(state) {
    let commands = [];
    for (let b of state.Breeds.values()) {
      if (b.BreedType == 1 /* Patch */) continue;
      else {
        commands = commands.concat(this.addBreedCompletions(b, true));
      }
    }
    return commands;
  }
  /** getBreedReporters: Get breed reporters. */
  getBreedReporters(state) {
    let reporters = [];
    for (let b of state.Breeds.values()) {
      reporters = reporters.concat(this.addBreedCompletions(b, false));
    }
    return reporters;
  }
  addBreedCompletions(breed, commands) {
    let completions = [];
    for (var rule of BreedStatementRules) {
      if ((rule.Type == breed.BreedType || rule.Type == void 0) && rule.isCommand == commands && rule.Tag != Own) {
        if (rule.Singular == true || rule.Singular == void 0) {
          for (var s of rule.String) {
            completions.push(s.replace(/<breed>/g, breed.Singular));
          }
        }
        if (rule.Singular == false || rule.Singular == void 0) {
          for (var s of rule.String) {
            completions.push(s.replace(/<breed>/g, breed.Plural));
          }
        }
      }
    }
    return completions;
  }
  /** GetCompletion: Get the completion hint at a given context. */
  GetCompletion(Context) {
    var _a, _b, _c;
    const node = syntaxTree8(Context.state).resolveInner(Context.pos, -1);
    const from = /\./.test(node.name) ? node.to : node.from;
    const nodeName = node.type.name;
    let parentName = ((_a = node.parent) == null ? void 0 : _a.type.name) ?? "";
    const grandparentName = ((_c = (_b = node.parent) == null ? void 0 : _b.parent) == null ? void 0 : _c.type.name) ?? "";
    const context = this.Editor.LintContext;
    let curr = node;
    let parents = [];
    while (curr.parent) {
      parents.push(curr.parent.name);
      curr = curr.parent;
    }
    Log(node.name + "/" + parents.join("/"));
    if (parents.includes("Reporter") && this.Editor.Options.ParseMode == "Normal" /* Normal */ || grandparentName == "Normal" && parentName == "\u26A0") {
      parentName = "Program";
    }
    if (this.ParentTypes.indexOf(parentName) > -1)
      return { from, options: this.GetParentKeywords(parentName, context) };
    if (this.ParentTypes.indexOf(grandparentName) > -1 && (parentName != "Procedure" || nodeName == "To"))
      return {
        from,
        options: this.GetParentKeywords(grandparentName, context)
      };
    if ((nodeName == "Identifier" || nodeName == "Extension" || nodeName.includes("Reporter") || nodeName.includes("Command") || nodeName == "Set" || nodeName == "Let") && parentName != "Unrecognized") {
      let results = this.SharedIdentifiers;
      const extensions = [...context.Extensions.keys()];
      const extensionNames = extensions.join(",");
      if (this.LastExtensions != extensionNames) {
        this.LastPrimitives = PrimitiveManager.GetCompletions(extensions);
        this.LastExtensions = extensionNames;
      }
      results = results.concat(this.LastPrimitives);
      if (context.Breeds.size > 0) {
        let breeds = context.GetBreedNames();
        breeds = breeds.filter((breed) => !["turtle", "turtles", "patch", "patches", "link", "links"].includes(breed));
        results.push(...this.KeywordsToCompletions(breeds, "Breed"));
        results.push(...this.KeywordsToCompletions(this.getBreedCommands(context), "Command"));
        results.push(...this.KeywordsToCompletions(this.getBreedReporters(context), "Reporter"));
        results.push(...this.KeywordsToCompletions(context.GetBreedVariables(), "Variable-Breed"));
      }
      results.push(
        ...this.KeywordsToCompletions([...context.Globals.keys(), ...context.WidgetGlobals.keys()], "Variable-Global")
      );
      for (var Procedure3 of context.Procedures.values()) {
        results.push({
          label: Procedure3.Name,
          type: Procedure3.IsCommand ? "Command-Custom" : "Reporter-Custom"
        });
      }
      results.push(...this.KeywordsToCompletions(getLocalVariables(node, Context.state, context), "Variable-Local"));
      return { from, options: results };
    }
    return null;
  }
  /** GetCompletionSource: Get the completion source for a NetLogo model. */
  GetCompletionSource() {
    return (Context) => this.GetCompletion(Context);
  }
};

// src/lang/netlogo.ts
var NetLogoLanguage = LRLanguage.define({
  parser: parser.configure({
    props: [
      // Stylish tags
      styleTags({
        // Basic elements
        Constant: tags.literal,
        String: tags.literal,
        Numeric: tags.literal,
        LineComment: tags.lineComment,
        OpenBracket: tags.paren,
        CloseBracket: tags.paren,
        Directive: tags.strong,
        Extension: tags.bool,
        // Commands
        AndOr: tags.operator,
        Reporter: tags.operator,
        Reporter0Args: tags.operator,
        Reporter1Args: tags.operator,
        Reporter2Args: tags.operator,
        Reporter3Args: tags.operator,
        Reporter4Args: tags.operator,
        Reporter5Args: tags.operator,
        Reporter6Args: tags.operator,
        Reporter0ArgsVar: tags.operator,
        Reporter1ArgsVar: tags.operator,
        Reporter2ArgsVar: tags.operator,
        Reporter3ArgsVar: tags.operator,
        Reporter4ArgsVar: tags.operator,
        Reporter5ArgsVar: tags.operator,
        Reporter6ArgsVar: tags.operator,
        Reporter2ArgsVar0: tags.operator,
        Reporter1ArgsVar0: tags.operator,
        ReporterLeft1ArgsOpt: tags.operator,
        ReporterLeft1Args: tags.operator,
        ReporterLeft2Args: tags.operator,
        SpecialReporter0Args: tags.operator,
        SpecialReporter1Args: tags.operator,
        SpecialReporter2Args: tags.operator,
        SpecialReporter3Args: tags.operator,
        SpecialReporter4Args: tags.operator,
        SpecialReporter5Args: tags.operator,
        SpecialReporter6Args: tags.operator,
        SpecialReporter1ArgsBoth: tags.operator,
        SpecialReporter0ArgsLink: tags.operator,
        SpecialReporter1ArgsLink: tags.operator,
        SpecialReporter2ArgsTurtle: tags.operator,
        SpecialReporter0ArgsTurtle: tags.operator,
        SpecialReporter1ArgsTurtle: tags.operator,
        SpecialReporter0ArgsLinkP: tags.operator,
        APReporter: tags.operator,
        APReporterFlip: tags.operator,
        APReporterVar: tags.operator,
        Command: tags.variableName,
        SpecialCommand: tags.variableName,
        Command0Args: tags.variableName,
        Command1Args: tags.variableName,
        Command2Args: tags.variableName,
        Command3Args: tags.variableName,
        Command4Args: tags.variableName,
        Command5Args: tags.variableName,
        Command6Args: tags.variableName,
        Command0ArgsVar: tags.variableName,
        Command1ArgsVar: tags.variableName,
        Command2ArgsVar: tags.variableName,
        Command3ArgsVar: tags.variableName,
        Command4ArgsVar: tags.variableName,
        Command5ArgsVar: tags.variableName,
        Command6ArgsVar: tags.variableName,
        Command3ArgsVar2: tags.variableName,
        SpecialCommand0Args: tags.variableName,
        SpecialCommand1Args: tags.variableName,
        SpecialCommand2Args: tags.variableName,
        SpecialCommand3Args: tags.variableName,
        SpecialCommand4Args: tags.variableName,
        SpecialCommand5Args: tags.variableName,
        SpecialCommand6Args: tags.variableName,
        SpecialCommandCreateTurtle: tags.variableName,
        SpecialCommandCreateLink: tags.variableName,
        APCommand: tags.variableName,
        // Variables
        Set: tags.variableName,
        Let: tags.variableName,
        LinkVar: tags.bool,
        PatchVar: tags.bool,
        TurtleVar: tags.bool,
        "VariableName/BreedToken": tags.bool,
        // Global statements
        ExtensionStr: tags.strong,
        GlobalStr: tags.strong,
        "BreedDeclarative/BreedToken": tags.strong,
        BreedStr: tags.strong,
        Own: tags.strong,
        // Procedures
        To: tags.strong,
        End: tags.strong,
        ProcedureName: tags.strong
      }),
      // Indentations
      indentNodeProp.add({
        // LineComment:(context)=>{
        //   console.log("HERE")
        //   console.log(context.column(context.pos))
        //   console.log(context)
        //   return context.column(context.pos)
        // },
        //ReporterContent: delimitedIndent({ closing: '[\n', align: true }),
        ReporterStatement: (context) => delimitedStrategy(context),
        // delimitedIndent({ closing: '[\n', align: true }),
        CommandStatement: (context) => delimitedStrategy(context),
        ProcedureContent: delimitedIndent({ closing: "[\n" }),
        CodeBlock: delimitedIndent({ closing: "]" }),
        AnonymousProcedure: delimitedIndent({ closing: "]", align: false }),
        Extensions: delimitedIndent({ closing: "]", align: false }),
        Globals: delimitedIndent({ closing: "]", align: false }),
        Breed: delimitedIndent({ closing: "]", align: false }),
        BreedsOwn: delimitedIndent({ closing: "]", align: false }),
        Procedure: (context) => {
          return /^\s*[Ee][Nn][Dd]/.test(context.textAfter) ? context.baseIndent : context.lineIndent(context.node.from) + context.unit;
        }
        // delimitedIndent({ closing: 'end' }),
        // Doesn't work well with "END" or "eND". Should do a bug report to CM6.
      }),
      // Foldings
      foldNodeProp.add({
        CodeBlock: foldInside,
        Procedure: foldProcedure
      })
    ]
  }),
  languageData: {
    commentTokens: { line: ";" },
    closeBrackets: closeBrackets(),
    indentOnInput: /^\s*end$/i
  }
});
function bracketedAligned(context) {
  let tree = context.node;
  let openToken = tree.childAfter(tree.from), last = tree.lastChild;
  if (!openToken) return null;
  let openLine = context.state.doc.lineAt(openToken.from);
  let lineEnd = openLine.to;
  for (let pos = openToken.to; ; ) {
    let next = tree.childAfter(pos);
    if (!next || next == last) return null;
    if (!next.type.isSkipped) return next.from < lineEnd ? openToken : null;
    pos = next.to;
  }
}
function delimitedStrategy(context) {
  var _a, _b, _c, _d, _e, _f, _g;
  let nextNode = context.node.resolveInner(context.pos);
  console.log(nextNode.name, (_a = nextNode.node.parent) == null ? void 0 : _a.name);
  console.log(context.textAfter, context.node.name, (_b = context.node.parent) == null ? void 0 : _b.name);
  let after = context.textAfter, space = after.match(/^\s*/)[0].length;
  let closing2 = "[\n", align = ((_c = context.node.firstChild) == null ? void 0 : _c.name) != "Arg" && ((_d = context.node.firstChild) == null ? void 0 : _d.name) != "LineComment", units = 1;
  let next = after.slice(space, space + 2);
  let closed = closing2 && (next == closing2 || next == "[" || next == "]");
  let aligned = align ? bracketedAligned(context) : null;
  if (((_g = (_f = (_e = context.node.parent) == null ? void 0 : _e.parent) == null ? void 0 : _f.parent) == null ? void 0 : _g.name) == "CommandStatement") {
    return context.continue();
  }
  if (after.slice(space, space + 1) == ";") return context.baseIndent;
  if (aligned) return closed ? context.column(aligned.from) : context.column(aligned.to) + 1;
  return context.baseIndent + (closed ? 0 : context.unit * units);
}
function foldProcedure(node) {
  var first = node.getChild("Arguments");
  first = first ?? node.getChild("ProcedureName");
  first = first ?? node.firstChild;
  let last = node.lastChild;
  return first && first.to < last.from ? { from: first.to, to: last.type.isError ? node.to : last.to } : null;
}
function NetLogo(Editor) {
  return new LanguageSupport(NetLogoLanguage, [
    NetLogoLanguage.data.of({
      autocomplete: new AutoCompletion(Editor).GetCompletionSource()
    })
  ]);
}
var EmptyContext = new PreprocessContext();
function GetContext() {
  var Context = ParseContext.get();
  if (Context == null) return EmptyContext;
  Context.Context = Context.Context ?? Context.state.field(preprocessStateExtension).Editor.PreprocessContext;
  return Context.Context;
}

// src/lang/linters/identifier-linter.ts
import { syntaxTree as syntaxTree9 } from "@codemirror/language";
var IdentifierLinter = (view, preprocessContext, lintContext) => {
  const diagnostics = [];
  const context = getCheckContext(view, lintContext, preprocessContext);
  syntaxTree9(view.state).cursor().iterate((noderef) => {
    var parent = noderef.node.parent;
    if (noderef.name == "Identifier" && (parent == null ? void 0 : parent.name) != "\u26A0" || noderef.name == "SpecialCommandCreateTurtlePossible" && (parent == null ? void 0 : parent.name.includes("VariableName"))) {
      const node = noderef.node;
      const value = getCodeName(view.state, node);
      if (checkValidIdentifier(node, value, context)) return;
      if (value.startsWith("-") && checkValidIdentifier(node, value.slice(1), context)) {
        let d = getDiagnostic(view, noderef, "Negation _");
        d.actions = [
          {
            name: Localized.Get("Fix"),
            apply(view2, from, to) {
              if (value.startsWith("(")) {
                view2.dispatch({ changes: { from, to, insert: "- " + value.slice(1) } });
              } else {
                view2.dispatch({ changes: { from, to, insert: "(- " + value.slice(1) + ")" } });
              }
            }
          }
        ];
        diagnostics.push(d);
        return;
      }
      if (value === "?") {
        while (parent !== null) {
          if (parent.name === "CodeBlock" || parent.name === "Value") {
            diagnostics.push(getDiagnostic(view, noderef, "Deprecated usage of ?"));
            return;
          }
          parent = parent.parent;
        }
      }
      if (value === ",") {
        diagnostics.push(getDiagnostic(view, noderef, "Incorrect usage of ,"));
        return;
      }
      if (checkUnrecognizedWithSuggestions(diagnostics, view, node)) return;
      if (checkUndefinedBreed(diagnostics, context.preprocessState, view, node)) return;
      diagnostics.push(getDiagnostic(view, noderef, "Unrecognized identifier _"));
    } else if (noderef.name == "SpecialCommandCreateTurtlePossible" && !(parent == null ? void 0 : parent.name.includes("VariableName"))) {
      if (checkUnrecognizedWithSuggestions(diagnostics, view, noderef.node)) return;
      checkUndefinedBreed(diagnostics, context.preprocessState, view, noderef.node);
    }
  });
  return diagnostics;
};

// src/lang/linters/unrecognized-global-linter.ts
import { syntaxTree as syntaxTree10 } from "@codemirror/language";
var UnrecognizedGlobalLinter = (view, preprocessContext, lintContext) => {
  const diagnostics = [];
  let cursor = syntaxTree10(view.state).cursor();
  let lastGlobalPos = 0;
  if (cursor.firstChild() && cursor.node.name == "Normal") {
    for (var key of ["Extensions", "Globals", "BreedsOwn", "Breed"]) {
      cursor.node.getChildren(key).map((child) => {
        if (child.from > lastGlobalPos) {
          lastGlobalPos = child.from;
        }
      });
    }
    cursor.node.getChildren("Procedure").map((child) => {
      var _a;
      if (child.from < lastGlobalPos) {
        let value;
        let nameNode = (_a = child.node.getChild("Procedure")) == null ? void 0 : _a.getChild("ProcedureName");
        if (nameNode) {
          value = view.state.sliceDoc(nameNode.from, nameNode.to);
        } else {
          value = view.state.sliceDoc(child.from, child.to).split("\n")[0];
        }
        diagnostics.push({
          from: child.from,
          to: child.to,
          severity: "error",
          message: Localized.Get("Improperly placed procedure _", value)
        });
      }
    });
    for (var key of ["Extensions", "Globals"]) {
      if (cursor.node.getChildren(key).length > 1) {
        let first = true;
        cursor.node.getChildren(key).map((child) => {
          if (first) {
            first = false;
          } else {
            diagnostics.push({
              from: child.from,
              to: child.to,
              severity: "error",
              message: Localized.Get("Duplicate global statement _", key)
            });
          }
        });
      }
    }
    cursor.node.getChildren("Breed").map((child) => {
      let sing = child.getChild("BreedSingular");
      let plural = child.getChild("BreedPlural");
      if (sing && plural && sing.to - sing.from > 0 && plural.to - plural.from > 0) {
      } else {
        diagnostics.push({
          from: child.from,
          to: child.to,
          severity: "error",
          message: Localized.Get("Missing breed names _", "breed")
        });
      }
    });
  }
  return diagnostics;
};

// src/lang/linters/unrecognized-linter.ts
import { syntaxTree as syntaxTree11 } from "@codemirror/language";
var UnrecognizedLinter = (view, preprocessContext, lintContext) => {
  const diagnostics = [];
  const context = getCheckContext(view, lintContext, preprocessContext);
  syntaxTree11(view.state).cursor().iterate((node) => {
    var _a, _b, _c, _d, _e, _f, _g;
    if ((node.name == "\u26A0" || node.name == "Error" || node.name == "Misplaced" || node.name == "WorseParentheticals") && node.to != node.from) {
      let curr = node.node;
      let parents = [];
      while (curr.parent) {
        parents.push(curr.parent.name);
        curr = curr.parent;
      }
      const value = getCodeName(view.state, node);
      Log(value, node.name, parents);
      if (node.name == "Misplaced") {
        let sum = 0;
        let types = ["Extensions", "Globals", "Breed", "BreedsOwn", "Procedure"];
        types.map((name2) => {
          var _a2;
          sum += ((_a2 = node.node.parent) == null ? void 0 : _a2.getChildren(name2).length) ?? 0;
        });
        if (sum == 0 && view.state.field(stateExtension).Mode != "Normal" /* Normal */) {
          return;
        }
      }
      if (((_a = node.node.parent) == null ? void 0 : _a.name) == "Arguments") {
        let child = node.node.firstChild;
        if (reserved.includes(value) || child && (child.name.startsWith("Command") || child.name.startsWith("Reporter"))) {
          diagnostics.push(getDiagnostic(view, node, "Argument is reserved _"));
        } else {
          diagnostics.push(getDiagnostic(view, node, "Argument is invalid _"));
        }
      } else if (((_b = node.node.parent) == null ? void 0 : _b.name) == "SetVariable") {
        if (((_c = node.node.prevSibling) == null ? void 0 : _c.name) == "Set") {
          diagnostics.push(getDiagnostic(view, node.node, "Term _ reserved", "error", value, "Local variable"));
        } else {
          diagnostics.push(getDiagnostic(view, node, "Unrecognized statement _"));
        }
      } else if (!["[", "]", ")", "(", '"'].includes(value) && !checkUndefinedBreed(diagnostics, context.preprocessState, view, node.node)) {
        if (checkUnrecognizedWithSuggestions(diagnostics, view, node)) return;
        if (((_d = node.node.parent) == null ? void 0 : _d.name) == "Normal") {
          diagnostics.push(getDiagnostic(view, node, "Unrecognized global statement _"));
        } else {
          if (((_e = node.node.firstChild) == null ? void 0 : _e.node.name) == "Identifier" && ((_f = node.node.lastChild) == null ? void 0 : _f.node.name) == "Identifier" && node.node.getChildren("Identifier").length == 1) {
            diagnostics.push(getDiagnostic(view, node, "Unrecognized identifier _"));
          } else {
            diagnostics.push(getDiagnostic(view, node, "Unrecognized statement _"));
          }
        }
      } else if (["[", "]", ")", "(", '"'].includes(value) && ((_g = node.node.parent) == null ? void 0 : _g.name) == "Breed") {
        diagnostics.push(getDiagnostic(view, node.node.parent, "Missing breed names _"));
      }
    }
  });
  return diagnostics;
};

// src/lang/linters/argument-linter.ts
import { syntaxTree as syntaxTree12 } from "@codemirror/language";
var primitives4 = PrimitiveManager;
var ArgumentLinter = (view, preprocessContext, lintContext) => {
  const diagnostics = [];
  syntaxTree12(view.state).cursor().iterate((noderef) => {
    var _a;
    if (
      // Checking let/set statements
      noderef.name == "SetVariable" && (noderef.node.getChildren("VariableName").length != 1 || noderef.node.getChildren("Value").length + noderef.node.getChildren("ReporterStatement").length != 1) || noderef.name == "NewVariableDeclaration" && (noderef.node.getChildren("Identifier").length + noderef.node.getChildren("UnsupportedPrim").length != 1 || noderef.node.getChildren("Value").length + noderef.node.getChildren("ReporterStatement").length != 1)
    ) {
      let func = noderef.name == "SetVariable" ? "Set" : "Let";
      let expected = 2;
      let child_count = 0;
      let cursor = noderef.node.cursor();
      if (cursor.firstChild()) {
        while (cursor.nextSibling()) {
          if (cursor.from != cursor.to) child_count++;
        }
      }
      let actual = child_count;
      if (actual < expected) {
        diagnostics.push(
          getDiagnostic(
            view,
            noderef.node,
            "Too few right args for _. Expected _, found _.",
            "error",
            func,
            expected.toString(),
            actual.toString()
          )
        );
      }
    } else if (noderef.name == "ReporterStatement" || noderef.name == "CommandStatement") {
      const Node = noderef.node;
      if (((_a = Node.firstChild) == null ? void 0 : _a.name) == "\u26A0") diagnostics.push(getDiagnostic(view, Node, "Missing command _"));
      let args = getArgs(Node);
      if (Node.getChildren("VariableDeclaration").length == 0 && args.func) {
        const result = checkValidNumArgs(view.state, args, preprocessContext);
        let error_type = result[0];
        let func = result[1];
        let expected = result[2];
        let actual = result[3];
        if (func == null || expected == null || actual == null) {
        } else if (error_type == "no primitive") {
          diagnostics.push(
            getDiagnostic(
              view,
              noderef.node,
              "Problem identifying primitive _. Expected _, found _.",
              "error",
              func.toString(),
              expected.toString(),
              actual.toString()
            )
          );
        } else if (error_type == "left") {
          diagnostics.push(
            getDiagnostic(
              view,
              noderef.node,
              "Left args for _. Expected _, found _.",
              "error",
              func.toString(),
              expected.toString(),
              actual.toString()
            )
          );
        } else if (error_type == "rightmin") {
          diagnostics.push(
            getDiagnostic(
              view,
              noderef.node,
              "Too few right args for _. Expected _, found _.",
              "error",
              func.toString(),
              expected.toString(),
              actual.toString()
            )
          );
        } else if (error_type == "rightmax") {
          diagnostics.push(
            getDiagnostic(
              view,
              noderef.node,
              "Too many right args for _. Expected _, found _.",
              "error",
              func.toString(),
              expected.toString(),
              actual.toString()
            )
          );
        }
      }
      if (args.func) {
        let funcName = getCodeName(view.state, args.func);
        var potentialLoop = false;
        if (funcName == "while") {
          potentialLoop = args.rightArgs.length > 1 && getCodeName(view.state, args.rightArgs[0]) == "true";
        } else if (funcName == "loop") {
          potentialLoop = true;
        }
        if (potentialLoop && !checkLoopEnd(view, Node))
          diagnostics.push(getDiagnostic(view, noderef.node, "Infinite loop _", "error", funcName));
      }
    }
  });
  return diagnostics;
};
var checkLoopEnd = function(view, node) {
  let found = false;
  node.cursor().iterate((noderef) => {
    var command = getCodeName(view.state, noderef);
    if (["stop", "die", "report"].includes(command)) {
      found = true;
      return false;
    }
  });
  return found;
};
var getArgs = function(Node) {
  var _a;
  let cursor = Node.cursor();
  let args = { leftArgs: null, rightArgs: [], func: null, hasParentheses: false };
  let seenFunc = false;
  let done = false;
  if (!cursor.firstChild()) {
    return args;
  } else if (Node.resolve(Node.from, -1).name == "OpenParen" || Node.resolve(Node.from, -1).resolve(Node.from, -1).name == "OpenParen" || (((_a = Node.parent) == null ? void 0 : _a.getChildren("OpenParen").length) ?? -1) > 0) {
    args.hasParentheses = true;
  }
  while (done == false) {
    if (cursor.node.name == "OpenParen") {
      args.hasParentheses = true;
    } else if (!seenFunc && cursor.node.name == "Arg") {
      args.leftArgs = cursor.node;
    } else if (
      // collect nodes containing right args ('Commands'/'Reporters' are specifically for map, filter, etc.)
      seenFunc && (cursor.node.name == "Arg" || cursor.node.name == "Commands" || cursor.node.name == "Reporters")
    ) {
      args.rightArgs.push(cursor.node);
    } else if (
      // identify the node containing primitive
      cursor.node.name.includes("Command") && !cursor.node.name.includes("Commands") && !cursor.node.name.includes("CommandStatement") || cursor.node.name.includes("Reporter") && !cursor.node.name.includes("Reporters") && !cursor.node.name.includes("ReporterStatement")
    ) {
      args.func = cursor.node;
      seenFunc = true;
    }
    if (!cursor.nextSibling()) {
      done = true;
    }
  }
  return args;
};
var checkValidNumArgs = function(state, args, preprocessContext) {
  var _a, _b, _c, _d, _e;
  let func = getCodeName(state, args.func);
  if (func == "-") {
    if (!args.hasParentheses && !args.leftArgs) {
      Log("left args");
      let expected = 1;
      let actual = args.leftArgs ? 1 : 0;
      Log("left", expected, actual);
      return ["left", func, expected, actual];
    } else if (args.rightArgs.length > 1) {
      return ["rightmax", func, 1, args.rightArgs.length];
    } else {
      return [true, func, 0, 0];
    }
  }
  let funcRef = func;
  let name2 = ((_a = args.func) == null ? void 0 : _a.name) ?? "";
  if (name2.includes("Special")) {
    switch (name2) {
      case "SpecialCommandCreateTurtle":
        name2 = "Command2Args";
        funcRef = "create-turtles";
        break;
      case "SpecialCommandCreateLink":
        name2 = "Command2Args";
        funcRef = "create-links-with";
        break;
      default:
        let numArgs = preprocessContext.Commands.get(func) ?? preprocessContext.Reporters.get(func) ?? getBreedProcedureArgs(name2);
        return [numArgs == args.rightArgs.length, func, numArgs, args.rightArgs.length];
    }
  }
  let primitive = primitives4.GetNamedPrimitive(funcRef);
  if (!primitive) {
    Log("no primitive", (_b = args.func) == null ? void 0 : _b.name, func);
    return ["no primitive", func, 0, 0];
  } else if (
    // checks for incorrect numbers of arguments on the left side
    ((_c = primitive.LeftArgumentType) == null ? void 0 : _c.Types[0]) == 0 /* Unit */ && args.leftArgs || ((_d = primitive.LeftArgumentType) == null ? void 0 : _d.Types[0]) != 0 /* Unit */ && !args.leftArgs
  ) {
    Log("left args");
    let expected = ((_e = primitive.LeftArgumentType) == null ? void 0 : _e.Types[0]) != 0 /* Unit */ ? 1 : 0;
    let actual = args.leftArgs ? 1 : 0;
    Log("left", expected, actual);
    return ["left", func, expected, actual];
  } else {
    let rightArgMin = 0;
    let rightArgMax = 0;
    if ((name2.includes("APCommand") || name2.includes("Var")) && !args.hasParentheses) {
      name2 = name2.replace("Command", "");
      name2 = name2.replace("ArgsVar", "");
      rightArgMin = Number(name2[0]);
      rightArgMax = Number(name2[0]);
    } else {
      rightArgMin = args.hasParentheses ? primitive.MinimumOption ?? primitive.DefaultOption ?? primitive.RightArgumentTypes.filter((arg) => arg.Optional == false).length : primitive.DefaultOption ?? primitive.RightArgumentTypes.filter((arg) => arg.Optional == false).length;
      rightArgMax = primitive.RightArgumentTypes.filter((arg) => arg.CanRepeat).length > 0 && args.hasParentheses ? 100 : primitive.DefaultOption ?? primitive.RightArgumentTypes.length;
    }
    if (args.rightArgs.length < rightArgMin) {
      Log(args.rightArgs);
      Log(func, "rightargs", rightArgMin, rightArgMax, args.rightArgs.length);
      return ["rightmin", func, rightArgMin, args.rightArgs.length];
    } else if (args.rightArgs.length > rightArgMax) {
      return ["rightmax", func, rightArgMax, args.rightArgs.length];
    } else {
      return [true, func, 0, 0];
    }
  }
};
var getBreedProcedureArgs = function(func_type) {
  let match = func_type.match(/[A-Za-z]*(\d)[A-Za-z]*/);
  if (match) {
    return parseInt(match[1]);
  } else {
    return null;
  }
};

// src/lang/linters/unsupported-linter.ts
import { syntaxTree as syntaxTree13 } from "@codemirror/language";
var UnsupportedLinter = (view, preprocessContext, lintContext) => {
  const diagnostics = [];
  const context = getCheckContext(view, lintContext, preprocessContext);
  let indices = [];
  syntaxTree13(view.state).cursor().iterate((node) => {
    var _a, _b, _c, _d, _e;
    if (indices.includes(node.from)) return;
    const value = getCodeName(view.state, node);
    if (unsupported.includes(value)) {
      indices.push(node.from);
      diagnostics.push({
        from: node.from,
        to: node.to,
        severity: "warning",
        message: Localized.Get("Unsupported statement _", value)
      });
    }
    if (node.name.includes("Unsupported") && ((_a = node.node.parent) == null ? void 0 : _a.name) != "VariableName" && ((_b = node.node.parent) == null ? void 0 : _b.name) != "NewVariableDeclaration" && ((_c = node.node.parent) == null ? void 0 : _c.name) != "Arguments" && ((_d = node.node.parent) == null ? void 0 : _d.name) != "AnonArguments" && ((_e = node.node.parent) == null ? void 0 : _e.name) != "ProcedureName" && !checkValidIdentifier(node.node, value, context)) {
      indices.push(node.from);
      diagnostics.push({
        from: node.from,
        to: node.to,
        severity: "warning",
        message: Localized.Get("Unsupported extension statement _", value)
      });
    }
  });
  return diagnostics;
};

// src/lang/linters/extension-linter.ts
import { syntaxTree as syntaxTree14 } from "@codemirror/language";
var primitives5 = PrimitiveManager;
var ExtensionLinter = (view, preprocessContext, lintContext) => {
  const diagnostics = [];
  let foundExtension = false;
  let extension_index = 0;
  let extension_node = null;
  const context = getCheckContext(view, lintContext, preprocessContext);
  syntaxTree14(view.state).cursor().iterate((noderef) => {
    var _a, _b, _c, _d;
    if (noderef.name == "Extensions") {
      noderef.node.getChildren("Identifier").map((child) => {
        let name2 = getCodeName(view.state, child);
        if (primitives5.GetExtensions().indexOf(name2) == -1)
          diagnostics.push(getDiagnostic(view, child, "Unsupported extension _", "warning"));
      });
      noderef.node.getChildren("CloseBracket").map((child) => {
        extension_index = child.from;
        foundExtension = true;
        extension_node = noderef.node;
      });
    } else if ((noderef.name.includes("Args") || noderef.name.includes("Unsupported") && ((_a = noderef.node.parent) == null ? void 0 : _a.name) != "VariableName" && ((_b = noderef.node.parent) == null ? void 0 : _b.name) != "Arguments" && ((_c = noderef.node.parent) == null ? void 0 : _c.name) != "AnonArguments" && ((_d = noderef.node.parent) == null ? void 0 : _d.name) != "ProcedureName" && !checkValidIdentifier(noderef.node, getCodeName(view.state, noderef), context)) && !noderef.name.includes("Special")) {
      const value = getCodeName(view.state, noderef);
      let vals = value.split(":");
      if (vals.length <= 1 || lintContext.Extensions.has(vals[0])) return;
      diagnostics.push(
        addGlobalsAction(
          getDiagnostic(
            view,
            noderef,
            !noderef.name.includes("Unsupported") ? "Missing extension _" : "Unsupported missing extension _",
            "error",
            vals[0]
          ),
          "Extensions",
          [vals[0]]
        )
      );
    }
  });
  return diagnostics;
};

// src/lang/linters/naming-linter.ts
import { syntaxTree as syntaxTree15 } from "@codemirror/language";
var primitives6 = PrimitiveManager;
var NamingLinter = (view, preprocessContext, lintContext) => {
  const diagnostics = [];
  let defined = [];
  let breedDefined = [];
  let reserved2 = ["turtles", "turtle", "patches", "patch", "links", "link"];
  let reservedVars = GetAllBreedPrimitives(lintContext);
  reservedVars.push(...turtleVars);
  reservedVars.push(...patchVars);
  reservedVars.push(...linkVars);
  var NameCheck = (node, type, extra, isBreed = false) => {
    const value = getCodeName(view.state, node);
    if (defined.includes(value) || (extra == null ? void 0 : extra.includes(value)) || !isBreed && breedDefined.includes(value)) {
      diagnostics.push(getDiagnostic(view, node, "Term _ already used", "error", value, type));
    } else if (reservedVars.includes(value)) {
      if (type.includes("variable")) {
        if (type != "Local variable")
          diagnostics.push(removeAction(getDiagnostic(view, node, "Variable _ reserved", "error", value, type)));
        else diagnostics.push(getDiagnostic(view, node, "Variable _ reserved", "error", value, type));
      } else {
        diagnostics.push(getDiagnostic(view, node, "Term _ reserved", "error", value, type));
      }
    } else if (reserved2.includes(value) || primitives6.GetNamedPrimitive(value)) {
      diagnostics.push(getDiagnostic(view, node, "Term _ reserved", "error", value, type));
    } else {
      if (extra) extra.push(value);
      else {
        defined.push(value);
      }
    }
  };
  var Mode = view.state.field(stateExtension).Mode;
  if (Mode != "Normal" /* Normal */ && Mode != "Generative" /* Generative */) {
    defined.push(...lintContext.GetDefined());
    syntaxTree15(view.state).cursor().iterate((noderef) => {
      if (noderef.name == "NewVariableDeclaration") {
        let child = noderef.node.getChild("Identifier") ?? noderef.node.getChild("UnsupportedPrim");
        if (!child) return;
        let localvars = getLocalVariables(child, view.state, lintContext);
        NameCheck(child, "Local variable", localvars);
      }
    });
  } else {
    syntaxTree15(view.state).cursor().iterate((noderef) => {
      var _a, _b, _c, _d;
      if (noderef.name == "BreedSingular" || noderef.name == "BreedPlural") {
        NameCheck(noderef, "Breed");
      } else if (noderef.name == "Identifier" && ((_a = noderef.node.parent) == null ? void 0 : _a.name) == "Globals") {
        NameCheck(noderef, "Global variable");
      } else if (noderef.name == "ProcedureName") {
        if (((_b = noderef.node.parent) == null ? void 0 : _b.getChildren("To").length) == 0) {
          diagnostics.push(getDiagnostic(view, noderef, "Unrecognized global statement _", "error"));
        } else {
          NameCheck(noderef, "Procedure");
        }
      } else if (noderef.name == "BreedsOwn") {
        let own = noderef.node.getChild("Own");
        let breedvars = [];
        if (!own) return;
        let breedName = getCodeName(view.state, noderef);
        breedName = breedName.substring(0, breedName.length - 4);
        noderef.node.getChildren("Identifier").map((child) => {
          if (breedName == "turtles") {
            NameCheck(child, "Turtle variable");
          } else if (breedName == "links") {
            NameCheck(child, "Link variable");
          } else if (breedName == "patches") {
            NameCheck(child, "Patch variable");
          } else if (isLinkBreed(breedName, lintContext)) {
            NameCheck(child, "Link variable", breedvars, true);
          } else {
            NameCheck(child, "Turtle variable", breedvars, true);
          }
        });
        breedDefined.push(...breedvars);
      } else if (noderef.name == "NewVariableDeclaration" || noderef.name == "SetVariable") {
        let child = (_c = noderef.node.firstChild) == null ? void 0 : _c.nextSibling;
        if (!child) return;
        if (child.name.includes("Reporter") || child.name.includes("Command")) {
          const value = getCodeName(view.state, child);
          diagnostics.push(getDiagnostic(view, child, "Term _ reserved", "error", value, "Local variable"));
        } else if (noderef.name == "NewVariableDeclaration") {
          let localvars = getLocalVariables(child, view.state, lintContext);
          NameCheck(child, "Local variable", localvars);
        }
      } else if (noderef.name == "Arguments") {
        let current = [];
        if (((_d = noderef.node.parent) == null ? void 0 : _d.name) == "AnonArguments") {
          let parent = noderef.node.parent.parent;
          if (parent) {
            let prev_node = parent == null ? void 0 : parent.cursor().moveTo(parent.from - 2).node;
            current = getLocalVariables(prev_node, view.state, lintContext);
          }
        }
        for (var key of ["Identifier", "UnsupportedPrim"]) {
          noderef.node.getChildren(key).map((child) => {
            NameCheck(child, "Argument", current);
          });
        }
      }
    });
  }
  return diagnostics;
};
var isLinkBreed = (breedName, lintContext) => {
  for (var [name2, breed] of lintContext.Breeds) {
    if (breed.Plural.toLowerCase() == breedName.toLowerCase()) {
      return breed.BreedType == 3 /* DirectedLink */ || breed.BreedType == 2 /* UndirectedLink */;
    }
  }
  return null;
};

// src/lang/linters/bracket-linter.ts
import { matchBrackets, syntaxTree as syntaxTree16 } from "@codemirror/language";
var BracketLinter = (view, preprocessContext, lintContext) => {
  const diagnostics = [];
  syntaxTree16(view.state).cursor().iterate((node) => {
    if (["OpenParen", "CloseParen", "OpenBracket", "CloseBracket"].includes(node.name)) {
      let parents = [];
      let curr = node.node;
      while (curr.parent) {
        parents.push(curr.parent.name);
        curr = curr.parent;
      }
      if (["OpenBracket", "OpenParen"].includes(node.name)) {
        let match = matchBrackets(view.state, node.from, 1);
        if (match && match.matched) return;
      }
      let current = "", expected = "";
      if (test_function(node, "OpenBracket", "CloseBracket")) {
        current = "[";
        expected = "]";
      } else if (test_function(node, "CloseBracket", "OpenBracket")) {
        current = "]";
        expected = "[";
      } else if (test_function(node, "OpenParen", "CloseParen")) {
        current = "(";
        expected = ")";
      } else if (test_function(node, "CloseParen", "OpenParen")) {
        current = ")";
        expected = "(";
      }
      if (current != "") diagnostics.push(getDiagnostic(view, node, "Unmatched item _", "error", current, expected));
    }
  });
  return diagnostics;
};
var test_function = function(node, name2, match_name) {
  var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j;
  let num_paren = 1;
  if (((_a = node.node.parent) == null ? void 0 : _a.name) && ["NewVariableDeclaration", "SetVariable"].includes((_b = node.node.parent) == null ? void 0 : _b.name)) {
    num_paren = 2;
  }
  return node.name == name2 && (((_c = node.node.parent) == null ? void 0 : _c.name) != "\u26A0" && ((_d = node.node.parent) == null ? void 0 : _d.getChildren(match_name).length) != num_paren && ((_f = (_e = node.node.parent) == null ? void 0 : _e.getChild("\u26A0")) == null ? void 0 : _f.getChildren(match_name).length) != num_paren || ((_g = node.node.parent) == null ? void 0 : _g.name) == "\u26A0" && ((_h = node.node.parent) == null ? void 0 : _h.getChildren(match_name).length) != 1 && ((_j = (_i = node.node.parent) == null ? void 0 : _i.parent) == null ? void 0 : _j.getChildren(match_name).length) != 1);
};

// src/lang/linters/mode-linter.ts
import { syntaxTree as syntaxTree17 } from "@codemirror/language";
var ModeLinter = (view, preprocessContext, lintContext, state) => {
  var mode = state.Mode;
  const diagnostics = [];
  if (view.state.doc.length == 0 || mode == "Generative" /* Generative */) return diagnostics;
  var node = syntaxTree17(view.state).cursor().node;
  if (node.name != "Program") return diagnostics;
  var unexpected = null;
  unexpected = unexpected ?? CheckMode(node, "OneLineReporter", mode);
  unexpected = unexpected ?? CheckMode(node, "Embedded", mode);
  unexpected = unexpected ?? CheckMode(node, "Normal", mode);
  if (unexpected != null) {
    diagnostics.push(getDiagnostic(view, unexpected, `Invalid for ${mode} mode _`));
    return diagnostics;
  }
  if (mode != "Normal" /* Normal */) {
    for (let name2 of ["Unrecognized", "Procedure", "Extensions", "Globals", "Breed", "BreedsOwn"]) {
      node.getChildren(name2).map((child) => {
        diagnostics.push(getDiagnostic(view, child, `Invalid for ${mode} mode _`));
      });
    }
  }
  return diagnostics;
};
var GetMode = function(Node, Mode) {
  return Node.getChild(Mode);
};
var CheckMode = function(Node, Mode, Expected) {
  var Current = GetMode(Node, Mode);
  if (Current == null) return null;
  if (Expected == Mode) return null;
  if (Expected == "Oneline" /* Oneline */ && (Mode == "OneLineReporter" || Mode == "Embedded")) return null;
  return Current;
};

// src/lang/linters/context-linter.ts
var ContextLinter = (view, preprocessContext, lintContext) => {
  const diagnostics = [];
  let stateNetLogo = view.state.field(stateExtension);
  for (let c of stateNetLogo.ContextErrors) {
    diagnostics.push(
      getDiagnostic(
        view,
        { from: c.From, to: c.To },
        "Invalid context _",
        "error",
        contextToString(c.PriorContext),
        contextToString(c.ConflictingContext),
        c.Primitive
      )
    );
  }
  return diagnostics;
};
var contextToString = function(context) {
  let contexts = [];
  if (context.Observer) contexts.push(Localized.Get("Observer"));
  if (context.Turtle) contexts.push(Localized.Get("Turtle"));
  if (context.Patch) contexts.push(Localized.Get("Patch"));
  if (context.Link) contexts.push(Localized.Get("Link"));
  return contexts.join("/");
};

// src/lang/linters/codeblock-linter.ts
import { syntaxTree as syntaxTree18 } from "@codemirror/language";
var CodeBlockLinter = (view, preprocessContext, lintContext) => {
  const diagnostics = [];
  syntaxTree18(view.state).cursor().iterate((node) => {
    if (node.name != "CodeBlock" && node.name != "Embedded") return;
    let cursor = node.node.cursor();
    let isCodeBlock = null;
    if (!cursor.firstChild()) return;
    while (cursor.nextSibling()) {
      var name2 = cursor.name;
      if (isCodeBlock == null) {
        if (!["LineComment", "OpenBracket", "CloseBracket"].includes(name2))
          isCodeBlock = cursor.name == "ProcedureContent";
        else continue;
      }
      if (isCodeBlock && !["LineComment", "OpenBracket", "CloseBracket", "ProcedureContent"].includes(name2)) {
        if (name2 !== "Identifier")
          diagnostics.push(getDiagnostic(view, cursor, "Invalid content for code block _", "error"));
      } else if (!isCodeBlock && cursor.name == "ProcedureContent") {
        diagnostics.push(getDiagnostic(view, cursor, "Invalid content for list _", "error"));
      }
    }
  });
  return diagnostics;
};

// src/lang/linters/reporter-linter.ts
import { syntaxTree as syntaxTree19 } from "@codemirror/language";
var ReporterLinter = (view, preprocessContext, lintContext) => {
  var _a, _b;
  const diagnostics = [];
  (_b = (_a = syntaxTree19(view.state).topNode) == null ? void 0 : _a.firstChild) == null ? void 0 : _b.getChildren("Procedure").map((proc) => {
    let to_node = proc.node.getChild("To");
    let is_reporter = getCodeName(view.state, to_node ?? proc.node) == "to-report";
    let found_report = false;
    let reporter_node = null;
    syntaxTree19(view.state).iterate({
      enter: (node) => {
        if (node.name == "Command1Args" && getCodeName(view.state, node.node) == "report") {
          found_report = true;
          reporter_node = node.node;
        }
      },
      from: proc.from,
      to: proc.to
    });
    if (is_reporter && !found_report && to_node) {
      let diagnostic = getDiagnostic(view, to_node, "Invalid to-report _", "error", "to-report");
      AddReplaceAction(diagnostic, "to");
      diagnostics.push(diagnostic);
    } else if (!is_reporter && found_report && reporter_node && to_node) {
      diagnostics.push(getDiagnostic(view, reporter_node, "Invalid report _", "error", "report"));
      let diagnostic = getDiagnostic(view, to_node, "Invalid report warning _", "warning", "report");
      AddReplaceAction(diagnostic, "to-report");
      diagnostics.push(diagnostic);
    }
  });
  return diagnostics;
};

// src/lang/linters/linters.ts
var netlogoLinters = [
  UnrecognizedLinter,
  UnrecognizedGlobalLinter,
  IdentifierLinter,
  ArgumentLinter,
  UnsupportedLinter,
  ExtensionLinter,
  NamingLinter,
  BracketLinter,
  ModeLinter,
  ContextLinter,
  CodeBlockLinter,
  ReporterLinter
];

// src/lang/linters/runtime-linter.ts
var CompilerLinter = (view) => {
  var state = view.state.field(stateExtension);
  return state.CompilerErrors.map(function(Error2) {
    return {
      from: Error2.start,
      to: Error2.end,
      severity: "error",
      message: Error2.message
    };
  });
};
var RuntimeLinter = (view) => {
  var state = view.state.field(stateExtension);
  return state.RuntimeErrors.map(function(Error2) {
    return {
      from: Error2.start,
      to: Error2.end,
      severity: "error",
      message: Error2.message
    };
  });
};

// src/features/editing.ts
import {
  replaceAll,
  selectMatches,
  SearchQuery,
  findNext,
  gotoLine,
  replaceNext,
  setSearchQuery,
  openSearchPanel,
  closeSearchPanel
} from "@codemirror/search";
import { undo, redo } from "@codemirror/commands";
var EditingFeatures = class {
  /** Constructor: Initialize the editing features. */
  constructor(Galapagos) {
    this.Galapagos = Galapagos;
    this.CodeMirror = Galapagos.CodeMirror;
    this.Parent = Galapagos.Parent;
  }
  // #region "Find and Replace"
  /** Undo: Make the editor undo. Returns false if no group was available. */
  Undo() {
    return undo(this.CodeMirror);
  }
  /** Redo: Make the editor Redo. Returns false if no group was available. */
  Redo() {
    return redo(this.CodeMirror);
  }
  /** Find: Find a keyword in the editor and loop over all matches. */
  Find(Keyword) {
    var _a;
    openSearchPanel(this.CodeMirror);
    let prevValue = ((_a = this.Parent.querySelector('.cm-textfield[name="search"]')) == null ? void 0 : _a.value) ?? "";
    this.CodeMirror.dispatch({
      effects: setSearchQuery.of(new SearchQuery({ search: Keyword }))
    });
    findNext(this.CodeMirror);
    this.CodeMirror.dispatch({
      effects: setSearchQuery.of(new SearchQuery({ search: prevValue }))
    });
    closeSearchPanel(this.CodeMirror);
  }
  /** Replace: Loop through the matches and replace one at a time. */
  Replace(Source, Target) {
    var _a, _b;
    openSearchPanel(this.CodeMirror);
    let prevFind = ((_a = this.Parent.querySelector('.cm-textfield[name="search"]')) == null ? void 0 : _a.value) ?? "";
    let prevReplace = ((_b = this.Parent.querySelector('.cm-textfield[name="replace"]')) == null ? void 0 : _b.value) ?? "";
    this.CodeMirror.dispatch({
      effects: setSearchQuery.of(
        new SearchQuery({
          search: Source,
          replace: Target
        })
      )
    });
    replaceNext(this.CodeMirror);
    findNext(this.CodeMirror);
    this.CodeMirror.dispatch({
      effects: setSearchQuery.of(
        new SearchQuery({
          search: prevFind,
          replace: prevReplace
        })
      )
    });
    closeSearchPanel(this.CodeMirror);
  }
  /** FindAll: Find all the matching words in the editor. */
  FindAll(Source) {
    var _a;
    openSearchPanel(this.CodeMirror);
    let prevValue = ((_a = this.Parent.querySelector('.cm-textfield[name="search"]')) == null ? void 0 : _a.value) ?? "";
    this.CodeMirror.dispatch({
      effects: setSearchQuery.of(new SearchQuery({ search: Source }))
    });
    selectMatches(this.CodeMirror);
    this.CodeMirror.dispatch({
      effects: setSearchQuery.of(new SearchQuery({ search: prevValue }))
    });
    closeSearchPanel(this.CodeMirror);
  }
  /** ReplaceAll: Replace the all the matching words in the editor. */
  ReplaceAll(Source, Target) {
    var _a, _b;
    openSearchPanel(this.CodeMirror);
    let prevFind = ((_a = this.Parent.querySelector('.cm-textfield[name="search"]')) == null ? void 0 : _a.value) ?? "";
    let prevReplace = ((_b = this.Parent.querySelector('.cm-textfield[name="replace"]')) == null ? void 0 : _b.value) ?? "";
    this.CodeMirror.dispatch({
      effects: setSearchQuery.of(
        new SearchQuery({
          search: Source,
          replace: Target
        })
      )
    });
    replaceAll(this.CodeMirror);
    this.CodeMirror.dispatch({
      effects: setSearchQuery.of(
        new SearchQuery({
          search: prevFind,
          replace: prevReplace
        })
      )
    });
    closeSearchPanel(this.CodeMirror);
  }
  /** JumpTo: Jump to a certain line. */
  JumpTo(Line2) {
    const { state } = this.CodeMirror;
    const docLine = state.doc.line(Math.max(1, Math.min(state.doc.lines, Line2)));
    this.CodeMirror.dispatch({
      selection: { anchor: docLine.from },
      scrollIntoView: true
    });
  }
  // #endregion
  // #region "Editor Interfaces"
  /** ShowFind: Show the finding interface. */
  ShowFind() {
    this.HideAll();
    openSearchPanel(this.CodeMirror);
    const input = this.Parent.querySelector('.cm-textfield[name="replace"]');
    if (input) input.style.display = "none";
    const button1 = this.Parent.querySelector('.cm-button[name="replace"]');
    if (button1) button1.style.display = "none";
    const button2 = this.Parent.querySelector('.cm-button[name="replaceAll"]');
    if (button2) button2.style.display = "none";
  }
  /** ShowReplace: Show the replace interface. */
  ShowReplace() {
    this.HideAll();
    openSearchPanel(this.CodeMirror);
    const input = this.Parent.querySelector('.cm-textfield[name="replace"]');
    if (input) input.style.display = "inline-block";
    const button1 = this.Parent.querySelector('.cm-button[name="replace"]');
    if (button1) button1.style.display = "inline-block";
    const button2 = this.Parent.querySelector('.cm-button[name="replaceAll"]');
    if (button2) button2.style.display = "inline-block";
  }
  /** ShowJumpTo: Show the jump-to-line interface. */
  ShowJumpTo() {
    this.HideAll();
    closeSearchPanel(this.CodeMirror);
    const jumpElm = this.Parent.querySelector(".cm-gotoLine");
    jumpElm ? jumpElm.style.display = "flex" : gotoLine(this.CodeMirror);
  }
  /** HideJumpTo: Hide line interface. */
  HideJumpTo() {
    const jumpElm = this.Parent.querySelector(".cm-gotoLine");
    if (jumpElm) jumpElm.style.display = "none";
  }
  /** HideAllInterfaces: Hide all interfaces available. */
  HideAll() {
    closeSearchPanel(this.CodeMirror);
    this.HideJumpTo();
  }
  /** ShowProcedures: Show a list of procedures for the user to jump to. */
  ShowProcedures() {
  }
  // #endregion
};

// src/features/selection.ts
import { selectAll } from "@codemirror/commands";
import { Decoration as Decoration2, EditorView as EditorView6 } from "@codemirror/view";
import { diffWords } from "diff";
import { SearchCursor } from "@codemirror/search";

// src/codemirror/widgets-changes.ts
import { WidgetType as WidgetType2 } from "@codemirror/view";
var TextWidget = class extends WidgetType2 {
  constructor(text, className = "") {
    super();
    this.text = text;
    this.className = className;
  }
  toDOM() {
    let wrap = document.createElement("span");
    wrap.setAttribute("aria-hidden", "true");
    wrap.className = `cm-text ${this.className}`;
    wrap.textContent = this.text;
    return wrap;
  }
};

// src/features/selection.ts
var SelectionFeatures = class {
  /** Constructor: Initialize the editing features. */
  constructor(Galapagos) {
    this.Galapagos = Galapagos;
    this.CodeMirror = Galapagos.CodeMirror;
  }
  // #region "Selection and Cursor"
  /** SelectAll: Select all text in the editor. */
  SelectAll() {
    selectAll(this.CodeMirror);
    this.CodeMirror.focus();
  }
  /** Select: Select and scroll to a given range in the editor. */
  Select(Start, End2) {
    if (End2 > this.CodeMirror.state.doc.length || Start < 0 || Start > End2) {
      return;
    }
    this.CodeMirror.dispatch({
      selection: { anchor: Start, head: End2 },
      scrollIntoView: true
    });
    this.CodeMirror.focus();
  }
  /** GetSelection: Returns an object of the start and end of
   *  a selection in the editor. */
  GetSelection() {
    return {
      from: this.CodeMirror.state.selection.main.from,
      to: this.CodeMirror.state.selection.main.to
    };
  }
  /** GetSelections: Get the selections of the editor. */
  GetSelections() {
    return this.CodeMirror.state.selection.ranges;
  }
  /** GetCursorPosition: Set the cursor position of the editor. */
  GetCursorPosition() {
    var _a;
    return ((_a = this.CodeMirror.state.selection.ranges[0]) == null ? void 0 : _a.from) ?? 0;
  }
  /** SetCursorPosition: Set the cursor position of the editor. */
  SetCursorPosition(position) {
    this.CodeMirror.dispatch({
      selection: { anchor: position },
      scrollIntoView: true
    });
  }
  /** RefreshCursor: Refresh the cursor position. */
  RefreshCursor() {
    this.SetCursorPosition(this.GetCursorPosition());
  }
  // #endregion
  // #region "Highlighting Changes"
  /** HighlightChanges: Highlight the changes in the editor. */
  HighlightChanges(PreviousVersion) {
    let clicked = false;
    const CurrentVersion = this.CodeMirror.state.doc.toString();
    const currentState = this.CodeMirror.state;
    const editorView = this.CodeMirror;
    const diff = diffWords(PreviousVersion, CurrentVersion);
    const removed = diff.filter((part) => part.removed).map((part) => part.value.replace("\n", "\u21B5\n"));
    const added = diff.filter((part) => part.added).map((part) => part.value);
    const removedEffect = StateEffect.define({
      map: ({ from, to }, change) => ({ from: change.mapPos(from), to: change.mapPos(to) })
    });
    const addTextWidget = StateEffect.define({
      map: ({ from, to }, change) => ({ from: change.mapPos(from), to: change.mapPos(to) })
    });
    const addedMark = Decoration2.mark({ attributes: { class: "cm-added" } });
    let removedIndex = 0;
    const changesField = StateField.define({
      create() {
        return Decoration2.none;
      },
      update(value, tr) {
        value = value.map(tr.changes);
        for (let e of tr.effects) {
          if (e.is(removedEffect)) {
            value = value.update({
              add: [addedMark.range(e.value.from, e.value.to)]
            });
          } else if (e.is(addTextWidget)) {
            let decorationWidget = Decoration2.widget({
              widget: new TextWidget(removed[removedIndex], "cm-removed"),
              // if it is a removed word then add a "removed" widget decoration
              side: 1
            });
            removedIndex++;
            value = value.update({
              add: [decorationWidget.range(e.value.to)]
            });
          }
        }
        return value;
      },
      provide: (f) => EditorView6.decorations.from(f)
    });
    function highlightAdded(view, word) {
      let effects = [];
      let cursor = new SearchCursor(view.state.doc, word, 0);
      cursor.next();
      effects.push(
        removedEffect.of({
          from: cursor.value.from,
          to: cursor.value.to
        })
      );
      if (!effects.length) return false;
      if (!view.state.field(changesField, false)) {
        effects.push(StateEffect.appendConfig.of([changesField]));
      }
      view.dispatch({ effects });
      return true;
    }
    function makeWidget(view, end, type = "text") {
      let effects = [];
      if (type === "text") {
        effects.push(
          addTextWidget.of({
            from: 0,
            to: end
          })
        );
      }
      if (!effects.length) return false;
      effects.push(StateEffect.appendConfig.of([changesField]));
      view.dispatch({ effects });
      return true;
    }
    added.forEach((word) => highlightAdded(this.CodeMirror, word));
    let currentPos = 0;
    diff.forEach((part) => {
      if (part.removed) {
        makeWidget(this.CodeMirror, currentPos);
      } else {
        currentPos += part.value.length;
      }
    });
    function sleep(ms) {
      return new Promise((resolve) => setTimeout(resolve, ms));
    }
    function revert(view, state) {
      view.setState(state);
      return;
    }
    const removeChangesField = StateField.define({
      create() {
        Decoration2.none;
      },
      update(lines, tr) {
        if (tr.selection && !clicked) {
          console.log("selection changed ");
          sleep(50).then(() => {
            revert(editorView, currentState);
            clicked = false;
          });
        }
        return;
      }
    });
    this.CodeMirror.dispatch({
      effects: StateEffect.appendConfig.of([removeChangesField])
    });
  }
  // #endregion
};

// src/codemirror/prettify.ts
import { indentRange as indentRange2, syntaxTree as syntaxTree20 } from "@codemirror/language";
var prettify = function(view, from = null, to = null) {
  if (from && to) {
    view.dispatch({ selection: { anchor: from, head: to } });
  }
  from = view.state.selection.main.from;
  to = view.state.selection.main.to;
  let doc = view.state.doc.toString().substring(from, to);
  let new_doc = removeSpacingRegex(doc);
  view.dispatch(view.state.replaceSelection(new_doc));
  view.dispatch({ selection: { anchor: from, head: from + new_doc.length } });
  view.dispatch({
    changes: addSpacing(view, view.state.selection.main.from, view.state.selection.main.to, 100)
  });
  from = view.state.selection.main.from;
  to = view.state.selection.main.to;
  new_doc = finalSpacing(view.state.doc.toString().substring(from, to));
  view.dispatch(view.state.replaceSelection(new_doc));
  view.dispatch({ selection: { anchor: from, head: from + new_doc.length } });
  view.dispatch({
    changes: indentRange2(view.state, view.state.selection.main.from, view.state.selection.main.to)
  });
  return view.state.selection.main.to;
};
var prettifyAll = function(view, Editor) {
  let doc = view.state.doc.toString();
  Editor.ForceParse();
  let new_doc = removeSpacing(syntaxTree20(view.state), doc);
  view.dispatch({ changes: { from: 0, to: doc.length, insert: new_doc } });
  Editor.ForceParse();
  view.dispatch({
    changes: addSpacing(view, 0, new_doc.length, Editor.LineWidth)
  });
  new_doc = finalSpacing(view.state.doc.toString());
  view.dispatch({ changes: { from: 0, to: view.state.doc.toString().length, insert: new_doc } });
  Editor.ForceParse();
  view.dispatch({
    changes: indentRange2(view.state, 0, view.state.doc.toString().length)
    //indent(view.state.doc.toString(),view.state)
  });
  if (doc != view.state.doc.toString()) Log("Prettifier made changes");
};
var doubleLineBreaks = [
  // 'LineComment',
  "GlobalStr",
  "ExtensionStr",
  "BreedStr",
  "Own",
  "To"
];
function removeSpacing(tree, doc) {
  var result = "";
  var previous = "";
  var lastPosition = 0;
  tree.iterate({
    enter: (noderef) => {
      if (noderef.node.firstChild != null) return;
      var content2 = doc.substring(noderef.from, noderef.to);
      if (previous !== "(" && content2 !== ")" && noderef.from > 0) {
        var spacing = doc.substring(lastPosition, noderef.from);
        if (doubleLineBreaks.indexOf(noderef.node.name) !== -1) {
          if (spacing.indexOf("\n\n") != -1) result += "\n\n";
          else if (spacing.indexOf("\n") != -1) result += "\n";
          else result += " ";
        } else if (noderef.name == "LineComment") {
          spacing = spacing.replace(/\n\n+/g, "\n\n");
          result += spacing;
        } else {
          if (spacing.indexOf("\n") != -1) result += "\n";
          else result += " ";
        }
      }
      result += content2;
      previous = content2;
      lastPosition = noderef.to;
    },
    mode: IterMode.IncludeAnonymous
  });
  return result;
}
function removeSpacingRegex(doc) {
  let new_doc = doc.replace(/\n[ ]+/g, "\n");
  new_doc = new_doc.replace(/(\n[^;\n]+)(\n\s*\[)/g, "$1 [");
  new_doc = new_doc.replace(/(\n[^;\n]+)(\n\s*\])/g, "$1 ]");
  new_doc = new_doc.replace(/(\[\n\s*)([\w\(])/g, "[ $2");
  new_doc = new_doc.replace(/(\n)( +)(to[ -])/g, "$1$3");
  new_doc = new_doc.replace(/ +/g, " ");
  new_doc = new_doc.replace(/[ ]+\n/g, "\n");
  new_doc = new_doc.replace(/\n\n+/g, "\n\n");
  return new_doc;
}
var finalSpacing = function(doc) {
  let new_doc = doc.replace(/\n[ ]+/g, "\n");
  new_doc = new_doc.replace(/[ ]+\n/g, "\n");
  new_doc = new_doc.replace(/\n\n+/g, "\n\n");
  new_doc = new_doc.replace(/ +/g, " ");
  new_doc = new_doc.replace(/^\s+/g, "");
  new_doc = new_doc.replace(/(\n[^;\n]+)\n[ ]*\[[ ]*\n/g, "$1 [\n");
  new_doc = new_doc.replace(/(\n+)(\n\nto[ -])/g, "$2");
  new_doc = new_doc.replace(/(\n+)(\n\n[\w-]+-own)/g, "$2");
  new_doc = new_doc.replace(/[ ]+$/, "");
  return new_doc;
};
var addSpacing = function(view, from, to, lineWidth) {
  let changes = [];
  let doc = view.state.doc.toString();
  let lastInsertedSpace = 0;
  syntaxTree20(view.state).cursor().iterate((node) => {
    var _a, _b, _c;
    if (node.from >= from && node.to <= to) {
      if ((((_a = node.node.parent) == null ? void 0 : _a.name) == "Program" && node.name != "LineComment" || node.name == "To" || node.name == "End" || node.name == "ProcedureContent" && ((_b = node.node.parent) == null ? void 0 : _b.name) != "CodeBlock") && node.from > 0 && doc[node.from - 1] != "\n") {
        changes.push({ from: node.from, to: node.from, insert: "\n" });
      } else if (node.name == "CodeBlock") {
        if (doc.substring(node.from, node.to).match(/^\s*\[\s*[^\s]+\s*\]/g)) {
          let replacement = "[ " + doc.substring(node.from, node.to).replace(/(\[|\]|\n)/g, "").trim() + " ]";
          if (doc.substring(0, node.from).match(/\n[ ]*$/)) {
            changes.push({
              from: node.from,
              to: node.to,
              insert: replacement
            });
          } else {
            changes.push({
              from: node.from,
              to: node.to,
              insert: "\n" + replacement
            });
          }
          return false;
        } else if (checkBlock(node.node, "ProcedureContent", doc, lineWidth)) {
          for (var name2 of ["ProcedureContent", "CloseBracket"]) {
            node.node.getChildren(name2).map((child) => {
              if (!doc.substring(Math.max(0, child.from - 15), child.from).replace(/[ ]/g, "").endsWith("\n")) {
                changes.push({
                  from: child.from,
                  to: child.from,
                  insert: "\n"
                });
              }
            });
          }
        }
      } else if (node.name == "ReporterBlock" && checkBlock(node.node, "ReporterStatement", doc, lineWidth)) {
        for (var name2 of ["ReporterStatement", "CloseBracket"]) {
          node.node.getChildren(name2).map((child) => {
            if (doc[child.from - 1] != "\n") {
              changes.push({
                from: child.from,
                to: child.from,
                insert: "\n"
              });
            }
          });
        }
      } else if (node.name == "CommandStatement" || node.name == "ReporterStatement") {
        let cursor = node.node.cursor();
        if (cursor.firstChild()) {
          while (cursor.node.name == "LineComment") {
            cursor.nextSibling();
          }
          let startPos = doc.substring(0, cursor.from).lastIndexOf("\n");
          let startingSpaces = doc.substring(startPos, cursor.to).match(/^\s+/);
          if (startingSpaces) {
            startPos = startPos + startingSpaces[0].length;
          }
          startPos = Math.max(startPos, lastInsertedSpace);
          let lastPos = cursor.to;
          let removeFrom = cursor.to;
          if (cursor.node.name != "Arg" && ((_c = cursor.node.nextSibling) == null ? void 0 : _c.name) == "Arg" && doc.substring(cursor.from, cursor.to).length < lineWidth && doc.substring(cursor.to, cursor.to + 1) == "\n") {
            changes.push({
              from: cursor.to,
              to: cursor.to + 1,
              insert: " "
            });
            removeFrom = cursor.to + 1;
          }
          while (cursor.nextSibling()) {
            if (cursor.node.name == "LineComment") {
              removeFrom = cursor.to + 1;
              continue;
            }
            if (removeFrom > cursor.from) {
              removeFrom = cursor.from;
            }
            if (cursor.node.name == "Arg") {
              if (doc.substring(lastPos, cursor.from).includes("\n") && doc.substring(startPos, cursor.to).replace(/\s+/g, " ").length < lineWidth) {
                changes.push({
                  from: removeFrom,
                  to: cursor.from,
                  insert: " "
                });
              } else if (doc.substring(startPos, cursor.to).length > lineWidth && !doc.substring(lastPos, cursor.to).includes("\n") && cursor.node.nextSibling) {
                changes.push({
                  from: removeFrom,
                  to: cursor.from,
                  insert: "\n"
                });
                lastInsertedSpace = cursor.from;
              }
              lastPos = cursor.to;
            }
            removeFrom = cursor.to;
          }
        }
      } else if (node.name == "AnonymousProcedure" && (checkBlock(node.node, "ReporterStatement", doc, lineWidth) || checkBlock(node.node, "ProcedureContent", doc, lineWidth))) {
        for (var name2 of ["ProcedureContent", "ReporterStatement", "CloseBracket"]) {
          node.node.getChildren(name2).map((child) => {
            if (doc[child.from - 1] != "\n") {
              changes.push({
                from: child.from,
                to: child.from,
                insert: "\n"
              });
            }
          });
        }
      } else if (node.name == "OpenParen" && ![" ", "(", "\n"].includes(view.state.sliceDoc(node.from - 1, node.from))) {
        changes.push({ from: node.from, to: node.to, insert: " (" });
      } else if (node.name == "CloseParen" && ![" ", "\n", ")"].includes(view.state.sliceDoc(node.to, node.to + 1))) {
        changes.push({ from: node.from, to: node.to, insert: ") " });
      } else if (node.name == "OpenBracket") {
        let bracket2 = "";
        if (view.state.sliceDoc(node.from - 1, node.from) != " ") {
          bracket2 += " ";
        }
        bracket2 += "[";
        if (![" ", "\n"].includes(view.state.sliceDoc(node.to, node.to + 1))) {
          bracket2 += " ";
        }
        changes.push({ from: node.from, to: node.to, insert: bracket2 });
      } else if (node.name == "CloseBracket") {
        let bracket2 = "";
        if (view.state.sliceDoc(node.from - 1, node.from) != " ") {
          bracket2 += " ";
        }
        bracket2 += "]";
        if (![" ", "\n"].includes(view.state.sliceDoc(node.to, node.to + 1))) {
          bracket2 += " ";
        }
        changes.push({ from: node.from, to: node.to, insert: bracket2 });
      }
      if (["Extensions", "Globals", "BreedsOwn"].includes(node.name)) {
        if (doc.substring(node.from, node.to).includes("\n")) {
          for (var name2 of ["CloseBracket", "Extension", "Identifier"]) {
            node.node.getChildren(name2).map((child) => {
              if (doc[child.from - 1] != "\n" && child.from > 0) {
                changes.push({
                  from: child.from,
                  to: child.from,
                  insert: "\n"
                });
              }
            });
          }
        }
      }
      if (node.name.includes("Args") && !node.name.includes("Special")) {
        let prim = doc.substring(node.from, node.to).toLowerCase();
        changes.push({ from: node.from, to: node.to, insert: prim });
      }
    }
  });
  return changes;
};
var checkBlock = function(node, childName, doc, lineWidth) {
  let count = 0;
  let multiline = doc.substring(node.from, node.to).includes("[\n");
  let multilineChildren = false;
  node.node.getChildren(childName).map((child) => {
    count += 1;
    multiline = doc.substring(child.from, child.to).includes("\n") || doc.substring(child.from, child.to).length > lineWidth || multiline;
    child.getChildren("CommandStatement").map((node2) => {
      node2.getChildren("Arg").map((subnode) => {
        if (subnode.getChildren("CodeBlock").length > 0) {
          multilineChildren = true;
        } else if (subnode.getChildren("AnonymousProcedure").length > 0) {
          multilineChildren = true;
        }
      });
    });
  });
  return (multiline || multilineChildren) && count == 1 || count > 1;
};

// src/features/semantics.ts
import { forEachDiagnostic } from "@codemirror/lint";
import { syntaxTree as syntaxTree22 } from "@codemirror/language";

// src/lang/services/code-snapshot.ts
function BuildSnapshot(Galapagos) {
  Galapagos.UpdateContext();
  var State = Galapagos.GetState();
  var Code = Galapagos.GetCode();
  var Extensions = State.Extensions;
  var Globals = State.Globals;
  var Breeds = /* @__PURE__ */ new Map();
  for (var [Singular, Breed5] of State.Breeds) {
    Breeds.set(Singular, JSON.parse(JSON.stringify(Breed5)));
  }
  var Procedures = /* @__PURE__ */ new Map();
  for (var [Name, Procedure3] of State.Procedures) {
    Procedures.set(Name, JSON.parse(JSON.stringify(Procedure3)));
  }
  return { Code, Extensions, Globals, Breeds, Procedures };
}
function IntegrateSnapshot(Galapagos, Snapshot) {
  for (var [Singular, Breed5] of Snapshot.Breeds) {
    Galapagos.Operations.AppendBreed(Breed5.BreedType, Breed5.Plural, Breed5.Singular);
  }
  for (var [Singular, Breed5] of Snapshot.Breeds) {
    Galapagos.Operations.AppendBreedVariables(Breed5.Plural, Breed5.Variables);
  }
  Galapagos.Operations.AppendGlobals("Extensions", Snapshot.Extensions);
  Galapagos.Operations.AppendGlobals("Globals", Snapshot.Globals);
}

// src/lang/services/fix-generated-code.ts
import { syntaxTree as syntaxTree21 } from "@codemirror/language";
async function FixGeneratedCode(Editor, Source, Parent, try_again = true) {
  Source = Source.trim();
  if (Source == "") return Source;
  if (Source.endsWith(";")) Source = Source.slice(0, -1);
  Editor.SetCode(Source);
  Editor.Semantics.PrettifyAll();
  var Snapshot = BuildSnapshot(Editor);
  var intoProcedure = [];
  let changes = [];
  let state = Editor.CodeMirror.state;
  let comments = [];
  let commentsStart = null;
  let commentFrom = null;
  let procedureStart = null;
  let first = { Globals: null, Extensions: null };
  let breeds = [];
  let globals = [];
  let extensions = [];
  let reservedVars = [...turtleVars, ...patchVars, ...linkVars, ...constants];
  var checkForMisplaced = (node) => {
    if (node.name == "Procedure" && procedureStart == null) {
      procedureStart = node.from;
    } else if (node.name == "Globals" || node.name == "Extensions") {
      if (first[node.name] == null) {
        if (procedureStart != null && procedureStart < node.from) {
          changes.push({
            from: 0,
            to: 0,
            insert: AddComments(state.sliceDoc(node.from, node.to), comments) + "\n\n"
          });
          changes.push({
            from: commentsStart ?? node.from,
            to: node.to,
            insert: ""
          });
          first[node.name] = AddComments(state.sliceDoc(node.from, node.to), comments).length - 1;
          comments = [];
          commentFrom = null;
          commentsStart = null;
          return;
        } else {
          first[node.name] = node.to - 1;
        }
      } else {
        let to_add = state.sliceDoc(node.from, node.to).replace(/globals\s*\[/i, "").replace(/extensions\s*\[/i, "").replace(/\]/, "");
        let index = first[node.name];
        if (index) {
          changes.push({
            from: index,
            to: index,
            insert: " " + to_add
          });
          changes.push({
            from: commentsStart ?? node.from,
            to: node.to,
            insert: ""
          });
          comments = [];
          commentFrom = null;
          commentsStart = null;
          return;
        }
      }
    } else if (procedureStart != null && (node.name == "BreedsOwn" || node.name == "Misplaced" && node.node.resolveInner(node.from, 1).name == "BreedToken")) {
      changes.push({
        from: 0,
        to: 0,
        insert: AddComments(state.sliceDoc(node.from, node.to), comments) + "\n\n"
      });
      changes.push({
        from: commentsStart ?? node.from,
        to: node.to,
        insert: ""
      });
      comments = [];
      commentFrom = null;
      commentsStart = null;
      return;
    }
    if (node.name == "LineComment") {
      comments = [state.sliceDoc(node.from, node.to)];
      commentsStart = node.from;
    } else if (comments.length > 0 && !commentFrom) {
      commentFrom = node.from;
    } else if (comments.length > 0 && commentFrom && node.from > commentFrom) {
      comments = [];
      commentFrom = null;
      commentsStart = null;
    }
  };
  let cursor = syntaxTree21(state).cursor();
  cursor.firstChild();
  if (cursor.node.name == "Normal") {
    if (cursor.firstChild()) {
      checkForMisplaced(cursor.node);
      while (cursor.nextSibling()) {
        checkForMisplaced(cursor.node);
      }
    }
  }
  Editor.Operations.ChangeCode(changes);
  Editor.ForceParse();
  state = Editor.CodeMirror.state;
  changes = [];
  procedureStart = null;
  comments = [];
  commentFrom = null;
  commentsStart = null;
  let lowerdoc = state.doc.toString().toLowerCase();
  syntaxTree21(state).cursor().iterate((noderef) => {
    var _a, _b, _c, _d, _e;
    if (noderef.name == "Misplaced" || noderef.name == "Procedure" && noderef.node.getChildren("To").length == 0) {
      let skip = false;
      Log(noderef.name, noderef.from, commentFrom, comments);
      if (noderef.name == "Misplaced") {
        let grandchild = (_a = noderef.node.firstChild) == null ? void 0 : _a.firstChild;
        if (grandchild && grandchild.name.includes("0Args")) {
          skip = true;
        }
      }
      if (!skip) {
        intoProcedure.push(AddComments(state.sliceDoc(noderef.from, noderef.to), comments));
      }
      changes.push({
        from: commentsStart ?? noderef.from,
        to: Math.min(noderef.to + 1, lowerdoc.length),
        insert: ""
      });
      return false;
    }
    if (noderef.name == "Error") {
      Log(noderef.name, comments);
      changes.push({
        from: commentsStart ?? noderef.from,
        to: noderef.to + 1,
        insert: ""
      });
      changes.push({
        from: 0,
        to: 0,
        insert: AddComments(state.sliceDoc(noderef.from, noderef.to), comments) + "\n"
      });
      return false;
    } else if (noderef.name == "Globals") {
      let len = noderef.node.getChildren("Identifier").length;
      let deleted = 0;
      let temp_changes = [];
      noderef.node.getChildren("Identifier").map((child) => {
        let value = getCodeName(state, child);
        if (globals.includes(value) || reservedVars.includes(value)) {
          temp_changes.push({
            from: child.from,
            to: child.to,
            insert: ""
          });
          deleted += 1;
        }
        globals.push(value);
      });
      if (deleted == len || len == 0) {
        changes.push({
          from: commentsStart ?? noderef.from,
          to: noderef.to + 1,
          insert: ""
        });
      } else {
        changes = changes.concat(temp_changes);
      }
    } else if (noderef.name == "BreedsOwn") {
      let vars = [];
      let len = noderef.node.getChildren("Identifier").length;
      let deleted = 0;
      let temp_changes = [];
      noderef.node.getChildren("Identifier").map((child) => {
        let value = state.sliceDoc(child.from, child.to);
        if (vars.includes(value.toLowerCase()) || reservedVars.includes(value.toLowerCase())) {
          temp_changes.push({
            from: child.from,
            to: child.to,
            insert: ""
          });
          deleted += 1;
        }
        vars.push(value.toLowerCase());
      });
      if (deleted == len || len == 0) {
        changes.push({
          from: commentsStart ?? noderef.from,
          to: noderef.to + 1,
          insert: ""
        });
      } else {
        changes = changes.concat(temp_changes);
      }
    } else if (noderef.name == "Breed") {
      let change = FixBreed(noderef.node, state, breeds);
      if (change != null) {
        changes.push({
          from: change.from,
          to: change.to,
          insert: change.insert
        });
      }
      let plural = noderef.node.getChild("BreedPlural");
      let singular = noderef.node.getChild("BreedSingular");
      if (plural && singular) {
        breeds.push(state.sliceDoc(plural.from, plural.to).toLowerCase());
        breeds.push(state.sliceDoc(singular.from, singular.to).toLowerCase());
      }
    } else if (noderef.name == "Extensions") {
      let len = noderef.node.getChildren("Identifier").length;
      let deleted = 0;
      let temp_changes = [];
      noderef.node.getChildren("Identifier").map((child) => {
        let value = getCodeName(state, child);
        if (lowerdoc.includes("(" + value + ":") || lowerdoc.includes(" " + value + ":") || lowerdoc.includes("\n" + value + ":") || extensions.includes(value)) {
          temp_changes.push({
            from: child.from,
            to: child.to,
            insert: ""
          });
          deleted += 1;
        }
        extensions.push(value);
      });
      if (deleted == len || len == 0) {
        changes.push({
          from: commentsStart ?? noderef.from,
          to: noderef.to + 1,
          insert: ""
        });
      } else {
        changes = changes.concat(temp_changes);
      }
    } else if (noderef.name == "SpecialCommand0Args" && state.sliceDoc(noderef.from, noderef.to).toLowerCase() == "setup") {
      let procedure = (_c = (_b = noderef.node.parent) == null ? void 0 : _b.parent) == null ? void 0 : _c.parent;
      let name2 = procedure == null ? void 0 : procedure.getChild("ProcedureName");
      if ((procedure == null ? void 0 : procedure.name) == "Procedure" && state.sliceDoc(name2 == null ? void 0 : name2.from, name2 == null ? void 0 : name2.to).toLowerCase() == "go") {
        changes.push({
          from: commentsStart ?? noderef.from,
          to: noderef.to + 1,
          insert: ""
        });
      }
    }
    if (noderef.name == "Procedure" && noderef.node.getChildren("ProcedureContent").length == 1) {
      let child = (_e = (_d = noderef.node.getChild("ProcedureContent")) == null ? void 0 : _d.getChild("CommandStatement")) == null ? void 0 : _e.getChild("SpecialCommand0Args");
      if (child && lowerdoc.includes("to " + getCodeName(state, child))) {
        changes.push({
          from: noderef.from,
          to: noderef.to,
          insert: ""
        });
      }
    } else if (noderef.name == "Procedure" && noderef.node.getChildren("ProcedureContent").length == 0) {
      let child = noderef.node.getChild("ProcedureName");
      let name2 = getCodeName(state, child);
      let matches = lowerdoc.match(new RegExp(name2, "gi"));
      if (matches && matches.length == 1) {
        changes.push({ from: noderef.from, to: noderef.to, insert: "" });
      }
    } else if (noderef.name == "ProcedureName") {
    }
    if (!procedureStart && noderef.name == "Procedure") procedureStart = noderef.from;
    if (noderef.name == "LineComment") {
      comments = [state.sliceDoc(noderef.from, noderef.to)];
      commentsStart = noderef.from;
    } else if (comments.length > 0 && !commentFrom) {
      commentFrom = noderef.from;
    } else if (comments.length > 0 && commentFrom && noderef.from > commentFrom) {
      comments = [];
      commentFrom = null;
      commentsStart = null;
    }
  });
  if (intoProcedure.length != 0) {
    changes.push({
      from: procedureStart ?? lowerdoc.length,
      to: procedureStart ?? lowerdoc.length,
      insert: "\nto play\n" + intoProcedure.join("\n") + "\nend\n\n"
    });
  }
  Editor.Operations.ChangeCode(changes);
  let Errors = await Editor.ForceLintAsync();
  console.log(Errors);
  let did_actions = false;
  Errors.map((error) => {
    if (error.actions) {
      did_actions = true;
      error.actions[0].apply(Editor.CodeMirror, error.from, error.to);
    }
  });
  if (did_actions && try_again) await FixGeneratedCode(Editor, Editor.CodeMirror.state.doc.toString(), Parent, false);
  IntegrateSnapshot(Editor, Snapshot);
  if (Parent) IntegrateSnapshot(Editor, Parent);
  Editor.Semantics.PrettifyAll();
  return Editor.GetCode().trim();
}
function FixBreed(node, state, breeds) {
  let singular = node.getChild("BreedSingular");
  let plural = node.getChild("BreedPlural");
  let invalid_sing = ["turtle", "link", "patch", ...breeds].includes(state.sliceDoc(singular == null ? void 0 : singular.from, singular == null ? void 0 : singular.to).toLowerCase()) || state.sliceDoc(singular == null ? void 0 : singular.from, singular == null ? void 0 : singular.to).toLowerCase() == state.sliceDoc(plural == null ? void 0 : plural.from, plural == null ? void 0 : plural.to).toLowerCase();
  let invalid_plur = ["turtles", "links", "patches", ...breeds].includes(
    state.sliceDoc(plural == null ? void 0 : plural.from, plural == null ? void 0 : plural.to).toLowerCase()
  );
  if (singular && plural && invalid_sing && invalid_plur) {
    return {
      from: node.from,
      to: node.to,
      insert: ""
    };
  } else if (singular && invalid_sing) {
    return {
      from: singular == null ? void 0 : singular.from,
      to: singular == null ? void 0 : singular.to,
      insert: getSingularName(state.sliceDoc(plural == null ? void 0 : plural.from, plural == null ? void 0 : plural.to))
    };
  } else if (plural && invalid_plur) {
    return {
      from: plural == null ? void 0 : plural.from,
      to: plural == null ? void 0 : plural.to,
      insert: getPluralName(state.sliceDoc(singular == null ? void 0 : singular.from, singular == null ? void 0 : singular.to))
    };
  } else {
    return null;
  }
}
function AddComments(str, comments) {
  if (comments.length == 0) return str;
  else return comments.join("\n") + "\n" + str;
}

// src/features/semantics.ts
var SemanticFeatures = class {
  /** Constructor: Initialize the editing features. */
  constructor(Galapagos) {
    this.Galapagos = Galapagos;
    this.CodeMirror = Galapagos.CodeMirror;
  }
  // #region "Highlighting"
  /** GetSyntaxTree: Get the syntax tree of the NetLogo code. */
  GetSyntaxTree() {
    return syntaxTree22(this.CodeMirror.state);
  }
  /** SyntaxNodesAt: Iterate through syntax nodes at a certain position. */
  SyntaxNodesAt(Position, Callback) {
    this.GetSyntaxTree().cursorAt(Position).iterate(Callback);
  }
  /** GetRecognizedMode: Get the recognized program mode. */
  GetRecognizedMode() {
    return this.Galapagos.GetState().RecognizedMode;
  }
  /** Highlight: Export the code in the editor into highlighted HTML. */
  Highlight() {
    this.Galapagos.ForceParse();
    return this.HighlightTree(this.GetSyntaxTree(), this.Galapagos.GetCode());
  }
  /** HighlightContent: Highlight a given snippet of code. */
  HighlightContent(Content) {
    return this.HighlightTree(this.Galapagos.Language.language.parser.parse(Content), Content);
  }
  /** HighlightTree: Highlight a parsed syntax tree and a snippet of code. */
  HighlightTree(Tree3, Content) {
    const Container = document.createElement("span");
    this.TraverseNodes(Tree3, Content, (Text2, Style, From, To2) => {
      var Lines = Text2.split("\n");
      for (var I = 0; I < Lines.length; I++) {
        var Line2 = Lines[I];
        var Span = document.createElement("span");
        Span.innerText = Line2;
        if (Style != "") Span.className = Style;
        if (Span.innerHTML != "") Container.appendChild(Span);
        if (I != Lines.length - 1) Container.appendChild(document.createElement("br"));
      }
    });
    return Container;
  }
  /** TraverseNodes: Parse a snippet of code and traverse its syntax nodes. */
  TraverseNodes(Tree3, Content, Callback) {
    let pos = 0;
    highlightTree(Tree3, highlightStyle, (from, to, classes) => {
      from > pos && Callback(Content.slice(pos, from), "", pos, from);
      Callback(Content.slice(from, to), classes, from, to);
      pos = to;
    });
    pos != Tree3.length && Callback(Content.slice(pos, Tree3.length), "", pos, Tree3.length);
  }
  // #endregion
  // #region "Formatting"
  /** Prettify: Prettify the selection of NetLogo code. */
  Prettify() {
    prettify(this.CodeMirror);
  }
  /** PrettifyAll: Prettify all the NetLogo code. */
  PrettifyAll() {
    prettifyAll(this.CodeMirror, this.Galapagos);
  }
  /** PrettifyOrAll: Prettify the selected code. If no code is selected, prettify all. */
  PrettifyOrAll() {
    var Ranges = this.CodeMirror.state.selection.ranges;
    if (Ranges.length == 0 || Ranges[0].from == Ranges[0].to) this.PrettifyAll();
    else this.Prettify();
  }
  /** BuildSnapshot: Build a snapshot of the code. */
  BuildSnapshot() {
    return BuildSnapshot(this.Galapagos);
  }
  /** IntegrateSnapshot: Integrate a snapshot of the code. */
  IntegrateSnapshot(Snapshot) {
    return IntegrateSnapshot(this.Galapagos, Snapshot);
  }
  /** FixGeneratedCode: Try to fix and prettify a piece of generated code. */
  async FixGeneratedCode(Source, Parent) {
    return FixGeneratedCode(this.Galapagos, Source, Parent);
  }
  // #endregion
  // #region "Linting"
  /** ForEachDiagnostic: Loop through all linting diagnostics throughout the code. */
  ForEachDiagnostic(Callback) {
    forEachDiagnostic(this.CodeMirror.state, Callback);
  }
  // #endregion
};

// src/editor.ts
import { basicSetup } from "codemirror";

// src/codemirror/cp-widget-extension.ts
import { WidgetType as WidgetType3, Decoration as Decoration3, ViewPlugin as ViewPlugin2 } from "@codemirror/view";
import { syntaxTree as syntaxTree23 } from "@codemirror/language";
import { ColorPicker } from "@netlogo/netlogo-color-picker";
import * as colors from "@netlogo/netlogo-color-picker/dist/helpers/colors.js";
var savedColors = [];
function extractRGBValues(rgbString) {
  const regex = /rgba?\((\d{1,3}),\s*(\d{1,3}),\s*(\d{1,3})(?:,\s*(\d{1,3}|\d\.\d+))?\)/;
  const match = rgbString.match(regex);
  if (match) {
    let values = match.slice(1, 4).map(Number);
    const alpha = match[4] === void 0 ? 255 : Number(match[4]);
    values.push(alpha);
    return values;
  }
  return [];
}
var ColorPickerWidget = class extends WidgetType3 {
  constructor(color, length, type) {
    super();
    this.color = color;
    this.length = length;
    this.colorType = type;
  }
  getColor() {
    return this.color;
  }
  getLength() {
    return this.length;
  }
  getColorType() {
    return this.colorType;
  }
  /** toDOM: defines the DOM appearance of the widget. Not connected to the widget as per CodeMirror documentation */
  toDOM() {
    let wrap = document.createElement("span");
    wrap.setAttribute("aria-hidden", "true");
    wrap.className = "cp-widget-wrap";
    wrap.style.position = "relative";
    wrap.style.display = "inline-block";
    let box = wrap.appendChild(document.createElement("div"));
    box.style.width = "0.5rem";
    box.style.height = "0.5rem";
    box.style.border = "1px solid gray";
    box.style.borderRadius = "20%";
    box.style.backgroundColor = this.color;
    box.style.display = "inline-block";
    box.style.marginLeft = "0.3rem";
    box.style.marginRight = "0.3rem";
    box.style.verticalAlign = "middle";
    box.classList.add("cp-widget-box");
    let clickable = wrap.appendChild(document.createElement("div"));
    clickable.style.position = "absolute";
    clickable.style.top = "0";
    clickable.style.left = "0.125rem";
    clickable.style.border = "1rem solid transparent";
    clickable.style.top = "50%";
    clickable.style.left = "50%";
    clickable.style.transform = "translate(-50%, -50%)";
    clickable.style.cursor = "pointer";
    return wrap;
  }
  ignoreEvent(event) {
    return false;
  }
};
function testValidColor(content2) {
  content2 = content2.trim();
  if (!content2) return [""];
  let number2 = Number(content2);
  if (!isNaN(number2) && number2 >= 0 && number2 < 140) return [colors.netlogoToRGB(number2), "numeric"];
  if (colors.baseColorsToRGB[content2]) return [colors.baseColorsToRGB[content2], "compound"];
  const rgbRegex = /^rgb\s+(\d+)\s+(\d+)\s+(\d+)$/i;
  const rgbMatch = content2.match(rgbRegex);
  if (rgbMatch) {
    const [_, r, g, b] = rgbMatch;
    const rgbValues = [Number(r), Number(g), Number(b)];
    if (rgbValues.every((v) => v >= 0 && v <= 255)) {
      return [`rgb(${rgbValues.join(",")})`, "rgbFn"];
    }
  }
  const hsbRegex = /^hsb\s+(\d+)\s+(\d+)\s+(\d+)$/i;
  const hsbMatch = content2.match(hsbRegex);
  if (hsbMatch) {
    const [_, h, s, b] = hsbMatch;
    const hsbValues = [Number(h), Number(s), Number(b)];
    if (hsbValues[0] >= 0 && hsbValues[0] <= 360 && hsbValues[1] >= 0 && hsbValues[1] <= 100 && hsbValues[2] >= 0 && hsbValues[2] <= 100) {
      const rgbValues = colors.HSBAToRGBA(hsbValues[0], hsbValues[1], hsbValues[2], 255).slice(0, -1);
      return [`rgb(${rgbValues.join(",")})`, "hsbFn"];
    }
  }
  let arrAsRGB = colors.netlogoArrToRGB(content2);
  if (arrAsRGB) {
    const colorType = arrAsRGB.startsWith("rgba") ? "rgbaArr" : "rgbArr";
    return [arrAsRGB, colorType];
  }
  return [colors.compoundToRGB(content2), "compound"];
}
function colorWidgets(view, posToWidget) {
  let widgets = [];
  for (let { from, to } of view.visibleRanges) {
    syntaxTree23(view.state).iterate({
      from,
      to,
      enter: (node) => {
        if (node.name == "VariableName") {
          let nodeStr = view.state.doc.sliceString(node.from, node.to);
          if (nodeStr.includes("color")) {
            let sibling = node.node.nextSibling;
            if (sibling) {
              let color = testValidColor(view.state.doc.sliceString(sibling.from, sibling.to));
              if (color[0] == "") {
                return;
              }
              let color_end = sibling.to;
              let color_start = sibling.from;
              if (color[1] == "compound") {
                let colorStr = view.state.doc.sliceString(sibling.from, sibling.to);
                let colorStrArr = colorStr.split(" ");
                if (colorStrArr.length > 3) {
                  let spaceIndex = colorStr.indexOf(colorStrArr[2]);
                  color_end = sibling.from + spaceIndex + colorStrArr[2].length;
                }
              }
              let cpWidget = new ColorPickerWidget(color[0], color_end - color_start, color[1]);
              let deco = Decoration3.widget({
                widget: cpWidget,
                side: 1
              });
              widgets.push(deco.range(color_end));
              posToWidget.set(sibling.to, cpWidget);
            }
          }
        }
      }
    });
  }
  return Decoration3.set(widgets);
}
function initializeColorPicker(view, pos, widget, OnColorPickerCreate) {
  var _a;
  const cpExist = document.querySelector("#colorPickerDiv");
  if (cpExist) {
    return -1;
  }
  let cpDiv = document.createElement("div");
  document.body.appendChild(cpDiv);
  const findAndSetCP = function() {
    cpDiv.id = "colorPickerDiv";
    cpDiv.style.position = "absolute";
    cpDiv.style.display = "flex";
    cpDiv.style.justifyContent = "center";
    cpDiv.style.alignItems = "center";
    const x = window.scrollX || document.documentElement.scrollLeft;
    const y = window.scrollY || document.documentElement.scrollTop;
    const viewportW = window.innerWidth;
    const viewportY = window.innerHeight;
    cpDiv.style.width = Math.max(384, viewportW) + "px";
    cpDiv.style.height = Math.max(444.8, viewportY) + "px";
    cpDiv.style.left = `${x}px`;
    cpDiv.style.top = `${y}px`;
    document.body.appendChild(cpDiv);
  };
  findAndSetCP();
  const colorPickerConfig = {
    parent: cpDiv,
    initColor: extractRGBValues(widget.getColor()),
    onColorSelect: (cpReturn) => {
      let newValue = "";
      const selectedColor = cpReturn[0].rgba;
      savedColors = cpReturn[1];
      switch (widget.getColorType()) {
        case "compound":
          newValue = colors.netlogoToCompound(colors.rgbToNetlogo(selectedColor));
          break;
        case "numeric":
          newValue = colors.rgbToNetlogo(selectedColor).toString();
          break;
        case "rgbArr":
          if (selectedColor[3] == 255) {
            newValue = `[${selectedColor[0]} ${selectedColor[1]} ${selectedColor[2]}]`;
          } else {
            newValue = `[${selectedColor[0]} ${selectedColor[1]} ${selectedColor[2]} ${selectedColor[3]}]`;
          }
          break;
        case "rgbaArr":
          newValue = `[${selectedColor[0]} ${selectedColor[1]} ${selectedColor[2]} ${selectedColor[3]}]`;
          break;
        case "rgbFn":
          newValue = `rgb ${selectedColor[0]} ${selectedColor[1]} ${selectedColor[2]}`;
          break;
        case "hsbFn":
          const asHsb = colors.RGBAToHSBA(selectedColor[0], selectedColor[1], selectedColor[2], 255).slice(0, -1);
          newValue = `hsb ${asHsb[0]} ${asHsb[1]} ${asHsb[2]}`;
          break;
      }
      let change = {
        from: pos - widget.getLength(),
        to: pos,
        insert: newValue
      };
      view.dispatch({ changes: change });
      destroyColorPicker();
    },
    savedColors
  };
  let openTo = "grid";
  if (widget.getColorType() == "rgbArr" || widget.getColorType() == "rgbFn") {
    openTo = "slider";
  }
  if (widget.getColorType() == "hsbFn") {
    openTo = "sliderHSB";
  }
  const colorPicker = new ColorPicker(colorPickerConfig, openTo);
  cpDiv.addEventListener("click", handleOutsideClick);
  if (OnColorPickerCreate) OnColorPickerCreate(cpDiv);
  (_a = navigator.virtualKeyboard) == null ? void 0 : _a.hide();
  view.contentDOM.blur();
  document.querySelectorAll(".cm-tooltip-hover").forEach((hover) => hover.setAttribute("style", "display: none;"));
  return 0;
}
function destroyColorPicker() {
  const cpDiv = document.querySelector("#colorPickerDiv");
  if (cpDiv) {
    cpDiv.removeEventListener("click", handleOutsideClick);
    cpDiv.remove();
  }
}
function handleOutsideClick(event) {
  const cpDiv = event.currentTarget;
  if (event.target === cpDiv) {
    destroyColorPicker();
  }
}
function createColorPickerPlugin(OnColorPickerCreate) {
  return ViewPlugin2.fromClass(
    class {
      constructor(view) {
        // timeout used to revert Color Picker interactability
        this.timeout = null;
        this.posToWidget = /* @__PURE__ */ new Map();
        this.decorations = colorWidgets(view, this.posToWidget);
      }
      update(update) {
        if (update.docChanged || update.viewportChanged || syntaxTree23(update.startState) != syntaxTree23(update.state)) {
          this.posToWidget.clear();
          this.decorations = colorWidgets(update.view, this.posToWidget);
        }
        if (update.selectionSet) {
          const selectionPos = update.state.selection.main.head;
          if (!this.isAtColorWidget(update.view, selectionPos)) {
            this.setWidgetsInteractability(update.view, "none");
            this.revertWidgetsInteractability(update.view, 1e3);
          }
        }
      }
      /** revertWidgetsInteractability: when called, reverts the widgetInteractability to auto after 300ms. If it is called within 300ms, reset the revert timer.  */
      revertWidgetsInteractability(view, delay = 1e3) {
        const self = this;
        const revert = () => {
          if (self.timeout !== null) {
            clearTimeout(self.timeout);
          }
          self.timeout = setTimeout(() => {
            self.setWidgetsInteractability(view, "auto");
            self.timeout = null;
          }, delay);
        };
        return revert();
      }
      //isAtColorWidget: checks if the cursor is at a color widget
      isAtColorWidget(view, cursorPos) {
        for (let widgetPos of this.posToWidget.keys()) {
          if (Math.abs(cursorPos - widgetPos) == 0) {
            return true;
          }
        }
        return false;
      }
      /** setWidgetsInteractability: sets the pointerEvents of the wrapper to the given value. */
      setWidgetsInteractability(view, pointerValue) {
        view.dom.querySelectorAll(".cp-widget-wrap").forEach((el) => {
          if (el instanceof HTMLElement) {
            el.style.pointerEvents = pointerValue;
          }
        });
      }
    },
    {
      decorations: (v) => v.decorations,
      eventHandlers: {
        mousedown: function(e, view) {
          destroyColorPicker();
        },
        touchstart: function(e, view) {
          let touch = e.touches[0];
          destroyColorPicker();
        },
        mouseup: function(e, view) {
          let target = e.target;
          if (target.nodeName == "DIV" && target.parentElement.classList.contains("cp-widget-wrap")) {
            e.preventDefault();
            initializeColorPicker(
              view,
              view.posAtDOM(target),
              this.posToWidget.get(view.posAtDOM(target)),
              OnColorPickerCreate
            );
          }
        },
        touchend: function(e, view) {
          let touch = e.touches[0];
          if (!touch) return;
          let target = touch.target;
          if (target.nodeName == "DIV" && target.parentElement.classList.contains("cp-widget-wrap")) {
            e.preventDefault();
            initializeColorPicker(
              view,
              view.posAtDOM(target),
              this.posToWidget.get(view.posAtDOM(target)),
              OnColorPickerCreate
            );
          }
        }
      }
    }
  );
}

// src/editor.ts
var GalapagosEditor3 = class {
  /** Constructor: Create an editor instance. */
  constructor(Parent, Options) {
    /** Linters: The linters used in this instance. */
    this.Linters = [];
    /** LineWidth: The width of the line, used for prettying. */
    this.LineWidth = 50;
    /** IsReadOnly: Whether the editor is readonly. */
    this.IsReadOnly = false;
    // #endregion
    // #region "Context Sharing"
    /** ID: ID of the editor. */
    this.ID = 0;
    /** Children: The connected editors. */
    this.Children = [];
    /** NextChildID: The next child ID. */
    this.NextChildID = 0;
    /** ParentEditor: The parent editor of this instance. */
    this.ParentEditor = null;
    /** PreprocessContext: The combined preprocessed context of this editor. */
    this.PreprocessContext = new PreprocessContext();
    /** LintContext: The combined main parsing context of this editor. */
    this.LintContext = new LintContext();
    /** Version: Version of the state (for linter cache). */
    this.Version = 0;
    /** IsVisible: Whether this editor is visible. */
    this.IsVisible = true;
    this.Editable = new Compartment();
    this.Parent = Parent;
    this.Options = Options;
    const Extensions = [
      // Editor
      basicSetup,
      lightTheme,
      // Readonly
      this.Editable.of(EditorView8.editable.of(!this.Options.ReadOnly)),
      // Events
      updateExtension((Update) => this.onUpdate(Update)),
      highlight,
      // indentExtension
      keymap2.of([indentWithTab])
    ];
    switch (Options.Language) {
      case 1 /* Javascript */:
        this.Language = javascript();
        break;
      case 3 /* CSS */:
        this.Language = css();
        break;
      case 2 /* HTML */:
        this.Language = html();
        break;
      default:
        this.Language = NetLogo(this);
        Extensions.push(preprocessStateExtension);
        Extensions.push(stateExtension);
        Extensions.push(buildToolTips(this));
        Dictionary.ClickHandler = Dictionary.ClickHandler ?? Options.OnDictionaryClick;
        this.Linters = netlogoLinters.map((linter3) => buildLinter(linter3, this));
        Extensions.push(...this.Linters);
        Extensions.push(linter2(CompilerLinter));
        Extensions.push(linter2(RuntimeLinter));
        Extensions.push(lintGutter());
    }
    Extensions.push(this.Language);
    if (Options.OnColorPickerCreate) Extensions.push(createColorPickerPlugin(Options.OnColorPickerCreate));
    var KeyBindings = Options.KeyBindings ?? [];
    if (this.Options.OneLine) {
      KeyBindings.push({ key: "Enter", run: () => true });
    }
    KeyBindings.push({ key: "Tab", run: acceptCompletion });
    if (!this.Options.OneLine) {
      KeyBindings.push(indentWithTab);
    }
    Extensions.push(Prec.highest(keymap2.of(KeyBindings)));
    Extensions.push(
      EditorView8.domEventHandlers({
        keydown: (Event) => {
          var _a;
          return (_a = Options.OnKeyDown) == null ? void 0 : _a.call(Options, Event, this);
        },
        keyup: (Event) => {
          var _a;
          return (_a = Options.OnKeyUp) == null ? void 0 : _a.call(Options, Event, this);
        },
        click: (Event) => {
          var _a;
          return (_a = Options.OnClick) == null ? void 0 : _a.call(Options, Event, this);
        }
      })
    );
    if (this.Options.Wrapping) Extensions.push(EditorView8.lineWrapping);
    if (this.Options.Placeholder) Extensions.push(placeholder(this.Options.Placeholder));
    this.CodeMirror = new EditorView8({
      extensions: Extensions,
      parent: Parent
    });
    this.GetPreprocessState().SetEditor(this);
    this.Options.ParseMode = this.Options.ParseMode ?? "Normal" /* Normal */;
    this.GetState(false).Mode = this.Options.ParseMode;
    this.GetState(false).Preprocess = this.PreprocessContext;
    this.Editing = new EditingFeatures(this);
    this.Selection = new SelectionFeatures(this);
    this.Semantics = new SemanticFeatures(this);
    this.Operations = new CodeEditing(this.CodeMirror);
    const el = this.Parent.getElementsByClassName("cm-content")[0];
    el.setAttribute("data-enable-grammarly", "false");
  }
  // #region "Editor Statuses"
  /** GetState: Get the current parser state of the NetLogo code. */
  GetState(Refresh) {
    if (Refresh) this.UpdateContext();
    return this.CodeMirror.state.field(stateExtension);
  }
  /** GetPreprocessState: Get the preprocess parser state of the NetLogo code. */
  GetPreprocessState() {
    return this.CodeMirror.state.field(preprocessStateExtension);
  }
  // #endregion
  // #region "Editor API"
  /** SetCode: Set the code of the editor. */
  SetCode(code) {
    this.CodeMirror.dispatch({
      changes: { from: 0, to: this.CodeMirror.state.doc.length, insert: code }
    });
  }
  /** GetCode: Get the code from the editor. */
  GetCode() {
    return this.CodeMirror.state.doc.toString();
  }
  /** GetCodeSlice: Returns a slice of code from the editor. */
  GetCodeSlice(Start, End2) {
    return this.CodeMirror.state.sliceDoc(Start, End2);
  }
  /** SetReadOnly: Set the readonly status for the editor. */
  SetReadOnly(Status) {
    this.IsReadOnly = Status;
    this.CodeMirror.dispatch({
      effects: this.Editable.reconfigure(EditorView8.editable.of(!Status))
    });
    if (Status) {
      document.querySelector(".cm-editor").style.backgroundColor = "#f5f5f5";
      document.querySelector(".cm-editor").style.color = "#888";
    } else {
      document.querySelector(".cm-editor").style.backgroundColor = "#fff";
      document.querySelector(".cm-editor").style.color = "#000";
    }
  }
  /** AddChild: Add a child editor. */
  AddChild(Child) {
    if (Child.Children.length > 0) throw new Error("Cannot add an editor that already has children as child.");
    this.Children.push(Child);
    Child.ID = ++this.NextChildID;
    Child.ParentEditor = this;
    Child.CodeMirror.state.field(stateExtension).EditorID = Child.ID;
    if (Child.Options.ParseMode !== "Generative" /* Generative */) {
      Child.LintContext = this.LintContext;
      Child.PreprocessContext = this.PreprocessContext;
      Child.GetState(false).Preprocess = this.PreprocessContext;
    }
  }
  /** RemoveChild: Remove a child editor. */
  RemoveChild(Child) {
    if (Child.ParentEditor !== this) throw new Error("Cannot remove an editor that is not my child.");
    var Index = this.Children.indexOf(Child);
    if (Index === -1) throw new Error("Cannot remove an editor that is not my child.");
    this.Children.splice(Index, 1);
    Child.ParentEditor = null;
    if (Child.Options.ParseMode !== "Generative" /* Generative */) {
      Child.LintContext = new LintContext();
      Child.PreprocessContext = new PreprocessContext();
      Child.GetState(false).Preprocess = Child.PreprocessContext;
    }
  }
  /** GetChild: Get the child editor by ID. */
  GetChild(ID) {
    if (ID == this.ID) return this;
    return this.Children.find((child) => child.ID == ID);
  }
  /** Detach: Detach the editor from its parent. */
  Detach() {
    if (this.ParentEditor == null) throw new Error("Cannot remove an editor that is not a child.");
    this.ParentEditor.RemoveChild(this);
  }
  /** SyncContext: Sync the context of the child editor. */
  SyncContext(Child) {
    Child.LintContext = this.LintContext;
    Child.PreprocessContext = this.PreprocessContext;
    Child.GetState(false).Preprocess = this.PreprocessContext;
  }
  /** Blur: Make the editor lose the focus (if any). */
  Blur() {
    this.CodeMirror.contentDOM.blur();
  }
  /** Focus: Make the editor gain the focus (if possible). */
  Focus() {
    this.CodeMirror.focus();
  }
  /** CloseCompletion: Forcible close the auto completion. */
  CloseCompletion() {
    closeCompletion(this.CodeMirror);
  }
  /** SetWidgetVariables: Sync the widget-defined global variables to the syntax parser/linter. */
  SetWidgetVariables(Variables, ForceLint) {
    if (this.ParentEditor != null) throw new Error("Cannot set widget variables on a child editor.");
    var State = this.GetState();
    var Current = State.WidgetGlobals;
    var Changed = Current.length != Variables.length;
    if (!Changed) {
      for (var I = 0; I < Variables.length; I++) {
        if (Current[I] != Variables[I]) {
          Changed = true;
          break;
        }
      }
    }
    if (Changed) {
      State.WidgetGlobals = Variables.map((str) => str.toLowerCase());
      State.SetDirty();
      if (this.Options.ParseMode == "Normal" /* Normal */) this.UpdateContext();
      else this.UpdateSharedContext();
      if (ForceLint) this.ForceLint();
    }
  }
  /** SetMode: Set the parsing mode of the editor. */
  SetMode(Mode, ForceLint) {
    var State = this.GetState();
    var Current = State.Mode;
    if (Current != Mode) {
      State.Mode = Mode;
      this.UpdateContext();
      if (ForceLint) this.ForceLint();
    }
  }
  /** SetCompilerErrors: Sync the compiler errors and present it on the editor. */
  // TODO: Some errors come with start 2147483647, which needs to be rendered as a tip without position.
  SetCompilerErrors(Errors) {
    var State = this.GetState();
    if (State.CompilerErrors.length == 0 && State.RuntimeErrors.length == 0 && Errors.length == 0) return;
    this.FixUnknownErrors(Errors);
    State.CompilerErrors = Errors;
    State.RuntimeErrors = [];
    this.ForceLint();
    if (Errors.length > 0) this.Selection.SetCursorPosition(Errors[0].start);
  }
  /** SetCompilerErrors: Sync the runtime errors and present it on the editor. */
  SetRuntimeErrors(Errors) {
    var State = this.GetState();
    if (State.RuntimeErrors.length == 0 && Errors.length == 0) return;
    this.FixUnknownErrors(Errors);
    State.RuntimeErrors = Errors;
    this.ForceLint();
    if (Errors.length > 0) this.Selection.SetCursorPosition(Errors[0].start);
  }
  /** FixUnknownErrors: Fix the unknown errors. */
  FixUnknownErrors(Errors) {
    var Code = this.GetCode();
    var FirstBreak = Code.indexOf("\n");
    if (FirstBreak === -1) FirstBreak = Code.length;
    Errors.forEach((Error2) => {
      if (Error2.start == 2147483647) {
        Error2.start = 0;
        Error2.end = FirstBreak;
      } else {
        try {
          Error2.code = Code.slice(Error2.start, Error2.end);
        } catch {
        }
      }
    });
  }
  /** SetContext: Set the context of the editor for one-line modes. */
  SetContext(context) {
    if ((this.Options.ParseMode == "Oneline" /* Oneline */ || this.Options.ParseMode == "Reporter" /* Reporter */) && this.GetState(false).SetContext(context)) {
      this.ForceParse();
      this.ForceLint();
    }
  }
  /** GetID: Get ID of the editor. */
  GetID() {
    return this.ID;
  }
  /** GetVersion: Get version of the state. */
  GetVersion() {
    return this.Version;
  }
  /** SetVisible: Set the visibility status of the editor. */
  SetVisible(status) {
    if (this.IsVisible == status) return;
    this.IsVisible = status;
    if (this.IsVisible) this.ForceLint();
  }
  /** GetChildren: Get the logical children of the editor. */
  GetChildren() {
    if (this.Options.ParseMode == "Generative" /* Generative */) {
      if (this.ParentEditor) return [this, this.ParentEditor];
    } else if (this.Options.ParseMode == "Normal" /* Normal */) return [...this.Children, this];
    return [this];
  }
  /** UpdateContext: Try to update the context of this editor. */
  UpdateContext() {
    const State = this.CodeMirror.state.field(stateExtension);
    if (!State.GetDirty()) return false;
    this.ForceParse();
    this.Version += 1;
    State.ParseState(this.CodeMirror.state);
    if (!this.ParentEditor || this.Options.ParseMode == "Generative" /* Generative */) {
      this.UpdateSharedContext();
    } else if (this.ParentEditor && this.Options.ParseMode == "Normal" /* Normal */) {
      this.ParentEditor.UpdateContext();
    }
    return true;
  }
  /** UpdateSharedContext: Update the shared context of the editor. */
  UpdateSharedContext() {
    var mainLint = this.LintContext.Clear();
    for (var child of this.GetChildren()) {
      let state = child.CodeMirror.state.field(stateExtension);
      for (var name2 of state.Extensions) mainLint.Extensions.set(name2, child.ID);
      for (var name2 of state.Globals) mainLint.Globals.set(name2, child.ID);
      for (var name2 of state.WidgetGlobals) mainLint.WidgetGlobals.set(name2, child.ID);
      for (var [name2, procedure] of state.Procedures) {
        procedure.EditorID = child.ID;
        mainLint.Procedures.set(name2, procedure);
      }
      for (var [name2, breed] of state.Breeds) {
        breed.EditorID = child.ID;
        var current = mainLint.Breeds.get(name2);
        if (!current) {
          current = new Breed(breed.Singular, breed.Plural, [...breed.Variables], breed.BreedType);
          mainLint.Breeds.set(name2, current);
        } else {
          var variables = current.Variables;
          breed.Variables.forEach((variable) => {
            if (!variables.includes(variable)) variables.push(variable);
          });
        }
      }
    }
    this.RefreshContexts();
  }
  /** RefreshContexts: Refresh contexts of the editor. */
  RefreshContexts() {
    if (this.IsVisible) {
      this.ForceParse(false);
      this.ForceLint();
    }
    for (var child of this.Children) {
      child.Version += 1;
      child.RefreshContexts();
    }
  }
  /** UpdatePreprocessContext: Try to update the context of this editor. */
  UpdatePreprocessContext() {
    this.Version += 1;
    if (!this.ParentEditor || this.Options.ParseMode == "Generative" /* Generative */) {
      this.UpdateSharedPreprocess();
    } else if (this.ParentEditor && this.Options.ParseMode == "Normal" /* Normal */) {
      this.ParentEditor.UpdatePreprocessContext();
    }
    return true;
  }
  /** UpdateSharedPreprocess: Update the shared preprocess context of the editor. */
  UpdateSharedPreprocess() {
    var mainPreprocess = this.PreprocessContext.Clear();
    for (var child of this.GetChildren()) {
      if (child.Options.ParseMode == "Normal" /* Normal */ || child == this) {
        let preprocess = child.CodeMirror.state.field(preprocessStateExtension);
        for (var I = 0; I < preprocess.PluralBreeds.length; I++) {
          var Plural = preprocess.PluralBreeds[I];
          var Singular = preprocess.SingularBreeds[I];
          var Type = preprocess.BreedTypes[I];
          mainPreprocess.PluralBreeds.set(Plural, child.ID);
          mainPreprocess.SingularBreeds.set(Singular, child.ID);
          mainPreprocess.PluralToSingulars.set(Plural, Singular);
          mainPreprocess.SingularToPlurals.set(Singular, Plural);
          mainPreprocess.BreedTypes.set(Plural, Type);
        }
        for (var [p, vars] of preprocess.BreedVars) {
          for (var variable of vars) {
            mainPreprocess.BreedVars.set(variable, child.ID);
            let vars2 = mainPreprocess.BreedVarToPlurals.has(variable) ? mainPreprocess.BreedVarToPlurals.get(variable) ?? [] : [];
            vars2.push(p);
            mainPreprocess.BreedVarToPlurals.set(variable, vars2);
          }
        }
        for (var [p, num_args] of preprocess.Commands) {
          mainPreprocess.Commands.set(p, num_args);
          mainPreprocess.CommandsOrigin.set(p, child.ID);
        }
        for (var [p, num_args] of preprocess.Reporters) {
          mainPreprocess.Reporters.set(p, num_args);
          mainPreprocess.ReportersOrigin.set(p, child.ID);
        }
      }
    }
  }
  // #endregion
  // #region "Linting and Parsing"
  /** ForceLintAsync: Force the editor to lint without rendering. */
  async ForceLintAsync() {
    var Diagnostics = [];
    for (var Extension2 of this.Linters) {
      var Results = await Promise.resolve(Extension2.Source(this.CodeMirror));
      Diagnostics.push(...Results);
    }
    return Diagnostics;
  }
  /** ForceParse: Force the editor to finish any parsing. */
  ForceParse(SetDirty = true) {
    forceParsing(this.CodeMirror, this.CodeMirror.state.doc.length, 1e5);
    if (SetDirty) this.CodeMirror.state.field(stateExtension).SetDirty();
  }
  /** ForceLint: Force the editor to do another round of linting. */
  ForceLint() {
    const plugins = this.CodeMirror.plugins;
    for (var I = 0; I < plugins.length; I++) {
      if (plugins[I].value.hasOwnProperty("lintTime")) {
        plugins[I].value.set = true;
        plugins[I].value.force();
        break;
      }
    }
  }
  // #endregion
  // #region "Event Handling"
  /** onUpdate: Handle the Update event. */
  onUpdate(update) {
    if (update.docChanged) this.SetCompilerErrors([]);
    if (this.Options.OnUpdate != null) this.Options.OnUpdate(update.docChanged, update);
    if (update.focusChanged) {
      if (this.CodeMirror.hasFocus) {
        if (this.Options.OnFocused != null) this.Options.OnFocused(this.CodeMirror);
      } else {
        if (this.Options.OnBlurred != null) this.Options.OnBlurred(this.CodeMirror);
      }
    }
  }
  // #endregion
};
var Localized = new LocalizationManager();
try {
  window.GalapagosEditor = GalapagosEditor3;
  window.EditorLocalized = Localized;
} catch (error) {
}

// src/server.ts
var html2 = `
  <!doctype html>
  <html>
    <head>
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
      <title>CM6 demo</title>
      <style>
        body {
          background-color: #300a24;
          color: white;
          font-family: monospace;
        }
        .cm-keyword,
        .cm-comment,
        .cm-bracket,
        .cm-attribute,
        .CodeMirror-matchingbracket {
          color: #34e2e2; /* neon blue */
        }
      </style>
    </head>
    <body>
      <div id="editor"></div>
      <script src="./build/demo_built.js"></script>
    </body>
  </html>
`;
var dom = new JSDOM(html2);
var document2 = dom.window.document;
document2.getSelection = () => ({});
var globalAny = global;
globalAny.document = document2;
Object.defineProperty(global, "navigator", {
  value: {},
  writable: true,
  configurable: true
});
var windowObj = {
  addEventListener: (type, listener) => {
  },
  removeEventListener: (type, listener) => {
  },
  dispatchEvent: (event) => true,
  requestAnimationFrame: (callback) => setTimeout(callback, 0),
  cancelAnimationFrame: (handle) => clearTimeout(handle),
  document: document2,
  getComputedStyle: (elt2) => ({
    lineHeight: "1.2",
    fontSize: "12px"
  }),
  innerHeight: 768,
  innerWidth: 1024,
  scrollX: 0,
  scrollY: 0,
  devicePixelRatio: 1
};
Object.defineProperty(windowObj, "window", {
  value: windowObj,
  writable: true,
  configurable: true
});
globalAny.window = windowObj;
var documentObj = dom.window.document;
documentObj.getSelection = () => ({
  rangeCount: 0,
  addRange: () => {
  },
  removeAllRanges: () => {
  },
  getRangeAt: () => null,
  createRange: () => ({
    getBoundingClientRect: () => ({
      top: 0,
      left: 0,
      right: 0,
      bottom: 0,
      width: 0,
      height: 0
    }),
    getClientRects: () => ({
      length: 1,
      item: () => ({
        top: 0,
        left: 0,
        right: 0,
        bottom: 0,
        width: 0,
        height: 0
      }),
      [0]: {
        top: 0,
        left: 0,
        right: 0,
        bottom: 0,
        width: 0,
        height: 0
      }
    })
  })
});
Object.defineProperty(documentObj, "defaultView", {
  value: windowObj,
  writable: true,
  configurable: true
});
Object.defineProperty(documentObj, "documentElement", {
  value: documentObj.querySelector("html"),
  writable: true,
  configurable: true
});
globalAny.document = documentObj;
var MockMutationObserver = class {
  constructor(callback) {
    this.callback = callback;
  }
  observe() {
  }
  disconnect() {
  }
  takeRecords() {
    return [];
  }
};
globalAny.MutationObserver = MockMutationObserver;
globalAny.EditorDictionary = {
  Initialize: () => {
  }
};
var app = express();
var port = process.env.PORT || 3e3;
app.use(cors());
app.use(bodyParser.json());
app.use(bodyParser.text());
globalAny.requestAnimationFrame = () => {
};
app.post("/prettify", (req, res) => {
  try {
    const { code } = req.body;
    if (!code || typeof code !== "string") {
      res.status(400).json({ error: 'Please provide NetLogo code as a string in the request body under the "code" key' });
      return;
    }
    console.log("Creating editor element...");
    const editorElement = document2.createElement("div");
    editorElement.id = "editor";
    if (!editorElement) {
      throw new Error("Editor element not found");
    }
    document2.body.appendChild(editorElement);
    console.log("Editor element created and appended");
    console.log("Initializing GalapagosEditor...");
    const editor = new GalapagosEditor3(editorElement, {
      Language: 0 /* NetLogo */,
      ParseMode: "Normal" /* Normal */,
      OnUpdate: (Changed, Update) => {
        if (Changed) console.log("Editor Update:", Update);
      },
      OnExplain: (Message, Context) => {
        console.log("Editor Explain:", Message, Context);
      }
    });
    console.log("GalapagosEditor initialized");
    try {
      console.log("Setting code in editor...");
      editor.SetCode(code);
      console.log("Code set successfully");
      console.log("Forcing parse...");
      editor.ForceParse();
      console.log("Parse complete");
      console.log("Prettifying code...");
      editor.Semantics.PrettifyAll();
      console.log("Prettification complete");
      console.log("Getting formatted code...");
      const formattedCode = editor.GetCode();
      console.log("Formatted code retrieved");
      res.json({
        formatted: formattedCode
      });
    } catch (innerErr) {
      console.error("Error during editor operations:", innerErr);
      throw innerErr;
    }
  } catch (err) {
    const error = err;
    console.error("Error formatting code:", error);
    console.error("Error stack:", error.stack);
    res.status(500).json({
      error: "An error occurred while formatting the code",
      details: error.message,
      stack: error.stack
    });
  }
});
app.get("/", (req, res) => {
  res.send("Hello World");
});
app.listen(port, () => {
  console.log(`Server is running on port ${port}`);
});
//# sourceMappingURL=server.js.map
